{"task_id": "notgate", "task_number": 61, "description": "Create a module that implements a NOT gate.", "header": "module top_module(\n\tinput in,\n\toutput out\n);\n", "module_code": "module top_module(\n\tinput in,\n\toutput out\n);\n\t\n\tassign out = ~in;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput in,\n\toutput out\n);\n\t\n\tassign out = ~in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tin <= 1'b0;\n\t\twavedrom_start(\"Inversion\");\n\t\trepeat(20) @(posedge clk)\n\t\t\tin <= $random;\t\t\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "fsm_onehot", "task_number": 62, "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "header": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "module_code": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[9];\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[9];\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic in,\n\toutput logic [9:0] state,\n\tinput tb_match,\n\tinput [9:0] next_state_ref,\n\tinput [9:0] next_state_dut,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tint errored1 = 0;\n\tint errored2 = 0;\n\tint onehot_error = 0;\n\treg [9:0] state_error = 10'h0;\n\t\n\tinitial begin\n\t\trepeat(2) @(posedge clk);\n\t\tforever @(posedge clk, negedge clk)\n\t\t\tstate_error <= state_error | (next_state_ref^next_state_dut);\n\tend\n\t\t\n\tinitial begin\n\t\tstate <= 0;\n\t\t\n\t\t@(negedge clk) wavedrom_start();\n\t\tfor (int i=0;i<10;i++) begin\n\t\t\t@(negedge clk, posedge clk);\n\t\t\tstate <= 1<< i;\n\t\t\tin <= 0;\n\t\tend\n\t\tfor (int i=0;i<10;i++) begin\n\t\t\t@(negedge clk, posedge clk);\n\t\t\tstate <= 1<< i;\n\t\t\tin <= 1;\n\t\tend\t\t\t\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\t// Test the one-hot cases first.\n\t\trepeat(200) @(posedge clk, negedge clk) begin\n\t\t\tstate <= 1<< ($unsigned($random) % 10);\n\t\t\tin <= $random;\n\t\t\tif (!tb_match) onehot_error++;\n\t\tend\n\t\t\n\t\t// Two-hot.\n\t\terrored1 = 0;\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\tstate <= (1<< ($unsigned($random) % 10)) | (1<< ($unsigned($random) % 10));\n\t\t\tin <= $random;\n\t\t\tif (!tb_match)\n\t\t\t\terrored1++;\n\t\tend\n\t\t\n\t\tif (!onehot_error && errored1) \n\t\t\t$display (\"Hint: Your circuit passed when given only one-hot inputs, but not with two-hot inputs.\");\n\t\t\n\t\t// Random.\n\t\terrored2 = 0;\n\t\trepeat(800) @(posedge clk, negedge clk) begin\n\t\t\tstate <= $random;\n\t\t\tin <= $random;\n\t\t\tif (!tb_match)\n\t\t\t\terrored2++;\n\t\tend\n\t\tif (!onehot_error && errored2) \n\t\t\t$display (\"Hint: Your circuit passed when given only one-hot inputs, but not with random inputs.\");\n\n\t\tif (!onehot_error && (errored1 || errored2))\n\t\t\t$display(\"Hint: Are you doing something more complicated than deriving state transition equations by inspection?\\n\");\n\t\t\n\t\tfor (int i=0;i<$bits(state_error);i++)\n\t\t\t$display(\"Hint: next_state[%0d] is %s.\", i, (state_error[i] === 1'b0) ? \"correct\": \"incorrect\");\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_next_state;\n\t\tint errortime_next_state;\n\t\tint errors_out1;\n\t\tint errortime_out1;\n\t\tint errors_out2;\n\t\tint errortime_out2;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in;\n\tlogic [9:0] state;\n\tlogic [9:0] next_state_ref;\n\tlogic [9:0] next_state_dut;\n\tlogic out1_ref;\n\tlogic out1_dut;\n\tlogic out2_ref;\n\tlogic out2_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in,state,next_state_ref,next_state_dut,out1_ref,out1_dut,out2_ref,out2_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in,\n\t\t.state );\n\treference_module good1 (\n\t\t.in,\n\t\t.state,\n\t\t.next_state(next_state_ref),\n\t\t.out1(out1_ref),\n\t\t.out2(out2_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in,\n\t\t.state,\n\t\t.next_state(next_state_dut),\n\t\t.out1(out1_dut),\n\t\t.out2(out2_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_next_state) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"next_state\", stats1.errors_next_state, stats1.errortime_next_state);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"next_state\");\n\t\tif (stats1.errors_out1) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out1\", stats1.errors_out1, stats1.errortime_out1);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out1\");\n\t\tif (stats1.errors_out2) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out2\", stats1.errors_out2, stats1.errortime_out2);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out2\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { next_state_ref, out1_ref, out2_ref } === ( { next_state_ref, out1_ref, out2_ref } ^ { next_state_dut, out1_dut, out2_dut } ^ { next_state_ref, out1_ref, out2_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (next_state_ref !== ( next_state_ref ^ next_state_dut ^ next_state_ref ))\n\t\tbegin if (stats1.errors_next_state == 0) stats1.errortime_next_state = $time;\n\t\t\tstats1.errors_next_state = stats1.errors_next_state+1'b1; end\n\t\tif (out1_ref !== ( out1_ref ^ out1_dut ^ out1_ref ))\n\t\tbegin if (stats1.errors_out1 == 0) stats1.errortime_out1 = $time;\n\t\t\tstats1.errors_out1 = stats1.errors_out1+1'b1; end\n\t\tif (out2_ref !== ( out2_ref ^ out2_dut ^ out2_ref ))\n\t\tbegin if (stats1.errors_out2 == 0) stats1.errortime_out2 = $time;\n\t\t\tstats1.errors_out2 = stats1.errors_out2+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "ece241_2013_q7", "task_number": 63, "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "header": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "module_code": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tQ <= j&~Q | ~k&Q;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tQ <= j&~Q | ~k&Q;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic j, k,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{j,k} <= 1;\n\t\t\n\t\t@(negedge clk) wavedrom_start();\n\t\t\t@(posedge clk) {j,k} <= 2'h1;\n\t\t\t@(posedge clk) {j,k} <= 2'h2;\n\t\t\t@(posedge clk) {j,k} <= 2'h3;\n\t\t\t@(posedge clk) {j,k} <= 2'h3;\n\t\t\t@(posedge clk) {j,k} <= 2'h3;\n\t\t\t@(posedge clk) {j,k} <= 2'h0;\n\t\t\t@(posedge clk) {j,k} <= 2'h0;\n\t\t\t@(posedge clk) {j,k} <= 2'h0;\n\t\t\t@(posedge clk) {j,k} <= 2'h2;\n\t\t\t@(posedge clk) {j,k} <= 2'h2;\n\t\t@(negedge clk) wavedrom_stop();\n\t\trepeat(400) @(posedge clk, negedge clk)\n\t\t\t{j,k} <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_Q;\n\t\tint errortime_Q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic j;\n\tlogic k;\n\tlogic Q_ref;\n\tlogic Q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,j,k,Q_ref,Q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.j,\n\t\t.k );\n\treference_module good1 (\n\t\t.clk,\n\t\t.j,\n\t\t.k,\n\t\t.Q(Q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.j,\n\t\t.k,\n\t\t.Q(Q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_Q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Q\", stats1.errors_Q, stats1.errortime_Q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { Q_ref } === ( { Q_ref } ^ { Q_dut } ^ { Q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (Q_ref !== ( Q_ref ^ Q_dut ^ Q_ref ))\n\t\tbegin if (stats1.errors_Q == 0) stats1.errortime_Q = $time;\n\t\t\tstats1.errors_Q = stats1.errors_Q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "popcount3", "task_number": 64, "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "header": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "module_code": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n\tassign out = in[0]+in[1]+in[2];\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n\tassign out = in[0]+in[1]+in[2];\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [2:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\t\n\tinitial begin\n\t\tin <= 7;\n\t\t@(negedge clk);\n\t\twavedrom_start();\n\t\t\trepeat(9) @(posedge clk) in <= in + 1'b1;\n\t\t@(negedge clk);\n\t\twavedrom_stop();\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [2:0] in;\n\tlogic [1:0] out_ref;\n\tlogic [1:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "vector5", "task_number": 65, "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "header": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "module_code": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a, b, c, d, e\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,c,d,e} <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic e;\n\tlogic [24:0] out_ref;\n\tlogic [24:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,a,b,c,d,e,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.e,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "lemmings1", "task_number": 66, "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "header": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "module_code": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\tparameter WL=0, WR=1;\n\treg state;\n\treg next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tWL: next = bump_left ? WR : WL;\n\t\t\tWR: next = bump_right ? WL: WR;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= WL;\n        else state <= next;\n\tend\n\t\t\n\tassign walk_left = (state==WL);\n\tassign walk_right = (state==WR);\n\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\tparameter WL=0, WR=1;\n\treg state;\n\treg next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tWL: next = bump_left ? WR : WL;\n\t\t\tWR: next = bump_right ? WL: WR;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= WL;\n        else state <= next;\n\tend\n\t\t\n\tassign walk_left = (state==WL);\n\tassign walk_right = (state==WR);\n\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic areset,\n\toutput logic bump_left,\n\toutput logic bump_right,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\n);\n\treg reset;\n\tassign areset = reset;\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\t\n\tinitial begin\n\t\treset <= 1'b1;\n\t\t{bump_right, bump_left} <= 3'h3;\n\t\twavedrom_start(\"Asynchronous reset\");\n\t\treset_test(1);\n\t\trepeat(3) @(posedge clk);\n\t\t{bump_right, bump_left} <= 2;\n\t\trepeat(2) @(posedge clk);\n\t\t{bump_right, bump_left} <= 1;\n\t\trepeat(2) @(posedge clk);\n\t\twavedrom_stop();\n\t\t\n\t\t@(posedge clk);\n\t\trepeat(200) @(posedge clk, negedge clk) begin\n\t\t\t{bump_right, bump_left} <= $random & $random;\n\t\t\treset <= !($random & 31);\n\t\tend\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_walk_left;\n\t\tint errortime_walk_left;\n\t\tint errors_walk_right;\n\t\tint errortime_walk_right;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic areset;\n\tlogic bump_left;\n\tlogic bump_right;\n\tlogic walk_left_ref;\n\tlogic walk_left_dut;\n\tlogic walk_right_ref;\n\tlogic walk_right_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,areset,bump_left,bump_right,walk_left_ref,walk_left_dut,walk_right_ref,walk_right_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.areset,\n\t\t.bump_left,\n\t\t.bump_right );\n\treference_module good1 (\n\t\t.clk,\n\t\t.areset,\n\t\t.bump_left,\n\t\t.bump_right,\n\t\t.walk_left(walk_left_ref),\n\t\t.walk_right(walk_right_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.areset,\n\t\t.bump_left,\n\t\t.bump_right,\n\t\t.walk_left(walk_left_dut),\n\t\t.walk_right(walk_right_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_walk_left) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"walk_left\", stats1.errors_walk_left, stats1.errortime_walk_left);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"walk_left\");\n\t\tif (stats1.errors_walk_right) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"walk_right\", stats1.errors_walk_right, stats1.errortime_walk_right);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"walk_right\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { walk_left_ref, walk_right_ref } === ( { walk_left_ref, walk_right_ref } ^ { walk_left_dut, walk_right_dut } ^ { walk_left_ref, walk_right_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (walk_left_ref !== ( walk_left_ref ^ walk_left_dut ^ walk_left_ref ))\n\t\tbegin if (stats1.errors_walk_left == 0) stats1.errortime_walk_left = $time;\n\t\t\tstats1.errors_walk_left = stats1.errors_walk_left+1'b1; end\n\t\tif (walk_right_ref !== ( walk_right_ref ^ walk_right_dut ^ walk_right_ref ))\n\t\tbegin if (stats1.errors_walk_right == 0) stats1.errortime_walk_right = $time;\n\t\t\tstats1.errors_walk_right = stats1.errors_walk_right+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "circuit1", "task_number": 67, "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "header": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "module_code": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = a&b;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = a&b;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a,b} <= 0;\n\t\t@(negedge clk) wavedrom_start(\"Unknown circuit\");\n\t\t\t@(posedge clk) {a,b} <= 0;\n\t\t\trepeat(8) @(posedge clk) {a,b} <= {a,b} + 1;\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b} <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic q_ref;\n\tlogic q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,a,b,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "7458", "task_number": 68, "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "header": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "module_code": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg p1a, p1b, p1c, p1d, p1e, p1f,\n\toutput reg p2a, p2b, p2c, p2d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{p1a,p1b,p1c,p1d,p1e,p1f} <= 4'h0;\t\t\n\t\t{p2a,p2b,p2c,p2d} <= 4'h0;\t\t\n\t\twavedrom_start();\n\t\trepeat(20) @(posedge clk) begin\n\t\t\t{p1a,p1b,p1c,p1d,p1e,p1f} <= {count[2:0], count[3:1]};\t\t\n\t\t\t{p2a,p2b,p2c,p2d} <= count;\t\t\n\t\t\tcount = count + 1;\n\t\tend\n\t\twavedrom_stop();\n\n\t\trepeat(400) @(posedge clk,negedge clk) begin\n\t\t\t{p1a,p1b,p1c,p1d,p2a,p2b,p2c,p2d} <= $random;\t\t\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_p1y;\n\t\tint errortime_p1y;\n\t\tint errors_p2y;\n\t\tint errortime_p2y;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic p1a;\n\tlogic p1b;\n\tlogic p1c;\n\tlogic p1d;\n\tlogic p1e;\n\tlogic p1f;\n\tlogic p2a;\n\tlogic p2b;\n\tlogic p2c;\n\tlogic p2d;\n\tlogic p1y_ref;\n\tlogic p1y_dut;\n\tlogic p2y_ref;\n\tlogic p2y_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,p1a,p1b,p1c,p1d,p1e,p1f,p2a,p2b,p2c,p2d,p1y_ref,p1y_dut,p2y_ref,p2y_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.p1a,\n\t\t.p1b,\n\t\t.p1c,\n\t\t.p1d,\n\t\t.p1e,\n\t\t.p1f,\n\t\t.p2a,\n\t\t.p2b,\n\t\t.p2c,\n\t\t.p2d );\n\treference_module good1 (\n\t\t.p1a,\n\t\t.p1b,\n\t\t.p1c,\n\t\t.p1d,\n\t\t.p1e,\n\t\t.p1f,\n\t\t.p2a,\n\t\t.p2b,\n\t\t.p2c,\n\t\t.p2d,\n\t\t.p1y(p1y_ref),\n\t\t.p2y(p2y_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.p1a,\n\t\t.p1b,\n\t\t.p1c,\n\t\t.p1d,\n\t\t.p1e,\n\t\t.p1f,\n\t\t.p2a,\n\t\t.p2b,\n\t\t.p2c,\n\t\t.p2d,\n\t\t.p1y(p1y_dut),\n\t\t.p2y(p2y_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_p1y) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"p1y\", stats1.errors_p1y, stats1.errortime_p1y);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"p1y\");\n\t\tif (stats1.errors_p2y) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"p2y\", stats1.errors_p2y, stats1.errortime_p2y);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"p2y\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { p1y_ref, p2y_ref } === ( { p1y_ref, p2y_ref } ^ { p1y_dut, p2y_dut } ^ { p1y_ref, p2y_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (p1y_ref !== ( p1y_ref ^ p1y_dut ^ p1y_ref ))\n\t\tbegin if (stats1.errors_p1y == 0) stats1.errortime_p1y = $time;\n\t\t\tstats1.errors_p1y = stats1.errors_p1y+1'b1; end\n\t\tif (p2y_ref !== ( p2y_ref ^ p2y_dut ^ p2y_ref ))\n\t\tbegin if (stats1.errors_p2y == 0) stats1.errortime_p2y = $time;\n\t\t\tstats1.errors_p2y = stats1.errors_p2y+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "2014_q3c", "task_number": 69, "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "header": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "module_code": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways_comb begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways_comb begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic x,\n\toutput logic [2:0] y\n);\n\n\tinitial begin\n\t\trepeat(200) @(posedge clk, negedge clk) begin\n\t\t\ty <= $random;\n\t\t\tx <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_Y0;\n\t\tint errortime_Y0;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic x;\n\tlogic [2:0] y;\n\tlogic Y0_ref;\n\tlogic Y0_dut;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,x,y,Y0_ref,Y0_dut,z_ref,z_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.x,\n\t\t.y );\n\treference_module good1 (\n\t\t.clk,\n\t\t.x,\n\t\t.y,\n\t\t.Y0(Y0_ref),\n\t\t.z(z_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.x,\n\t\t.y,\n\t\t.Y0(Y0_dut),\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_Y0) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Y0\", stats1.errors_Y0, stats1.errortime_Y0);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Y0\");\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { Y0_ref, z_ref } === ( { Y0_ref, z_ref } ^ { Y0_dut, z_dut } ^ { Y0_ref, z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (Y0_ref !== ( Y0_ref ^ Y0_dut ^ Y0_ref ))\n\t\tbegin if (stats1.errors_Y0 == 0) stats1.errortime_Y0 = $time;\n\t\t\tstats1.errors_Y0 = stats1.errors_Y0+1'b1; end\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "m2014_q4e", "task_number": 70, "description": "Implement a 2-input NOR gate.", "header": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "module_code": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2);\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2);\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic in1, in2\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{in1, in2} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in1;\n\tlogic in2;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in1,in2,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in1,\n\t\t.in2 );\n\treference_module good1 (\n\t\t.in1,\n\t\t.in2,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in1,\n\t\t.in2,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "wire4", "task_number": 71, "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "header": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "module_code": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\t\n\tassign {w,x,y,z} = {a,b,b,c};\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\t\n\tassign {w,x,y,z} = {a,b,b,c};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a, b, c,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\talways @(posedge clk, negedge clk)\n\t\t{a,b,c} <= $random;\n\t\n\tinitial begin\n\t\t@(negedge clk) wavedrom_start();\n\t\t\trepeat(8) @(posedge clk);\n\t\t@(negedge clk) wavedrom_stop();\n\t\trepeat(100) @(negedge clk);\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_w;\n\t\tint errortime_w;\n\t\tint errors_x;\n\t\tint errortime_x;\n\t\tint errors_y;\n\t\tint errortime_y;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic w_ref;\n\tlogic w_dut;\n\tlogic x_ref;\n\tlogic x_dut;\n\tlogic y_ref;\n\tlogic y_dut;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,a,b,c,w_ref,w_dut,x_ref,x_dut,y_ref,y_dut,z_ref,z_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.w(w_ref),\n\t\t.x(x_ref),\n\t\t.y(y_ref),\n\t\t.z(z_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.w(w_dut),\n\t\t.x(x_dut),\n\t\t.y(y_dut),\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_w) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"w\", stats1.errors_w, stats1.errortime_w);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"w\");\n\t\tif (stats1.errors_x) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"x\", stats1.errors_x, stats1.errortime_x);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"x\");\n\t\tif (stats1.errors_y) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"y\", stats1.errors_y, stats1.errortime_y);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"y\");\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { w_ref, x_ref, y_ref, z_ref } === ( { w_ref, x_ref, y_ref, z_ref } ^ { w_dut, x_dut, y_dut, z_dut } ^ { w_ref, x_ref, y_ref, z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (w_ref !== ( w_ref ^ w_dut ^ w_ref ))\n\t\tbegin if (stats1.errors_w == 0) stats1.errortime_w = $time;\n\t\t\tstats1.errors_w = stats1.errors_w+1'b1; end\n\t\tif (x_ref !== ( x_ref ^ x_dut ^ x_ref ))\n\t\tbegin if (stats1.errors_x == 0) stats1.errortime_x = $time;\n\t\t\tstats1.errors_x = stats1.errors_x+1'b1; end\n\t\tif (y_ref !== ( y_ref ^ y_dut ^ y_ref ))\n\t\tbegin if (stats1.errors_y == 0) stats1.errortime_y = $time;\n\t\t\tstats1.errors_y = stats1.errors_y+1'b1; end\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "m2014_q4b", "task_number": 72, "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "header": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "module_code": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic d, ar\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{d,ar} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic d;\n\tlogic ar;\n\tlogic q_ref;\n\tlogic q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,d,ar,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.d,\n\t\t.ar );\n\treference_module good1 (\n\t\t.clk,\n\t\t.d,\n\t\t.ar,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.d,\n\t\t.ar,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "always_case", "task_number": 73, "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "header": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "module_code": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [2:0] sel, \n\toutput logic [3:0] data0,\n\toutput logic [3:0] data1,\n\toutput logic [3:0] data2,\n\toutput logic [3:0] data3,\n\toutput logic [3:0] data4,\n\toutput logic [3:0] data5,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tdata0 <= 4'ha;\n\t\tdata1 <= 4'hb;\n\t\tdata2 <= 4'hc;\n\t\tdata3 <= 4'hd;\n\t\tdata4 <= 4'he;\n\t\tdata5 <= 4'hf;\n\t\t{sel} <= 3'b111;\n\t\t@(negedge clk) wavedrom_start(\"<b>Sel</b> chooses one of the data inputs\");\n\t\t\trepeat(8) @(posedge clk) sel <= sel + 1;\n\t\t@(negedge clk) wavedrom_stop();\n\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{data0, data1, data2, data3} <= $urandom;\n\t\t\t{data4, data5, sel} <= $urandom;\n\t\tend\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [2:0] sel;\n\tlogic [3:0] data0;\n\tlogic [3:0] data1;\n\tlogic [3:0] data2;\n\tlogic [3:0] data3;\n\tlogic [3:0] data4;\n\tlogic [3:0] data5;\n\tlogic [3:0] out_ref;\n\tlogic [3:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,sel,data0,data1,data2,data3,data4,data5,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.sel,\n\t\t.data0,\n\t\t.data1,\n\t\t.data2,\n\t\t.data3,\n\t\t.data4,\n\t\t.data5 );\n\treference_module good1 (\n\t\t.sel,\n\t\t.data0,\n\t\t.data1,\n\t\t.data2,\n\t\t.data3,\n\t\t.data4,\n\t\t.data5,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.sel,\n\t\t.data0,\n\t\t.data1,\n\t\t.data2,\n\t\t.data3,\n\t\t.data4,\n\t\t.data5,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "timer", "task_number": 74, "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "header": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "module_code": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\tlogic [9:0] count_value;\n\n\talways @(posedge clk)\n\t\tif(load) count_value <= data;\n\t\telse if(count_value != 0) count_value <= count_value - 1;\n\n\tassign tc = count_value == 0;\n\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\tlogic [9:0] count_value;\n\n\talways @(posedge clk)\n\t\tif(load) count_value <= data;\n\t\telse if(count_value != 0) count_value <= count_value - 1;\n\n\tassign tc = count_value == 0;\n\nendmodule\n\nmodule stimulus_gen(\n\tinput clk, \n\toutput logic load, \n\toutput logic [9:0] data, \n\tinput tb_match,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\toutput int wavedrom_hide_after_time\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\tload <= 1'b0;\n\t\twavedrom_start(\"Count 3, then 10 cycles\");\n\t\t\t@(posedge clk) {data, load} <= {10'd3, 1'b1};\n\t\t\t@(posedge clk) {data, load} <= {10'hx, 1'b0};\n\t\t\t@(posedge clk) load <= 0;\n\t\t\t@(posedge clk) load <= 0;\n\t\t\t@(posedge clk) load <= 0;\n\t\t\t@(posedge clk) {data, load} <= {10'd10, 1'b1};\n\t\t\t@(posedge clk) {data, load} <= {10'hx, 1'b0};\n\t\t\trepeat(12) @(posedge clk);\n\t\twavedrom_stop();\n\n\t\t@(posedge clk) {load, data} <= {1'b1, 10'h10};\n\t\t@(posedge clk) {load, data} <= {1'b0, 10'h10};\n\t\t@(posedge clk) {load, data} <= {1'b1, 10'h0};   // Load 0\n\t\t@(posedge clk) {load, data} <= {1'b1, 10'h3ff}; // Load 1023\n\t\t@(posedge clk) {load, data} <= {1'b0, 10'h0};\n\t\trepeat(1040) @(posedge clk);\n\n\t\trepeat(2500) @(posedge clk) begin\n\t\t\tload <= !($urandom & 10'hf);\n\t\t\tdata <= $urandom_range(0,32);\n\t\tend\n\n\t\t\n\t\t#1 $finish;\n\tend\n\nendmodule\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_tc;\n\t\tint errortime_tc;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic load;\n\tlogic [9:0] data;\n\tlogic tc_ref;\n\tlogic tc_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,load,data,tc_ref,tc_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.load,\n\t\t.data );\n\treference_module good1 (\n\t\t.clk,\n\t\t.load,\n\t\t.data,\n\t\t.tc(tc_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.load,\n\t\t.data,\n\t\t.tc(tc_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_tc) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"tc\", stats1.errors_tc, stats1.errortime_tc);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"tc\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { tc_ref } === ( { tc_ref } ^ { tc_dut } ^ { tc_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (tc_ref !== ( tc_ref ^ tc_dut ^ tc_ref ))\n\t\tbegin if (stats1.errors_tc == 0) stats1.errortime_tc = $time;\n\t\t\tstats1.errors_tc = stats1.errors_tc+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmseq", "task_number": 75, "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "header": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S;\n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\n\t\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S;\n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\n\t\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg reset, data,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\n);\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\twire [0:9] d = 10'b1110110011;\n\t\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\t@(posedge clk) reset <= 0;\n\t\tdata <= 1;\n\t\trepeat(2) @(posedge clk) ;\n\t\tdata <= 0;\n\t\t@(posedge clk);\n\t\tdata <= 1;\n\t\t@(posedge clk);\n\t\tdata <= 0;\n\t\n\t\twavedrom_start(\"Reset and sequence detect\");\n\t\treset_test();\n\t\tfor (int i=0;i<10;i++) begin\n\t\t\t@(posedge clk) data <= d[i];\n\t\tend\n\t\twavedrom_stop();\n\t\trepeat(600) @(posedge clk, negedge clk) begin\n\t\t\treset <= !($random & 31);\n\t\t\tdata <= $random;\n\t\tend\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_start_shifting;\n\t\tint errortime_start_shifting;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic reset;\n\tlogic data;\n\tlogic start_shifting_ref;\n\tlogic start_shifting_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,reset,data,start_shifting_ref,start_shifting_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.reset,\n\t\t.data );\n\treference_module good1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.data,\n\t\t.start_shifting(start_shifting_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.data,\n\t\t.start_shifting(start_shifting_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_start_shifting) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"start_shifting\", stats1.errors_start_shifting, stats1.errortime_start_shifting);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"start_shifting\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { start_shifting_ref } === ( { start_shifting_ref } ^ { start_shifting_dut } ^ { start_shifting_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (start_shifting_ref !== ( start_shifting_ref ^ start_shifting_dut ^ start_shifting_ref ))\n\t\tbegin if (stats1.errors_start_shifting == 0) stats1.errortime_start_shifting = $time;\n\t\t\tstats1.errors_start_shifting = stats1.errors_start_shifting+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "dff8r", "task_number": 76, "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "header": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg [7:0] d, output reg reset,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\t\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\t\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\td <= $random;\n\t\twavedrom_start(\"Synchronous active-high reset\");\n\t\treset_test();\n\t\trepeat(10) @(negedge clk)\n\t\t\td <= $random;\n\t\twavedrom_stop();\n\t\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\treset <= !($random & 15);\n\t\t\td <= $random;\n\t\tend\n\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] d;\n\tlogic reset;\n\tlogic [7:0] q_ref;\n\tlogic [7:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,d,reset,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.d,\n\t\t.reset );\n\treference_module good1 (\n\t\t.clk,\n\t\t.d,\n\t\t.reset,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.d,\n\t\t.reset,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "edgedetect2", "task_number": 77, "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "header": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n\t\n\treg [7:0] d_last;\t\n\t\t\t\n\talways @(posedge clk) begin\n\t\td_last <= in;\n\t\tanyedge <= in ^ d_last;\n\tend\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n\t\n\treg [7:0] d_last;\t\n\t\t\t\n\talways @(posedge clk) begin\n\t\td_last <= in;\n\t\tanyedge <= in ^ d_last;\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\tinput tb_match,\n\toutput reg [7:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\tin <= 0;\n\t\t@(posedge clk);\n\t\t@(negedge clk) wavedrom_start(\"\");\n\t\trepeat(2) @(posedge clk);\n\t\tin <= 1;\n\t\trepeat(4) @(posedge clk);\n\t\tin <= 0;\n\t\trepeat(4) @(negedge clk);\n\t\tin <= 6;\n\t\trepeat(2) @(negedge clk);\n\t\tin <= 0;\t\t\n\t\trepeat(2) @(posedge clk);\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\t\n\t\trepeat(200)\n\t\t\t@(posedge clk, negedge clk) in <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_anyedge;\n\t\tint errortime_anyedge;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] in;\n\tlogic [7:0] anyedge_ref;\n\tlogic [7:0] anyedge_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,in,anyedge_ref,anyedge_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.clk,\n\t\t.in,\n\t\t.anyedge(anyedge_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.in,\n\t\t.anyedge(anyedge_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_anyedge) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"anyedge\", stats1.errors_anyedge, stats1.errortime_anyedge);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"anyedge\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { anyedge_ref } === ( { anyedge_ref } ^ { anyedge_dut } ^ { anyedge_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (anyedge_ref !== ( anyedge_ref ^ anyedge_dut ^ anyedge_ref ))\n\t\tbegin if (stats1.errors_anyedge == 0) stats1.errortime_anyedge = $time;\n\t\t\tstats1.errors_anyedge = stats1.errors_anyedge+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "count1to10", "task_number": 78, "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "header": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 10)\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 10)\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg reset,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\t\n);\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\twavedrom_start(\"Synchronous reset and counting.\");\n\t\treset_test();\n\t\trepeat(12) @(posedge clk);\n\t\twavedrom_stop();\n\t\t@(posedge clk);\n\t\t\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\treset <= !($random & 31);\n\t\tend\n\t\t#1 $finish;\n\tend\n\t\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic reset;\n\tlogic [3:0] q_ref;\n\tlogic [3:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,reset,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.reset );\n\treference_module good1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "circuit9", "task_number": 79, "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "header": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "module_code": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n\talways @(posedge clk)\n\t\tif (a)\n\t\t\tq <= 4;\n\t\telse if (q == 6)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q + 1'b1;\n\t\t\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n\talways @(posedge clk)\n\t\tif (a)\n\t\t\tq <= 4;\n\t\telse if (q == 6)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q + 1'b1;\n\t\t\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\ta <= 1;\n\t\t@(negedge clk) {a} <= 1;\n\t\t@(negedge clk) wavedrom_start(\"Unknown circuit\");\n\t\t\trepeat(2) @(posedge clk);\n\t\t\t@(posedge clk) {a} <= 0;\n\t\t\trepeat(11) @(posedge clk);\n\t\t\t@(negedge clk) a <= 1;\n\t\t\trepeat(5) @(posedge clk, negedge clk);\n\t\t\ta <= 0;\n\t\t\trepeat(4) @(posedge clk);\n\t\twavedrom_stop();\n\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\ta <= &((5)'($urandom));\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic [2:0] q_ref;\n\tlogic [2:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,a,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a );\n\treference_module good1 (\n\t\t.clk,\n\t\t.a,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.a,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "lfsr5", "task_number": 80, "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "header": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n\t\n\tlogic [4:0] q_next;\n\talways @(q) begin\n\t\tq_next = q[4:1];\n\t\tq_next[4] = q[0];\n\t\tq_next[2] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 5'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n\t\n\tlogic [4:0] q_next;\n\talways @(q) begin\n\t\tq_next = q[4:1];\n\t\tq_next[4] = q[0];\n\t\tq_next[2] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 5'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg reset,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\t\n);\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\t@(negedge clk);\n\t\twavedrom_start();\n\t\t\treset_test();\n\t\t\trepeat(8) @(posedge clk);\n\t\t@(negedge clk);\n\t\twavedrom_stop();\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\treset <= !($random & 31);\n\t\tend\n\t\t@(posedge clk) reset <= 1'b0;\n\t\trepeat(2000) @(posedge clk);\n\t\treset <= 1'b1;\n\t\trepeat(5) @(posedge clk);\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic reset;\n\tlogic [4:0] q_ref;\n\tlogic [4:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,reset,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.reset );\n\treference_module good1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "bugs_addsubz", "task_number": 81, "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "header": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "module_code": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b;\n\t\tendcase\n\t\tresult_is_zero = (out == 0);\n\tend\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b;\n\t\tendcase\n\t\tresult_is_zero = (out == 0);\n\tend\n\t\nendmodule\n\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic do_sub,\n\toutput logic [7:0] a, b,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\t{a, b} <= 16'haabb;\n\t\tdo_sub <= 0;\n\t\t@(negedge clk) wavedrom_start(\"\");\n\t\t\t@(posedge clk, negedge clk) do_sub <= 0;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 0;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 1;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 1;\n\t\t\t\n\t\t\t@(posedge clk, negedge clk) {a, b} <= 16'h0303; do_sub <= 1'b0;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 0;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 1;\n\t\t\t@(posedge clk, negedge clk) {a, b} <= 16'h0304; do_sub <= 1'b0;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 0;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 1;\n\t\t\t@(posedge clk, negedge clk) {a, b} <= 16'hfd03; do_sub <= 1'b0;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 0;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 1;\n\t\t\t@(posedge clk, negedge clk) {a, b} <= 16'hfd04; do_sub <= 1'b0;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 0;\n\t\t\t@(posedge clk, negedge clk) do_sub <= 1;\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{a,b, do_sub} <= $urandom;\n\t\tend\n\t\t\t\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\t\tint errors_result_is_zero;\n\t\tint errortime_result_is_zero;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic do_sub;\n\tlogic [7:0] a;\n\tlogic [7:0] b;\n\tlogic [7:0] out_ref;\n\tlogic [7:0] out_dut;\n\tlogic result_is_zero_ref;\n\tlogic result_is_zero_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,do_sub,a,b,out_ref,out_dut,result_is_zero_ref,result_is_zero_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.do_sub,\n\t\t.a,\n\t\t.b );\n\treference_module good1 (\n\t\t.do_sub,\n\t\t.a,\n\t\t.b,\n\t\t.out(out_ref),\n\t\t.result_is_zero(result_is_zero_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.do_sub,\n\t\t.a,\n\t\t.b,\n\t\t.out(out_dut),\n\t\t.result_is_zero(result_is_zero_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\t\tif (stats1.errors_result_is_zero) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"result_is_zero\", stats1.errors_result_is_zero, stats1.errortime_result_is_zero);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"result_is_zero\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref, result_is_zero_ref } === ( { out_ref, result_is_zero_ref } ^ { out_dut, result_is_zero_dut } ^ { out_ref, result_is_zero_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\t\tif (result_is_zero_ref !== ( result_is_zero_ref ^ result_is_zero_dut ^ result_is_zero_ref ))\n\t\tbegin if (stats1.errors_result_is_zero == 0) stats1.errortime_result_is_zero = $time;\n\t\t\tstats1.errors_result_is_zero = stats1.errors_result_is_zero+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "m2014_q3", "task_number": 82, "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "header": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "module_code": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx;\n\t\t\t4'h1: f = 1'bx;\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 1'bx;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 1'bx;\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 0;\n\t\t\t4'ha: f = 1'bx;\n\t\t\t4'hb: f = 1;\n\t\t\t4'hc: f = 1;\n\t\t\t4'hd: f = 1'bx;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1'bx;\n\t\tendcase\n\tend\n\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx;\n\t\t\t4'h1: f = 1'bx;\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 1'bx;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 1'bx;\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 0;\n\t\t\t4'ha: f = 1'bx;\n\t\t\t4'hb: f = 1;\n\t\t\t4'hc: f = 1;\n\t\t\t4'hd: f = 1'bx;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1'bx;\n\t\tendcase\n\tend\n\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [4:1] x\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\tx <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_f;\n\t\tint errortime_f;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [4:1] x;\n\tlogic f_ref;\n\tlogic f_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,x,f_ref,f_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.x );\n\treference_module good1 (\n\t\t.x,\n\t\t.f(f_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.x,\n\t\t.f(f_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_f) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"f\", stats1.errors_f, stats1.errortime_f);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"f\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { f_ref } === ( { f_ref } ^ { f_dut } ^ { f_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (f_ref !== ( f_ref ^ f_dut ^ f_ref ))\n\t\tbegin if (stats1.errors_f == 0) stats1.errortime_f = $time;\n\t\t\tstats1.errors_f = stats1.errors_f+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "bugs_case", "task_number": 83, "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "header": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "module_code": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n//\tuhh.. make a case statement: maps scancode to 0-9, but accidentally infer a latch?\n//  and have one of the entries be wrong? (duplicate case, using different base!) \n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n//\tuhh.. make a case statement: maps scancode to 0-9, but accidentally infer a latch?\n//  and have one of the entries be wrong? (duplicate case, using different base!) \n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [7:0] code,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\tcode <= 8'h45;\n\t\t@(negedge clk) wavedrom_start(\"Decode scancodes\");\n\t\t\t@(posedge clk) code <= 8'h45;\n\t\t\t@(posedge clk) code <= 8'h03;\n\t\t\t@(posedge clk) code <= 8'h46;\n\t\t\t@(posedge clk) code <= 8'h16;\n\t\t\t@(posedge clk) code <= 8'd26;\n\t\t\t@(posedge clk) code <= 8'h1e;\n\t\t\t@(posedge clk) code <= 8'h25;\n\t\t\t@(posedge clk) code <= 8'h26;\n\t\t\t@(posedge clk) code <= 8'h2e;\n\t\t\t@(posedge clk) code <= $random;\n\t\t\t@(posedge clk) code <= 8'h36;\n\t\t\t@(posedge clk) code <= $random;\n\t\t\t@(posedge clk) code <= 8'h3d;\n\t\t\t@(posedge clk) code <= 8'h3e;\n\t\t\t@(posedge clk) code <= 8'h45;\n\t\t\t@(posedge clk) code <= 8'h46;\n\t\t\t@(posedge clk) code <= $random;\n\t\t\t@(posedge clk) code <= $random;\n\t\t\t@(posedge clk) code <= $random;\n\t\t\t@(posedge clk) code <= $random;\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(1000) @(posedge clk, negedge clk) begin\n\t\t\tcode <= $urandom;\n\t\tend\n\t\t\t\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\t\tint errors_valid;\n\t\tint errortime_valid;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] code;\n\tlogic [3:0] out_ref;\n\tlogic [3:0] out_dut;\n\tlogic valid_ref;\n\tlogic valid_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,code,out_ref,out_dut,valid_ref,valid_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.code );\n\treference_module good1 (\n\t\t.code,\n\t\t.out(out_ref),\n\t\t.valid(valid_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.code,\n\t\t.out(out_dut),\n\t\t.valid(valid_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\t\tif (stats1.errors_valid) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"valid\", stats1.errors_valid, stats1.errortime_valid);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"valid\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref, valid_ref } === ( { out_ref, valid_ref } ^ { out_dut, valid_dut } ^ { out_ref, valid_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\t\tif (valid_ref !== ( valid_ref ^ valid_dut ^ valid_ref ))\n\t\tbegin if (stats1.errors_valid == 0) stats1.errortime_valid = $time;\n\t\t\tstats1.errors_valid = stats1.errors_valid+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "vectorr", "task_number": 84, "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "header": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "module_code": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [7:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\t\n\n\t\n\tinitial begin\n\t\tin <= 0;\n\t\t@(negedge clk) wavedrom_start();\n\t\t\t@(posedge clk) in <= 8'h1;\n\t\t\t@(posedge clk) in <= 8'h2;\n\t\t\t@(posedge clk) in <= 8'h4;\n\t\t\t@(posedge clk) in <= 8'h8;\n\t\t\t@(posedge clk) in <= 8'h80;\n\t\t\t@(posedge clk) in <= 8'hc0;\n\t\t\t@(posedge clk) in <= 8'he0;\n\t\t\t@(posedge clk) in <= 8'hf0;\n\t\t@(negedge clk) wavedrom_stop();\n\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] in;\n\tlogic [7:0] out_ref;\n\tlogic [7:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "kmap3", "task_number": 85, "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "header": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "module_code": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg a, b, c, d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{a,b,c,d} <= 4'b0;\n\t\twavedrom_start();\n\t\trepeat(16) @(posedge clk)\n\t\t\t{a,b,c,d} <= count++;\t\t\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{d,c,b,a} <= $urandom;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,a,b,c,d,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "review2015_shiftcount", "task_number": 86, "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "header": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[2:0], data };\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[2:0], data };\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg shift_ena, count_ena, data,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\tdata <= 0;\n\t\tshift_ena <= 1;\n\t\tcount_ena <= 0;\n\t\trepeat(5) @(posedge clk);\n\t\n\t\tdata <= 1;\n\t\tshift_ena <= 0;\n\t\tcount_ena <= 0;\n\t\t@(posedge clk);\n\t\twavedrom_start(\"Shift mode\");\n\t\t@(posedge clk) shift_ena <= 1;\n\t\trepeat(2) @(posedge clk) shift_ena <= 0;\n\t\t@(posedge clk) shift_ena <= 1;\n\t\trepeat(4) @(posedge clk);\n\t\t@(posedge clk) data <= 0;\n\t\trepeat(4) @(posedge clk);\n\t\twavedrom_stop();\n\t\n\t\tdata <= 1;\n\t\tshift_ena <= 1;\t\t\n\t\trepeat(4) @(posedge clk);\n\t\tshift_ena <= 0;\n\t\twavedrom_start(\"Count mode\");\n\t\t@(posedge clk) count_ena <= 1;\n\t\trepeat(2) @(posedge clk) count_ena <= 0;\n\t\t@(posedge clk) count_ena <= 1;\n\t\trepeat(4) @(posedge clk);\n\t\t@(posedge clk) data <= 0;\n\t\trepeat(4) @(posedge clk);\n\t\twavedrom_stop();\n\t\n\t\trepeat(2000) @(posedge clk, negedge clk) begin\n\t\t\t{shift_ena, count_ena} <= $unsigned($random) % 3;\n\t\t\tdata <= $random;\n\t\tend\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic shift_ena;\n\tlogic count_ena;\n\tlogic data;\n\tlogic [3:0] q_ref;\n\tlogic [3:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,shift_ena,count_ena,data,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.shift_ena,\n\t\t.count_ena,\n\t\t.data );\n\treference_module good1 (\n\t\t.clk,\n\t\t.shift_ena,\n\t\t.count_ena,\n\t\t.data,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.shift_ena,\n\t\t.count_ena,\n\t\t.data,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "wire", "task_number": 87, "description": "Create a module with one input and one output that behaves like a wire.", "header": "module top_module(\n\tinput in,\n\toutput out);\n", "module_code": "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\twavedrom_start(\"Output should follow input\");\n\t\trepeat(20) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\twavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\tin <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmshift", "task_number": 88, "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "header": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg reset\n);\n\n\t\n\tinitial begin\n\t\trepeat(100) @(negedge clk) begin\n\t\t\treset <= !($random & 31);\n\t\tend\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_shift_ena;\n\t\tint errortime_shift_ena;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic reset;\n\tlogic shift_ena_ref;\n\tlogic shift_ena_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,reset,shift_ena_ref,shift_ena_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.reset );\n\treference_module good1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.shift_ena(shift_ena_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.shift_ena(shift_ena_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_shift_ena) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"shift_ena\", stats1.errors_shift_ena, stats1.errortime_shift_ena);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"shift_ena\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { shift_ena_ref } === ( { shift_ena_ref } ^ { shift_ena_dut } ^ { shift_ena_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (shift_ena_ref !== ( shift_ena_ref ^ shift_ena_dut ^ shift_ena_ref ))\n\t\tbegin if (stats1.errors_shift_ena == 0) stats1.errortime_shift_ena = $time;\n\t\t\tstats1.errors_shift_ena = stats1.errors_shift_ena+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "count15", "task_number": 89, "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "header": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg reset,\n\tinput tb_match,\n\toutput reg wavedrom_enable,\n\toutput reg[511:0] wavedrom_title\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\n\tinitial begin\n\t\treset <= 1;\n\t\t@(negedge clk);\n\t\t\n\t\twavedrom_start(\"Reset and counting\");\n\t\treset_test();\n\t\t\n\t\trepeat(3) @(posedge clk);\n\t\twavedrom_stop();\n\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\treset <= !($random & 31);\n\t\tend\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic reset;\n\tlogic [3:0] q_ref;\n\tlogic [3:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,reset,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.reset );\n\treference_module good1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "always_if", "task_number": 90, "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "header": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "module_code": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\talways @(*) out_always = (sel_b1 & sel_b2) ? b : a;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\talways @(*) out_always = (sel_b1 & sel_b2) ? b : a;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,sel_b1, sel_b2,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a, b, sel_b1, sel_b2} <= 4'b000;\n\t\t@(negedge clk) wavedrom_start(\"\");\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0100;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1000;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1101;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0001;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0110;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1010;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1111;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0011;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0111;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1011;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b1111;\n\t\t\t@(posedge clk, negedge clk) {a,b,sel_b1,sel_b2} <= 4'b0011;\n\t\twavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,sel_b1,sel_b2} <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_assign;\n\t\tint errortime_out_assign;\n\t\tint errors_out_always;\n\t\tint errortime_out_always;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic sel_b1;\n\tlogic sel_b2;\n\tlogic out_assign_ref;\n\tlogic out_assign_dut;\n\tlogic out_always_ref;\n\tlogic out_always_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,a,b,sel_b1,sel_b2,out_assign_ref,out_assign_dut,out_always_ref,out_always_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.sel_b1,\n\t\t.sel_b2 );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel_b1,\n\t\t.sel_b2,\n\t\t.out_assign(out_assign_ref),\n\t\t.out_always(out_always_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel_b1,\n\t\t.sel_b2,\n\t\t.out_assign(out_assign_dut),\n\t\t.out_always(out_always_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_assign) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_assign\", stats1.errors_out_assign, stats1.errortime_out_assign);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_assign\");\n\t\tif (stats1.errors_out_always) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_always\", stats1.errors_out_always, stats1.errortime_out_always);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_always\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_assign_ref, out_always_ref } === ( { out_assign_ref, out_always_ref } ^ { out_assign_dut, out_always_dut } ^ { out_assign_ref, out_always_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_assign_ref !== ( out_assign_ref ^ out_assign_dut ^ out_assign_ref ))\n\t\tbegin if (stats1.errors_out_assign == 0) stats1.errortime_out_assign = $time;\n\t\t\tstats1.errors_out_assign = stats1.errors_out_assign+1'b1; end\n\t\tif (out_always_ref !== ( out_always_ref ^ out_always_dut ^ out_always_ref ))\n\t\tbegin if (stats1.errors_out_always == 0) stats1.errortime_out_always = $time;\n\t\t\tstats1.errors_out_always = stats1.errors_out_always+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "kmap1", "task_number": 91, "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "header": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "module_code": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (a | b | c);\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (a | b | c);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg a, b, c,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{a,b,c} <= 1'b0;\n\t\twavedrom_start();\n\t\trepeat(10) @(posedge clk)\n\t\t\t{a,b,c} <= count++;\t\t\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{c,b,a} <= $urandom;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,a,b,c,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "2013_q2afsm", "task_number": 92, "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "header": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "module_code": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\tparameter A=0, B=1, C=2, D=3;\n\treg [1:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (~resetn) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways@(state,r) begin\n\t\tcase (state)\n\t\t\tA: if (r[1]) next = B;\n\t\t\t   else if (r[2]) next = C;\n\t\t\t   else if (r[3]) next = D;\n\t\t\t   else next = A;\n\t\t\tB: next = r[1] ? B : A;\n\t\t\tC: next = r[2] ? C : A;\n\t\t\tD: next = r[3] ? D : A;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign g[1] = (state == B);\t\n\tassign g[2] = (state == C);\t\n\tassign g[3] = (state == D);\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\tparameter A=0, B=1, C=2, D=3;\n\treg [1:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (~resetn) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways@(state,r) begin\n\t\tcase (state)\n\t\t\tA: if (r[1]) next = B;\n\t\t\t   else if (r[2]) next = C;\n\t\t\t   else if (r[3]) next = D;\n\t\t\t   else next = A;\n\t\t\tB: next = r[1] ? B : A;\n\t\t\tC: next = r[2] ? C : A;\n\t\t\tD: next = r[3] ? D : A;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign g[1] = (state == B);\t\n\tassign g[2] = (state == C);\t\n\tassign g[3] = (state == D);\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic resetn,\n\toutput logic [3:1] r,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\n);\n\treg reset;\n\tassign resetn = ~reset;\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\tr <= 0;\n\t\t@(posedge clk);\n\t\t\n\t\tr <= 1;\n\t\treset_test();\n\t\t\n\t\tr <= 0;\n\t\twavedrom_start(\"\");\n\t\t@(posedge clk) r <= 0;\n\t\t@(posedge clk) r <= 7;\n\t\t@(posedge clk) r <= 7;\n\t\t@(posedge clk) r <= 7;\n\t\t@(posedge clk) r <= 6;\n\t\t@(posedge clk) r <= 6;\n\t\t@(posedge clk) r <= 6;\n\t\t@(posedge clk) r <= 4;\n\t\t@(posedge clk) r <= 4;\n\t\t@(posedge clk) r <= 4;\n\t\t@(posedge clk) r <= 0;\n\t\t@(posedge clk) r <= 0;\n\t\t@(posedge clk) r <= 4;\n\t\t@(posedge clk) r <= 6;\n\t\t@(posedge clk) r <= 7;\n\t\t@(posedge clk) r <= 7;\n\t\t@(posedge clk) r <= 7;\n\t\t@(negedge clk);\n\t\twavedrom_stop();\n\t\t\n\t\t@(posedge clk);\n\t\treset <= 0;\n\t\t@(posedge clk);\n\t\t@(posedge clk);\n\t\t\n\t\trepeat(500) @(negedge clk) begin\n\t\t\treset <= ($random & 63) == 0;\n\t\t\tr <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_g;\n\t\tint errortime_g;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic resetn;\n\tlogic [3:1] r;\n\tlogic [3:1] g_ref;\n\tlogic [3:1] g_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,resetn,r,g_ref,g_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.resetn,\n\t\t.r );\n\treference_module good1 (\n\t\t.clk,\n\t\t.resetn,\n\t\t.r,\n\t\t.g(g_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.resetn,\n\t\t.r,\n\t\t.g(g_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_g) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"g\", stats1.errors_g, stats1.errortime_g);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"g\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { g_ref } === ( { g_ref } ^ { g_dut } ^ { g_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (g_ref !== ( g_ref ^ g_dut ^ g_ref ))\n\t\tbegin if (stats1.errors_g == 0) stats1.errortime_g = $time;\n\t\t\tstats1.errors_g = stats1.errors_g+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "count10", "task_number": 93, "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "header": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 9)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 9)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg reset,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\t\n);\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\twavedrom_start(\"Synchronous reset and counting\");\n\t\treset_test();\n\t\trepeat(12) @(posedge clk);\n\t\twavedrom_stop();\n\t\t@(posedge clk);\n\t\t\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\treset <= !($random & 31);\n\t\tend\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic reset;\n\tlogic [3:0] q_ref;\n\tlogic [3:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,reset,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.reset );\n\treference_module good1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "fsm_ps2", "task_number": 94, "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "header": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "module_code": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\tparameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n\treg [1:0] state;\n\treg [1:0] next;\n    \n    wire in3 = in[3];\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tBYTE1: next = in3 ? BYTE2 : BYTE1;\n\t\t\tBYTE2: next = BYTE3;\n\t\t\tBYTE3: next = DONE;\n\t\t\tDONE: next = in3 ? BYTE2 : BYTE1;\n\t\tendcase\n    end\n    \n    always @(posedge clk) begin\n\t\tif (reset) state <= BYTE1;\n        else state <= next;\n\tend\n\t\t\n\tassign done = (state==DONE);\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\tparameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n\treg [1:0] state;\n\treg [1:0] next;\n    \n    wire in3 = in[3];\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tBYTE1: next = in3 ? BYTE2 : BYTE1;\n\t\t\tBYTE2: next = BYTE3;\n\t\t\tBYTE3: next = DONE;\n\t\t\tDONE: next = in3 ? BYTE2 : BYTE1;\n\t\tendcase\n    end\n    \n    always @(posedge clk) begin\n\t\tif (reset) state <= BYTE1;\n        else state <= next;\n\tend\n\t\t\n\tassign done = (state==DONE);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [7:0] in,\n\toutput logic reset\n);\n\n\tinitial begin\n\t\trepeat(200) @(negedge clk) begin\n\t\t\tin <= $random;\n\t\t\treset <= !($random & 31);\n\t\tend\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_done;\n\t\tint errortime_done;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] in;\n\tlogic reset;\n\tlogic done_ref;\n\tlogic done_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,in,reset,done_ref,done_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in,\n\t\t.reset );\n\treference_module good1 (\n\t\t.clk,\n\t\t.in,\n\t\t.reset,\n\t\t.done(done_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.in,\n\t\t.reset,\n\t\t.done(done_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_done) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"done\", stats1.errors_done, stats1.errortime_done);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"done\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { done_ref } === ( { done_ref } ^ { done_dut } ^ { done_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (done_ref !== ( done_ref ^ done_dut ^ done_ref ))\n\t\tbegin if (stats1.errors_done == 0) stats1.errortime_done = $time;\n\t\t\tstats1.errors_done = stats1.errors_done+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "mux2to1", "task_number": 95, "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "header": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "module_code": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic a,b,sel,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a, b, sel} <= 3'b000;\n\t\t@(negedge clk) wavedrom_start(\"<b>Sel</b> chooses between <b>a</b> and <b>b</b>\");\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b000;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b100;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b110;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b111;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b011;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b001;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b100;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b101;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b110;\n\t\t\t@(posedge clk) {a, b, sel} <= 3'b111;\n\t\t@(negedge clk) wavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,sel} <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic sel;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,a,b,sel,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.sel );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "gates4", "task_number": 96, "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "header": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "module_code": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [3:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\tin <= 0;\n\t\t@(negedge clk) wavedrom_start(\"All combinations\");\n\t\t\t@(posedge clk);\n\t\t\trepeat(15) @(posedge clk) in <= in + 1;\n\t\t@(negedge clk) wavedrom_stop();\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_and;\n\t\tint errortime_out_and;\n\t\tint errors_out_or;\n\t\tint errortime_out_or;\n\t\tint errors_out_xor;\n\t\tint errortime_out_xor;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [3:0] in;\n\tlogic out_and_ref;\n\tlogic out_and_dut;\n\tlogic out_or_ref;\n\tlogic out_or_dut;\n\tlogic out_xor_ref;\n\tlogic out_xor_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in,out_and_ref,out_and_dut,out_or_ref,out_or_dut,out_xor_ref,out_xor_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out_and(out_and_ref),\n\t\t.out_or(out_or_ref),\n\t\t.out_xor(out_xor_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in,\n\t\t.out_and(out_and_dut),\n\t\t.out_or(out_or_dut),\n\t\t.out_xor(out_xor_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_and) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_and\", stats1.errors_out_and, stats1.errortime_out_and);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_and\");\n\t\tif (stats1.errors_out_or) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_or\", stats1.errors_out_or, stats1.errortime_out_or);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_or\");\n\t\tif (stats1.errors_out_xor) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_xor\", stats1.errors_out_xor, stats1.errortime_out_xor);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_xor\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_and_ref, out_or_ref, out_xor_ref } === ( { out_and_ref, out_or_ref, out_xor_ref } ^ { out_and_dut, out_or_dut, out_xor_dut } ^ { out_and_ref, out_or_ref, out_xor_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_and_ref !== ( out_and_ref ^ out_and_dut ^ out_and_ref ))\n\t\tbegin if (stats1.errors_out_and == 0) stats1.errortime_out_and = $time;\n\t\t\tstats1.errors_out_and = stats1.errors_out_and+1'b1; end\n\t\tif (out_or_ref !== ( out_or_ref ^ out_or_dut ^ out_or_ref ))\n\t\tbegin if (stats1.errors_out_or == 0) stats1.errortime_out_or = $time;\n\t\t\tstats1.errors_out_or = stats1.errors_out_or+1'b1; end\n\t\tif (out_xor_ref !== ( out_xor_ref ^ out_xor_dut ^ out_xor_ref ))\n\t\tbegin if (stats1.errors_out_xor == 0) stats1.errortime_out_xor = $time;\n\t\t\tstats1.errors_out_xor = stats1.errors_out_xor+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "2014_q3bfsm", "task_number": 97, "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "header": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "module_code": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\tparameter A=0, B=1, C=2, D=3, E=4;\n\treg [2:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (reset) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA: next = x ? B : A;\n\t\t\tB: next = x ? E : B;\n\t\t\tC: next = x ? B : C;\n\t\t\tD: next = x ? C : B;\n\t\t\tE: next = x ? E : D;\t\t\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign z = (state == D) || (state == E);\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\tparameter A=0, B=1, C=2, D=3, E=4;\n\treg [2:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (reset) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA: next = x ? B : A;\n\t\t\tB: next = x ? E : B;\n\t\t\tC: next = x ? B : C;\n\t\t\tD: next = x ? C : B;\n\t\t\tE: next = x ? E : D;\t\t\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign z = (state == D) || (state == E);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic reset,\n\toutput logic x\n);\n\n\tinitial begin\n\t\treset = 1;\n\t\tx = 0;\n\t\t@(posedge clk);\n\t\t@(posedge clk);\n\t\treset = 0;\n\t\t@(posedge clk);\n\t\t@(posedge clk);\n\t\t\n\t\trepeat(500) @(negedge clk) begin\n\t\t\treset <= !($random & 63);\n\t\t\tx <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic reset;\n\tlogic x;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,reset,x,z_ref,z_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.reset,\n\t\t.x );\n\treference_module good1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.x,\n\t\t.z(z_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.x,\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { z_ref } === ( { z_ref } ^ { z_dut } ^ { z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "2013_q2bfsm", "task_number": 98, "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "header": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "module_code": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n\tparameter A=0, B=1, S0=2, S1=3, S10=4, G1=5, G2=6, P0=7, P1=8;\n\treg [3:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (~resetn) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA: next = B;\n\t\t\tB: next = S0;\n\t\t\tS0: next = x ? S1 : S0;\n\t\t\tS1: next = x ? S1 : S10;\n\t\t\tS10: next = x? G1 : S0;\n\t\t\tG1: next = y ? P1 : G2;\n\t\t\tG2: next = y ? P1 : P0;\n\t\t\tP0: next = P0;\n\t\t\tP1: next = P1;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign f = (state == B);\n\tassign g = (state == G1) || (state == G2) || (state == P1);\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n\tparameter A=0, B=1, S0=2, S1=3, S10=4, G1=5, G2=6, P0=7, P1=8;\n\treg [3:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (~resetn) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA: next = B;\n\t\t\tB: next = S0;\n\t\t\tS0: next = x ? S1 : S0;\n\t\t\tS1: next = x ? S1 : S10;\n\t\t\tS10: next = x? G1 : S0;\n\t\t\tG1: next = y ? P1 : G2;\n\t\t\tG2: next = y ? P1 : P0;\n\t\t\tP0: next = P0;\n\t\t\tP1: next = P1;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign f = (state == B);\n\tassign g = (state == G1) || (state == G2) || (state == P1);\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic resetn,\n\toutput logic x, y\n);\n\n\tinitial begin\n\t\tresetn = 0;\n\t\tx = 0;\n\t\ty = 0;\n\t\t@(posedge clk);\n\t\t@(posedge clk);\n\t\tresetn = 1;\n\t\trepeat(500) @(negedge clk) begin\n\t\t\tresetn <= ($random & 31) != 0;\n\t\t\t{x,y} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_f;\n\t\tint errortime_f;\n\t\tint errors_g;\n\t\tint errortime_g;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic resetn;\n\tlogic x;\n\tlogic y;\n\tlogic f_ref;\n\tlogic f_dut;\n\tlogic g_ref;\n\tlogic g_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,resetn,x,y,f_ref,f_dut,g_ref,g_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.resetn,\n\t\t.x,\n\t\t.y );\n\treference_module good1 (\n\t\t.clk,\n\t\t.resetn,\n\t\t.x,\n\t\t.y,\n\t\t.f(f_ref),\n\t\t.g(g_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.resetn,\n\t\t.x,\n\t\t.y,\n\t\t.f(f_dut),\n\t\t.g(g_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_f) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"f\", stats1.errors_f, stats1.errortime_f);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"f\");\n\t\tif (stats1.errors_g) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"g\", stats1.errors_g, stats1.errortime_g);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"g\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { f_ref, g_ref } === ( { f_ref, g_ref } ^ { f_dut, g_dut } ^ { f_ref, g_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (f_ref !== ( f_ref ^ f_dut ^ f_ref ))\n\t\tbegin if (stats1.errors_f == 0) stats1.errortime_f = $time;\n\t\t\tstats1.errors_f = stats1.errors_f+1'b1; end\n\t\tif (g_ref !== ( g_ref ^ g_dut ^ g_ref ))\n\t\tbegin if (stats1.errors_g == 0) stats1.errortime_g = $time;\n\t\t\tstats1.errors_g = stats1.errors_g+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "dff8p", "task_number": 99, "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "header": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\t\n\talways @(negedge clk)\n\t\tif (reset)\n\t\t\tq <= 8'h34;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\t\n\talways @(negedge clk)\n\t\tif (reset)\n\t\t\tq <= 8'h34;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg [7:0] d, output reg reset,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\t\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\t\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\td <= $random;\n\t\t@(negedge clk);\n\t\t@(negedge clk);\n\t\twavedrom_start(\"Synchronous active-high reset\");\n\t\treset_test();\n\t\trepeat(10) @(negedge clk)\n\t\t\td <= $random;\n\t\twavedrom_stop();\n\n\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\treset <= !($random & 15);\n\t\t\td <= $random;\n\t\tend\n\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] d;\n\tlogic reset;\n\tlogic [7:0] q_ref;\n\tlogic [7:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,d,reset,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.d,\n\t\t.reset );\n\treference_module good1 (\n\t\t.clk,\n\t\t.d,\n\t\t.reset,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.d,\n\t\t.reset,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "reduction", "task_number": 100, "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "header": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "module_code": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [7:0] in\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\tin <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_parity;\n\t\tint errortime_parity;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] in;\n\tlogic parity_ref;\n\tlogic parity_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in,parity_ref,parity_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.parity(parity_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in,\n\t\t.parity(parity_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_parity) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"parity\", stats1.errors_parity, stats1.errortime_parity);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"parity\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { parity_ref } === ( { parity_ref } ^ { parity_dut } ^ { parity_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (parity_ref !== ( parity_ref ^ parity_dut ^ parity_ref ))\n\t\tbegin if (stats1.errors_parity == 0) stats1.errortime_parity = $time;\n\t\t\tstats1.errors_parity = stats1.errors_parity+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "fsm3comb", "task_number": 101, "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "header": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "module_code": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic in,\n\toutput logic [1:0] state\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\tin <= $random;\n\t\t\tstate <= $random;\n\t\tend\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_next_state;\n\t\tint errortime_next_state;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic in;\n\tlogic [1:0] state;\n\tlogic [1:0] next_state_ref;\n\tlogic [1:0] next_state_dut;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in,state,next_state_ref,next_state_dut,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in,\n\t\t.state );\n\treference_module good1 (\n\t\t.in,\n\t\t.state,\n\t\t.next_state(next_state_ref),\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in,\n\t\t.state,\n\t\t.next_state(next_state_dut),\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_next_state) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"next_state\", stats1.errors_next_state, stats1.errortime_next_state);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"next_state\");\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { next_state_ref, out_ref } === ( { next_state_ref, out_ref } ^ { next_state_dut, out_dut } ^ { next_state_ref, out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (next_state_ref !== ( next_state_ref ^ next_state_dut ^ next_state_ref ))\n\t\tbegin if (stats1.errors_next_state == 0) stats1.errortime_next_state = $time;\n\t\t\tstats1.errors_next_state = stats1.errors_next_state+1'b1; end\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "mt2015_q4b", "task_number": 102, "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "header": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "module_code": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~(x^y);\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~(x^y);\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic x,\n\toutput logic y,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\t{x,y} <= 0;\n\t\t@(negedge clk) wavedrom_start();\n\t\t\t@(posedge clk) {y,x} <= 0;\n\t\t\t@(posedge clk) {y,x} <= 1;\n\t\t\t@(posedge clk) {y,x} <= 2;\n\t\t\t@(posedge clk) {y,x} <= 3;\n\t\t@(negedge clk) wavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{x, y} <= $random % 4;\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic x;\n\tlogic y;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,x,y,z_ref,z_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.x,\n\t\t.y );\n\treference_module good1 (\n\t\t.x,\n\t\t.y,\n\t\t.z(z_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.x,\n\t\t.y,\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { z_ref } === ( { z_ref } ^ { z_dut } ^ { z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "2012_q2fsm", "task_number": 103, "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "header": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "module_code": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\tparameter A=0,B=1,C=2,D=3,E=4,F=5;\n\treg[2:0] state, next;\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= A;\n\t\telse state <= next;\n\t\t\n\t\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA: next = w ? B : A;\n\t\t\tB: next = w ? C : D;\n\t\t\tC: next = w ? E : D;\n\t\t\tD: next = w ? F : A;\n\t\t\tE: next = w ? E : D;\n\t\t\tF: next = w ? C : D;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t\n\tassign z = (state == E) || (state == F);\n\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\tparameter A=0,B=1,C=2,D=3,E=4,F=5;\n\treg[2:0] state, next;\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= A;\n\t\telse state <= next;\n\t\t\n\t\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA: next = w ? B : A;\n\t\t\tB: next = w ? C : D;\n\t\t\tC: next = w ? E : D;\n\t\t\tD: next = w ? F : A;\n\t\t\tE: next = w ? E : D;\n\t\t\tF: next = w ? C : D;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t\n\tassign z = (state == E) || (state == F);\n\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic reset,\n\toutput logic w\n);\n\n\tinitial begin\n\t\trepeat(200) @(negedge clk) begin\n\t\t\treset <= ($random & 'h1f) == 0;\n\t\t\tw <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic reset;\n\tlogic w;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,reset,w,z_ref,z_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.reset,\n\t\t.w );\n\treference_module good1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.w,\n\t\t.z(z_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.w,\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { z_ref } === ( { z_ref } ^ { z_dut } ^ { z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "dff16e", "task_number": 104, "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "header": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (!resetn)\n\t\t\tq <= 0;\n\t\telse begin\n\t\t\tif (byteena[0])\n\t\t\t\tq[7:0] <= d[7:0];\n\t\t\tif (byteena[1])\n\t\t\t\tq[15:8] <= d[15:8];\n\t\tend\n\tend\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (!resetn)\n\t\t\tq <= 0;\n\t\telse begin\n\t\t\tif (byteena[0])\n\t\t\t\tq[7:0] <= d[7:0];\n\t\t\tif (byteena[1])\n\t\t\t\tq[15:8] <= d[15:8];\n\t\tend\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg [15:0] d, output reg [1:0] byteena,\n\toutput reg resetn,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\n);\n\treg reset;\n\tassign resetn = ~reset;\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\tbyteena <= 2'b11;\n\t\td <= 16'habcd;\n\t\t@(posedge clk);\n\t\twavedrom_start(\"Synchronous active-low reset\");\n\t\treset_test(0);\n\t\trepeat(2) @(posedge clk);\n\t\twavedrom_stop();\n\t\t@(posedge clk);\n\t\t\n\t\t\n\t\tbyteena <= 2'b11;\n\t\td <= $random;\n\t\t@(posedge clk);\n\t\t@(negedge clk);\n\t\twavedrom_start(\"DFF with byte enables\");\n\t\trepeat(10) @(posedge clk) begin\n\t\t\td <= $random;\n\t\t\tbyteena <= byteena + 1;\n\t\tend\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\tbyteena[0] <= ($random & 3) != 0;\n\t\t\tbyteena[1] <= ($random & 3) != 0;\n\t\t\td <= $random;\n\t\tend\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic resetn;\n\tlogic [1:0] byteena;\n\tlogic [15:0] d;\n\tlogic [15:0] q_ref;\n\tlogic [15:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,resetn,byteena,d,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.resetn,\n\t\t.byteena,\n\t\t.d );\n\treference_module good1 (\n\t\t.clk,\n\t\t.resetn,\n\t\t.byteena,\n\t\t.d,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.resetn,\n\t\t.byteena,\n\t\t.d,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "edgedetect", "task_number": 105, "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "header": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\t\n\treg [7:0] d_last;\t\n\t\t\t\n\talways @(posedge clk) begin\n\t\td_last <= in;\n\t\tpedge <= in & ~d_last;\n\tend\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\t\n\treg [7:0] d_last;\t\n\t\t\t\n\talways @(posedge clk) begin\n\t\td_last <= in;\n\t\tpedge <= in & ~d_last;\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\tinput tb_match,\n\toutput reg [7:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\tin <= 0;\n\t\t@(posedge clk);\n\t\twavedrom_start(\"\");\n\t\trepeat(2) @(posedge clk);\n\t\tin <= 1;\n\t\trepeat(4) @(posedge clk);\n\t\tin <= 0;\n\t\trepeat(4) @(negedge clk);\n\t\tin <= 6;\n\t\trepeat(2) @(negedge clk);\n\t\tin <= 0;\t\t\n\t\trepeat(2) @(posedge clk);\n\t\twavedrom_stop();\n\n\t\trepeat(200)\n\t\t\t@(posedge clk, negedge clk) in <= $random;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_pedge;\n\t\tint errortime_pedge;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] in;\n\tlogic [7:0] pedge_ref;\n\tlogic [7:0] pedge_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,in,pedge_ref,pedge_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.clk,\n\t\t.in,\n\t\t.pedge(pedge_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.in,\n\t\t.pedge(pedge_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_pedge) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"pedge\", stats1.errors_pedge, stats1.errortime_pedge);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"pedge\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { pedge_ref } === ( { pedge_ref } ^ { pedge_dut } ^ { pedge_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (pedge_ref !== ( pedge_ref ^ pedge_dut ^ pedge_ref ))\n\t\tbegin if (stats1.errors_pedge == 0) stats1.errortime_pedge = $time;\n\t\t\tstats1.errors_pedge = stats1.errors_pedge+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "circuit8", "task_number": 106, "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "header": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "module_code": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n\talways @(negedge clock)\n\t\tq <= a;\n\t\t\n\talways @(*)\n\t\tif (clock)\n\t\t\tp = a;\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n\talways @(negedge clock)\n\t\tq <= a;\n\t\t\n\talways @(*)\n\t\tif (clock)\n\t\t\tp = a;\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic clock=0,\n\toutput logic a,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\talways begin\n\t\trepeat(3) @(posedge clk);\n\t\tclock = ~clock;\n\tend\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\ta <= 0;\n\t\t@(negedge clock) {a} <= 0;\n\t\t@(negedge clk) wavedrom_start(\"Unknown circuit\");\n\t\t\t@(posedge clk) {a} <= 0;\n\t\t\trepeat(14) @(posedge clk,negedge clk) a <= ~a;\n\t\t\trepeat(5) @(posedge clk, negedge clk);\n\t\t\trepeat(8) @(posedge clk,negedge clk) a <= ~a;\n\t\twavedrom_stop();\n\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\ta <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_p;\n\t\tint errortime_p;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic clock;\n\tlogic a;\n\tlogic p_ref;\n\tlogic p_dut;\n\tlogic q_ref;\n\tlogic q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clock,a,p_ref,p_dut,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.clock,\n\t\t.a );\n\treference_module good1 (\n\t\t.clock,\n\t\t.a,\n\t\t.p(p_ref),\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clock,\n\t\t.a,\n\t\t.p(p_dut),\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_p) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"p\", stats1.errors_p, stats1.errortime_p);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"p\");\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { p_ref, q_ref } === ( { p_ref, q_ref } ^ { p_dut, q_dut } ^ { p_ref, q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (p_ref !== ( p_ref ^ p_dut ^ p_ref ))\n\t\tbegin if (stats1.errors_p == 0) stats1.errortime_p = $time;\n\t\t\tstats1.errors_p = stats1.errors_p+1'b1; end\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "rule90", "task_number": 107, "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "header": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "module_code": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse begin\n\t\t\tq <= q[$bits(q)-1:1] ^ {q[$bits(q)-2:0], 1'b0} ;\n\t\tend\n\tend\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse begin\n\t\t\tq <= q[$bits(q)-1:1] ^ {q[$bits(q)-2:0], 1'b0} ;\n\t\tend\n\tend\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg load,\n\toutput reg[511:0] data,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tdata <= 0;\n\t\tdata[0] <= 1'b1;\n\t\tload <= 1;\n\t\t@(posedge clk); wavedrom_start(\"Sierpi&#324;ski triangle: See Hint.\");\n\t\t@(posedge clk);\n\t\t@(posedge clk);\n\t\tload <= 0;\n\t\trepeat(10) @(posedge clk);\t\t\n\t\twavedrom_stop();\n\n\n\t\tdata <= 0;\n\t\tdata[256] <= 1'b1;\n\t\tload <= 1;\n\t\t@(posedge clk);\n\t\t@(posedge clk);\n\t\t@(posedge clk);\n\t\tload <= 0;\n\t\trepeat(1000) @(posedge clk) begin\n\t\tend\n\t\tdata <= 512'h1000000000000001;\n\t\tload <= 1;\n\t\t@(posedge clk);\n\t\tload <= 0;\n\t\trepeat(1000) @(posedge clk) begin\n\t\tend\n\n\t\tdata <= $random;\n\t\tload <= 1;\n\t\t@(posedge clk);\n\t\tload <= 0;\n\t\trepeat(1000) @(posedge clk) begin\n\t\tend\n\n\t\tdata <= 0;\n\t\tload <= 1;\n\t\trepeat(20) @(posedge clk);\n\t\trepeat(2) @(posedge clk) data <= data + 2;\n\t\t@(posedge clk) begin \n\t\t\tload <= 0;\n\t\t\tdata <= data + 1;\n\t\tend\n\t\trepeat(20) @(posedge clk) data <= data + 1;\n\t\trepeat(500) @(posedge clk) begin\n\t\tend\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic load;\n\tlogic [511:0] data;\n\tlogic [511:0] q_ref;\n\tlogic [511:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,load,data,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.load,\n\t\t.data );\n\treference_module good1 (\n\t\t.clk,\n\t\t.load,\n\t\t.data,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.load,\n\t\t.data,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "mt2015_eq2", "task_number": 108, "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "header": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "module_code": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = A[1:0]==B[1:0];\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\n/*\n\tMidterm 2015 Question 1k. 2-bit equality comparator.\n*/\nmodule reference_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = A[1:0]==B[1:0];\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [1:0] A,\n\toutput logic [1:0] B\n);\n\n\talways @(posedge clk, negedge clk)\n\t\t{A, B} <= $random % 16;\n\t\n\tinitial begin\n\t\trepeat(1000) @(negedge clk);\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_z;\n\t\tint errortime_z;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [1:0] A;\n\tlogic [1:0] B;\n\tlogic z_ref;\n\tlogic z_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,A,B,z_ref,z_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.A,\n\t\t.B );\n\treference_module good1 (\n\t\t.A,\n\t\t.B,\n\t\t.z(z_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.A,\n\t\t.B,\n\t\t.z(z_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_z) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"z\", stats1.errors_z, stats1.errortime_z);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"z\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { z_ref } === ( { z_ref } ^ { z_dut } ^ { z_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (z_ref !== ( z_ref ^ z_dut ^ z_ref ))\n\t\tbegin if (stats1.errors_z == 0) stats1.errortime_z = $time;\n\t\t\tstats1.errors_z = stats1.errors_z+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "gatesv100", "task_number": 109, "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "header": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "module_code": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & in[99:1];\n\tassign out_any = in | in[99:1];\n\tassign out_different = in^{in[0], in[99:1]};\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & in[99:1];\n\tassign out_any = in | in[99:1];\n\tassign out_different = in^{in[0], in[99:1]};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\tinput tb_match,\n\toutput logic [99:0] in\n);\n\n\tinitial begin\n\t\tin <= $random;\n\t\trepeat(100) begin\n\t\t\t@(negedge clk) in <= $random;\n\t\t\t@(posedge clk) in <= $random;\n\t\tend\n\t\t#1 $finish;\n\tend\n\t\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_both;\n\t\tint errortime_out_both;\n\t\tint errors_out_any;\n\t\tint errortime_out_any;\n\t\tint errors_out_different;\n\t\tint errortime_out_different;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [99:0] in;\n\tlogic [98:0] out_both_ref;\n\tlogic [98:0] out_both_dut;\n\tlogic [99:1] out_any_ref;\n\tlogic [99:1] out_any_dut;\n\tlogic [99:0] out_different_ref;\n\tlogic [99:0] out_different_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in,out_both_ref,out_both_dut,out_any_ref,out_any_dut,out_different_ref,out_different_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out_both(out_both_ref),\n\t\t.out_any(out_any_ref),\n\t\t.out_different(out_different_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in,\n\t\t.out_both(out_both_dut),\n\t\t.out_any(out_any_dut),\n\t\t.out_different(out_different_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_both) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_both\", stats1.errors_out_both, stats1.errortime_out_both);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_both\");\n\t\tif (stats1.errors_out_any) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_any\", stats1.errors_out_any, stats1.errortime_out_any);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_any\");\n\t\tif (stats1.errors_out_different) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_different\", stats1.errors_out_different, stats1.errortime_out_different);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_different\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_both_ref, out_any_ref, out_different_ref } === ( { out_both_ref, out_any_ref, out_different_ref } ^ { out_both_dut, out_any_dut, out_different_dut } ^ { out_both_ref, out_any_ref, out_different_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_both_ref !== ( out_both_ref ^ out_both_dut ^ out_both_ref ))\n\t\tbegin if (stats1.errors_out_both == 0) stats1.errortime_out_both = $time;\n\t\t\tstats1.errors_out_both = stats1.errors_out_both+1'b1; end\n\t\tif (out_any_ref !== ( out_any_ref ^ out_any_dut ^ out_any_ref ))\n\t\tbegin if (stats1.errors_out_any == 0) stats1.errortime_out_any = $time;\n\t\t\tstats1.errors_out_any = stats1.errors_out_any+1'b1; end\n\t\tif (out_different_ref !== ( out_different_ref ^ out_different_dut ^ out_different_ref ))\n\t\tbegin if (stats1.errors_out_different == 0) stats1.errortime_out_different = $time;\n\t\t\tstats1.errors_out_different = stats1.errors_out_different+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "m2014_q4a", "task_number": 110, "description": "Implement a D latch using an always block.\n", "header": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "module_code": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n\talways@(*) begin\n\t\tif (ena)\n\t\t\tq = d;\n\tend\n\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n\talways@(*) begin\n\t\tif (ena)\n\t\t\tq = d;\n\tend\n\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic d, ena\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{d,ena} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic d;\n\tlogic ena;\n\tlogic q_ref;\n\tlogic q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,d,ena,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.d,\n\t\t.ena );\n\treference_module good1 (\n\t\t.d,\n\t\t.ena,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.d,\n\t\t.ena,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}