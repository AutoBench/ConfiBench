{"task_id": "always_nolatches", "gptgen_RTL": ["module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @ (scancode) begin\n        // Initialize outputs to 0\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n        \n        // Check the scancode and assert the corresponding output\n        case (scancode)\n            16'he06b: left = 1;\n            16'he072: down = 1;\n            16'he074: right = 1;\n            16'he075: up = 1;\n            default: begin\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @ (scancode) begin\n\t\t// Initialize outputs to 0\n\t\tleft = 0;\n\t\tdown = 0;\n\t\tright = 0;\n\t\tup = 0;\n\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\t\tdefault: begin\n\t\t\t\tleft = 0;\n\t\t\t\tdown = 0;\n\t\t\t\tright = 0;\n\t\t\t\tup = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @(scancode) begin\n    // Initialize outputs to 0\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    // Check the scancode and update outputs\n    case (scancode)\n        16'he06b: left = 1;\n        16'he072: down = 1;\n        16'he074: right = 1;\n        16'he075: up = 1;\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(scancode) begin\n    // Initialize outputs to 0\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    case (scancode)\n        16'he06b: left = 1;  // Left arrow key\n        16'he072: down = 1;  // Down arrow key\n        16'he074: right = 1; // Right arrow key\n        16'he075: up = 1;    // Up arrow key\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @ (scancode) begin\n    // Initialize outputs to 0 to ensure they are only high for the correct condition\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    case(scancode)\n        16'he06b: left = 1;    // Left arrow key\n        16'he072: down = 1;    // Down arrow key\n        16'he074: right = 1;   // Right arrow key\n        16'he075: up = 1;      // Up arrow key\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @(scancode) begin\n    // Initialize all outputs to 0\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    // Check the scancode and set the corresponding output\n    case (scancode)\n        16'he06b: left = 1;\n        16'he072: down = 1;\n        16'he074: right = 1;\n        16'he075: up = 1;\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @(scancode) begin\n    // Initialize outputs to 0 for the default case (no arrow keys pressed)\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    // Check the scancode and set the corresponding output\n    case (scancode)\n        16'he06b: left = 1;\n        16'he072: down = 1;\n        16'he074: right = 1;\n        16'he075: up = 1;\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @(scancode) begin\n    // Initialize outputs to 0 (none of the arrows are pressed)\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    // Check the scancode and assert the corresponding output\n    case(scancode)\n        16'he06b: left = 1;  // Left arrow key\n        16'he072: down = 1;  // Down arrow key\n        16'he074: right = 1; // Right arrow key\n        16'he075: up = 1;    // Up arrow key\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @ (scancode) begin\n    // Initially, set all outputs to 0\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    case (scancode)\n        16'he06b: left = 1;   // Left arrow key\n        16'he072: down = 1;   // Down arrow key\n        16'he074: right = 1;  // Right arrow key\n        16'he075: up = 1;     // Up arrow key\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @(scancode) begin\n    // Default values\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    case(scancode)\n        16'he06b: left = 1;\n        16'he072: down = 1;\n        16'he074: right = 1;\n        16'he075: up = 1;\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n"]}
{"task_id": "fadd", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n    // Intermediate signals for internal carry\n    wire sum_ab, carry_ab, carry_acin, carry_bcin;\n\n    // Adding first two bits\n    half_adder add_ab(.a(a), .b(b), .sum(sum_ab), .carry(carry_ab));\n    // Adding result with cin\n    half_adder add_acin(.a(sum_ab), .b(cin), .sum(sum), .carry(carry_acin));\n    \n    // Calculating final carry out\n    or(cout, carry_ab, carry_acin);\n\nendmodule\n\n// Half adder module used in the full adder\nmodule half_adder(\n    input a, \n    input b, \n    output sum, \n    output carry\n);\n    xor(sum, a, b);  // Sum without carry\n    and(carry, a, b); // Carry if both bits are 1\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n// Intermediate signals to store the sum and carry of a and b, and then the final sum with cin.\nwire sum_ab, carry_ab, carry_abc;\n\n// Adding a and b\nassign {carry_ab, sum_ab} = a + b;\n\n// Adding sum_ab with cin to get the final sum and the final carry out\nassign {carry_abc, sum} = sum_ab + cin;\n\n// The carry out is the OR of carry_ab and carry_abc\nassign cout = carry_ab | carry_abc;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\nassign sum = a ^ b ^ cin; // XOR for sum\nassign cout = (a & b) | (b & cin) | (cin & a); // Carry out\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n// Intermediate wires for the two half adders\nwire s1, c1, c2;\n\n// First half adder (adding a and b)\nassign s1 = a ^ b; // Sum of a and b\nassign c1 = a & b; // Carry of a and b\n\n// Second half adder (adding sum of first half adder and cin)\nassign sum = s1 ^ cin; // Final sum\nassign c2 = s1 & cin; // Carry of s1 and cin\n\n// Carry out is the OR of the two carries from the half adders\nassign cout = c1 | c2;\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n// Intermediate signals for the two half-adder stages\nwire sum_half, carry_half1, carry_half2;\n\n// First half adder - adds a and b\nassign sum_half = a ^ b; // XOR for sum\nassign carry_half1 = a & b; // AND for carry\n\n// Second half adder - adds sum_half and cin (carry-in)\nassign sum = sum_half ^ cin; // Final sum\nassign carry_half2 = sum_half & cin; // Intermediate carry\n\n// OR gate to determine the final carry out\nassign cout = carry_half1 | carry_half2;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n// Intermediate signals for the gates\nwire ab, a_xor_b, a_and_cin, b_and_cin;\n\n// XOR gate for input a and b\nassign a_xor_b = a ^ b;\n\n// AND gate for input a and b\nassign ab = a & b;\n\n// XOR gate for a_xor_b and cin - This is the sum output\nassign sum = a_xor_b ^ cin;\n\n// AND gates for intermediate carry operations\nassign a_and_cin = a_xor_b & cin;\nassign b_and_cin = ab;\n\n// OR gate for the final carry out\nassign cout = a_and_cin | b_and_cin;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule\n"]}
{"task_id": "always_case2", "gptgen_RTL": ["module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(in) begin\n        casez(in)\n            4'b0001: pos = 2'd0;\n            4'b0010: pos = 2'd1;\n            4'b0100: pos = 2'd2;\n            4'b1000: pos = 2'd3;\n            4'b0011: pos = 2'd0;\n            4'b0110: pos = 2'd1;\n            4'b1100: pos = 2'd2;\n            4'b0111: pos = 2'd0;\n            4'b1110: pos = 2'd1;\n            4'b1111: pos = 2'd0;\n            default: pos = 2'd0; // When all bits are 0\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    casez (in)\n        4'b0001: pos = 2'd0;\n        4'b0010: pos = 2'd1;\n        4'b01??: pos = 2'd2;\n        4'b1???: pos = 2'd3;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0; // Output 0 if all inputs are 0\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @ (in) begin\n    case (1'b1) // Priority encoding starting from the highest bit\n        in[3]: pos = 2'd3;\n        in[2]: pos = 2'd2;\n        in[1]: pos = 2'd1;\n        in[0]: pos = 2'd0;\n        default: pos = 2'd0; // When all bits are 0, output is 0\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        casez(in)\n            4'b0001: pos = 2'd0;\n            4'b0010: pos = 2'd1;\n            4'b0100: pos = 2'd2;\n            4'b1000: pos = 2'd3;\n            4'b0011: pos = 2'd0;\n            4'b0110: pos = 2'd1;\n            4'b1100: pos = 2'd2;\n            4'b0111: pos = 2'd0;\n            4'b1110: pos = 2'd1;\n            4'b1111: pos = 2'd0;\n            default: pos = 2'd0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    case (in)\n        4'b0001: pos = 2'd0;\n        4'b0010: pos = 2'd1;\n        4'b0100: pos = 2'd2;\n        4'b1000: pos = 2'd3;\n        4'b0011: pos = 2'd0; // In case of multiple 1's, priority is given to the rightmost 1.\n        4'b0110: pos = 2'd1; // Similarly, priority to the right.\n        4'b1100: pos = 2'd2; // And so on.\n        4'b0111: pos = 2'd0; // Priority to the rightmost 1.\n        4'b1110: pos = 2'd1; // Priority handling.\n        4'b1111: pos = 2'd0; // All ones, priority to the rightmost.\n        default: pos = 2'd0; // If none of the inputs are high.\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    case (in)\n        4'b1000: pos = 2'd3;\n        4'b0100: pos = 2'd2;\n        4'b0010: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        case (in)\n            4'b0001: pos = 2'd0;\n            4'b0010: pos = 2'd1;\n            4'b0100: pos = 2'd2;\n            4'b1000: pos = 2'd3;\n            4'b0011: pos = 2'd0; // Priority given to the rightmost '1'\n            4'b0110: pos = 2'd1; // Priority given to the rightmost '1'\n            4'b1100: pos = 2'd2; // Priority given to the rightmost '1'\n            4'b0111: pos = 2'd0; // Priority given to the rightmost '1'\n            4'b1110: pos = 2'd1; // Priority given to the rightmost '1'\n            4'b1111: pos = 2'd0; // Priority given to the rightmost '1'\n            default: pos = 2'd0; // If no bits are set, output is 0\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    case (in)\n        4'b0001: pos = 2'b00;\n        4'b0010: pos = 2'b01;\n        4'b0100: pos = 2'b10;\n        4'b1000: pos = 2'b11;\n        4'b0011: pos = 2'b00;\n        4'b0110: pos = 2'b01;\n        4'b1100: pos = 2'b10;\n        4'b0111: pos = 2'b00;\n        4'b1110: pos = 2'b01;\n        4'b1111: pos = 2'b00;\n        default: pos = 2'b00; // When in is 0 or any case not covered above\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        casez (in)\n            4'b1???: pos = 2'd3;\n            4'b01??: pos = 2'd2;\n            4'b001?: pos = 2'd1;\n            4'b0001: pos = 2'd0;\n            default: pos = 2'd0; // When all bits are 0, output is 0\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "m2014_q4j", "gptgen_RTL": ["module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\n// Intermediate carry bits\nwire [2:0] carry;\n\n// Full adder for bit 0\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// Full adder for bit 1\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// Full adder for bit 2\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// Full adder for bit 3\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(sum[4]) // This is the overflow bit\n);\n\nendmodule\n\n// Define the full adder module\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    // Sum calculation (XOR operation)\n    assign sum = a ^ b ^ cin;\n    // Carry out calculation\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\nwire [3:0] carry; // Intermediate carry bits\n\n// First full adder (least significant bit)\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),    // No carry input for the first adder\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// Second full adder\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// Third full adder\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// Fourth full adder\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(carry[3])\n);\n\n// Carry output is the overflow bit\nassign sum[4] = carry[3];\n\n// Full adder module definition\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\nwire sum_intermediate, carry_intermediate_a, carry_intermediate_b;\n\n// Sum calculation\nxor xor1(sum_intermediate, a, b);\nxor xor2(sum, sum_intermediate, cin);\n\n// Carry calculation\nand and1(carry_intermediate_a, a, b);\nand and2(carry_intermediate_b, sum_intermediate, cin);\nor or1(cout, carry_intermediate_a, carry_intermediate_b);\n\nendmodule\n\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire [3:0] carry;\n\n// full adder for bit 0\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// full adder for bit 1\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// full adder for bit 2\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// full adder for bit 3\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(carry[3])\n);\n\n// Overflow bit\nassign sum[4] = carry[3];\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire [3:0] carry; // Internal wire to hold carry bits\n\n// Full adder for bit 0\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0), // No carry-in for the first bit\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// Full adder for bit 1\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// Full adder for bit 2\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// Full adder for bit 3\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(carry[3])\n);\n\n// The carry out of the last full adder is the overflow bit\nassign sum[4] = carry[3];\n\nendmodule\n\n// Definition of the full adder module\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin; // XOR for sum\n    assign cout = (a & b) | (b & cin) | (a & cin); // Majority function for carry out\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\nwire [3:0] carry; // Intermediate carry bits\n\n// First full adder\nfull_adder fa0 (\n\t.a(x[0]),\n\t.b(y[0]),\n\t.cin(1'b0),\n\t.sum(sum[0]),\n\t.cout(carry[0])\n);\n\n// Second full adder\nfull_adder fa1 (\n\t.a(x[1]),\n\t.b(y[1]),\n\t.cin(carry[0]),\n\t.sum(sum[1]),\n\t.cout(carry[1])\n);\n\n// Third full adder\nfull_adder fa2 (\n\t.a(x[2]),\n\t.b(y[2]),\n\t.cin(carry[1]),\n\t.sum(sum[2]),\n\t.cout(carry[2])\n);\n\n// Fourth full adder\nfull_adder fa3 (\n\t.a(x[3]),\n\t.b(y[3]),\n\t.cin(carry[2]),\n\t.sum(sum[3]),\n\t.cout(carry[3])\n);\n\n// Overflow bit is the carry out of the last full adder\nassign sum[4] = carry[3];\n\nendmodule\n\n// Definition of the full adder module used above\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput sum,\n\toutput cout\n);\n\tassign sum = a ^ b ^ cin; // Sum bit\n\tassign cout = (a & b) | (b & cin) | (cin & a); // Carry out\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire c0, c1, c2;\n\n// First full adder\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(c0)\n);\n\n// Second full adder\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(c0),\n    .sum(sum[1]),\n    .cout(c1)\n);\n\n// Third full adder\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(c1),\n    .sum(sum[2]),\n    .cout(c2)\n);\n\n// Fourth full adder\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(c2),\n    .sum(sum[3]),\n    .cout(sum[4])\n);\n\nendmodule\n\n// Full adder module\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\n// Intermediate carries between full adders\nwire c0, c1, c2, c3;\n\n// Least significant bit full adder, no input carry (c0 is implicitly 0 here)\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(c0)\n);\n\n// Second bit full adder\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(c0),\n    .sum(sum[1]),\n    .cout(c1)\n);\n\n// Third bit full adder\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(c1),\n    .sum(sum[2]),\n    .cout(c2)\n);\n\n// Most significant bit full adder\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(c2),\n    .sum(sum[3]),\n    .cout(c3)\n);\n\n// The overflow bit is the carry out of the most significant bit full adder\nassign sum[4] = c3;\n\n// Full adder module definition\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin; // Sum is the XOR of the inputs\n    assign cout = (a & b) | (b & cin) | (cin & a); // Carry out is generated if any two or more inputs are 1\nendmodule\n\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire [3:0] carry; // Internal wires to hold the carry out of each full adder\n\n// Instantiate the full adder for the least significant bit\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0), // No carry-in for the least significant bit\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// Instantiate the full adder for the second bit\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// Instantiate the full adder for the third bit\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// Instantiate the full adder for the fourth bit\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(carry[3])\n);\n\n// The fifth bit of the sum (sum[4]) should be the overflow bit, which is the carry out of the most significant full adder\nassign sum[4] = carry[3];\n\n// Full adder module definition\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    // Full adder logic\n    assign sum = a ^ b ^ cin; // Sum is the XOR of input bits and carry-in\n    assign cout = (a & b) | (b & cin) | (a & cin); // Carry out is generated if two or more inputs are high\nendmodule\n\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire [3:0] carry;\n\n// Full Adder for bit 0\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0), // No carry input for the least significant bit\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// Full Adder for bit 1\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// Full Adder for bit 2\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// Full Adder for bit 3\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(carry[3])\n);\n\n// Handling the overflow bit\nassign sum[4] = carry[3];\n\nendmodule\n\n// Full Adder Module\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    // Sum calculation\n    assign sum = a ^ b ^ cin;\n    // Carry out calculation\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire c0, c1, c2, c3; // Carry outputs for each full adder\n\n// Instantiate full adders for each bit\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c0));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c0), .sum(sum[1]), .cout(c1));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c1), .sum(sum[2]), .cout(c2));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c2), .sum(sum[3]), .cout(c3));\n\nassign sum[4] = c3; // The overflow bit\n\n// Definition of the full adder module\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\nwire s1, c1, c2;\n\n// Sum and carry out computation\nxor(s1, a, b);\nxor(sum, s1, cin);\nand(c1, a, b);\nand(c2, s1, cin);\nor(cout, c1, c2);\n\nendmodule\n\nendmodule\n"]}
{"task_id": "vector0", "gptgen_RTL": ["module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n// Assign the input vector directly to the output vector\nassign outv = vec;\n\n// Split the input vector to individual bits\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n// Direct connection of input vector to output vector\nassign outv = vec;\n\n// Assigning individual bits of the input vector to separate outputs\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n// Assigning the input vector to output vector directly\nassign outv = vec;\n\n// Splitting the input vector into three separate 1-bit outputs\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n// Assign the entire vector to outv directly\nassign outv = vec;\n\n// Assign individual bits of the input vector to the separate outputs\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n"]}
{"task_id": "2012_q2b", "gptgen_RTL": ["module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n// State B is represented by y[1] and D by y[3]\n// Deriving Y1 (next state for state B, y[1]) based on current state and input w\nassign Y1 = (y[0] & w) | (y[2] & ~w);\n\n// Deriving Y3 (next state for state D, y[3]) based on current state and input w\nassign Y3 = (y[2] & w) | (y[5] & ~w) | (y[1] & ~w);\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// For Y1 (state B's input)\n// Transitions to B from A with w = 1\nassign Y1 = (y[0] & w);\n\n// For Y3 (state D's input)\n// Transitions to D from B with w = 0, from C with w = 0, and from E with w = 0\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w);\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// State A = 000001, B = 000010, C = 000100, D = 001000, E = 010000, F = 100000\n// Transition from A to B on w=1, hence Y1 should be high when in state A and w=1.\n// Transition from B to D on w=0, hence Y3 should be high when in state B and w=0.\n\n// Y1 corresponds to the input for state B's flip-flop\n// Y3 corresponds to the input for state D's flip-flop\n\nassign Y1 = (y[0] & w); // In state A (000001) and w=1, go to state B (000010)\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w); // In state B (000010) and w=0 or C (000100) and w=0 or E (010000) and w=0 or F (100000) and w=0, go to state D (001000)\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// One-hot state encoding\n// y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Y1 corresponds to state B (000010)\n// Y1 should be 1 when:\n// - Current state is A (y[0] == 1) and w == 1 (A --1--> B)\n// - Current state is D (y[3] == 1) and w == 0 (D --0--> A --> B on next cycle, hence this transition will not directly influence Y1 for B)\n// No other transitions will set B (Y1) based on the given state diagram\n\nassign Y1 = (y[0] & w);\n\n// Y3 corresponds to state D (001000)\n// Y3 should be 1 when:\n// - Current state is B (y[1] == 1) and w == 0 (B --0--> D)\n// - Current state is C (y[2] == 1) and w == 0 (C --0--> D)\n// - Current state is E (y[4] == 1) and w == 0 (E --0--> D)\n// - Current state is F (y[5] == 1) and w == 0 (F --0--> D)\n\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule\n", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n// State B is represented by y[1], and State D is represented by y[3].\n\n// For Y1 (input to flip-flop for state B), the transitions are:\n// A to B when w = 1, represented by y[0] & w.\n// D to B when w = 1, represented by y[3] & w.\n// Therefore, Y1 should be high for these transitions.\nassign Y1 = (y[0] & w) | (y[3] & w);\n\n// For Y3 (input to flip-flop for state D), the transitions are:\n// B to D when w = 0, represented by y[1] & ~w.\n// C to D when w = 0, represented by y[2] & ~w.\n// E to D when w = 0, represented by y[4] & ~w.\n// F to D when w = 0, represented by y[5] & ~w.\n// Therefore, Y3 should be high for these transitions.\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// For Y1 (input to state flip-flop y[1], which corresponds to state B)\n// From the state diagram:\n// A (0) --1--> B, thus when in state A (000001) and w is 1, Y1 should be 1.\n// B (0) --0--> D, does not directly relate to Y1 as the next state is D.\n// Therefore, only condition for Y1 to be 1 is when current state is A and w is 1.\n\nassign Y1 = y[0] & w;\n\n\n// For Y3 (input to state flip-flop y[3], which corresponds to state D)\n// From the state diagram:\n// B (0) --0--> D, thus when in state B (000010) and w is 0, Y3 should be 1.\n// C (0) --0--> D, thus when in state C (000100) and w is 0, Y3 should be 1.\n// E (1) --0--> D, thus when in state E (010000) and w is 0, Y3 should be 1.\n// F (1) --0--> D, thus when in state F (100000) and w is 0, Y3 should be 1.\n// Therefore, the condition for Y3 to be 1 is when current state is B, C, E, or F and w is 0.\n\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\n\nendmodule\n", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n// State B is represented by y[1] and State D by y[3]\n// From the state diagram, State B transitions to State D on a 0 input, which corresponds to Y3\n// Similarly, State D transitions to State A (y[0]) on a 0 input and to State F (y[5]) on a 1 input, neither directly influence Y1 as it represents State B\n// Thus, Y1's only change comes from State A (y[0]) transition to State B on a 1 input\n\n// Y1 becomes 1 if we're in State A and w is 1\nassign Y1 = y[0] & w;\n\n// Y3 becomes 1 in two cases:\n// 1. Transition from State B to State D on a 0 input => y[1] & ~w\n// 2. Transition from State C to State D on a 0 input => y[2] & ~w\n// Combining these two conditions for Y3\nassign Y3 = (y[1] | y[2]) & ~w;\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// State A to B (Y1) when w=1, B to E (Y3) when w=0\nassign Y1 = (y[0] & w) | (y[3] & ~w);\n// State B to D (Y3) when w=0, C to D (Y3) when w=0, F to D (Y3) when w=0\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[5] & ~w);\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// Calculating Y1 based on the state transition from A to B\nassign Y1 = (y[0] & w) | (y[2] & ~w);\n\n// Calculating Y3 based on the state transitions to D\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (~w & y[4]) | (w & y[5]);\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    // For Y1, the transitions to state B (y[1]) are from:\n    // A to B (when w=1)\n    // So, Y1 should be high when we are in state A (y[0]) and w is 1.\n    assign Y1 = y[0] & w;\n\n    // For Y3, the transitions to state D (y[3]) are from:\n    // B to D (when w=0)\n    // C to D (when w=0)\n    // E to D (when w=0)\n    // F to D (when w=0)\n    // Thus, Y3 should be high when we are in state B, C, E, or F and w is 0, which corresponds to y[1], y[2], y[4], or y[5] respectively.\n    assign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\n\nendmodule\n"]}
{"task_id": "kmap4", "gptgen_RTL": ["module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0001, 4'b0110, 4'b1011, 4'b1100, // abcd = 0001, 0110, 1011, 1100 corresponds to 1\n        4'b0100, 4'b0011, 4'b1110, 4'b1001: // abcd = 0100, 0011, 1110, 1001 corresponds to 1\n            out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n\tcase({a, b, c, d})\n\t\t4'b0000, 4'b0011, 4'b1100, 4'b1111: out = 1'b0;\n\t\t4'b0001, 4'b0010, 4'b1101, 4'b1110: out = 1'b1;\n\t\t4'b0100, 4'b0111, 4'b1000, 4'b1011: out = 1'b1;\n\t\t4'b0101, 4'b0110, 4'b1001, 4'b1010: out = 1'b0;\n\t\tdefault: out = 1'bx; // Undefined case\n\tendcase\nend\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @ (a or b or c or d) begin\n        case ({a, b, c, d})\n            4'b0001, 4'b0010, 4'b0111, 4'b0100, \n            4'b1011, 4'b1000, 4'b1101, 4'b1110: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0001, 4'b0110, 4'b0101, 4'b1010, 4'b1001, 4'b1110: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a, b, c, d})\n            4'b0001, 4'b0110, 4'b1010, 4'b1101: out = 1;\n            4'b0010, 4'b0101, 4'b1001, 4'b1110: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @ (a or b or c or d) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0110, 4'b1010, 4'b1101: out = 1;\n        4'b0010, 4'b0101, 4'b1001, 4'b1110: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @ (a or b or c or d) begin\n    case({a, b, c, d})\n        4'b0001, 4'b0110, 4'b1011, 4'b1100: out = 1;\n        4'b0100, 4'b1010, 4'b1111, 4'b1000: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0001, 4'b0110, 4'b0101, 4'b1010, 4'b1000, 4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0001, 4'b0110, 4'b1011, 4'b1100, // Cases where out = 1 based on the Karnaugh map\n        4'b0100, 4'b0011, 4'b1110, 4'b1001: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0001, 4'b0010, 4'b0110, 4'b1001, 4'b1010, 4'b1110: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n"]}
{"task_id": "m2014_q3", "gptgen_RTL": ["module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case(x)\n            4'b0000, 4'b0001, 4'b0010, 4'b0011: f = 1'bx; // Don't cares for 00 row\n            4'b0100: f = 0; // 01 00\n            4'b0101, 4'b0110, 4'b0111: f = 1'bx; // Don't cares for 01 row\n            4'b0110: f = 1; // 01 11\n            4'b0101: f = 0; // 01 10\n            4'b1100, 4'b1101: f = 1; // 11 00 and 11 01\n            4'b1110, 4'b1111: f = 1'bx; // Don't cares for 11 row\n            4'b1000, 4'b1001: f = 1; // 10 00 and 10 01\n            4'b1010: f = 0; // 10 10\n            4'b1011: f = 1'bx; // Don't care for 10 11\n            default: f = 1'bx; // Default case as a safe practice\n        endcase\n    end\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implementing the K-map\n    always @(*) begin\n        case (x)\n            4'b0000, 4'b0001, 4'b0010, 4'b0011: f = 1'bx; // Don't care conditions for 00 row\n            4'b0100: f = 0; // 01 row, 00 column\n            4'b0101: f = 1'bx; // Don't care condition\n            4'b0110: f = 1; // 01 row, 11 column\n            4'b0111: f = 0; // 01 row, 10 column\n            4'b1000, 4'b1001: f = 1; // 10 row, 00 and 01 columns\n            4'b1010: f = 0; // 10 row, 11 column\n            4'b1011: f = 1'bx; // Don't care condition\n            4'b1100, 4'b1101: f = 1; // 11 row, 00 and 01 columns\n            4'b1110, 4'b1111: f = 1'bx; // Don't care conditions for 11 row\n            default: f = 0; // Default case\n        endcase\n    end\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implementing the function based on the Karnaugh map provided\n    assign f = (x[4:3] == 2'b11 & x[2:1] != 2'b10) | \n               (x[4:3] == 2'b10) |\n               (x[4:3] == 2'b01 & x[2:1] == 2'b11);\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implement the function based on the Karnaugh map given\n    always @(*) begin\n        case(x)\n            4'b0100: f = 0; // x[1]x[2]=00, x[3]x[4]=01\n            4'b0110: f = 1; // x[1]x[2]=10, x[3]x[4]=01\n            4'b0101: f = 0; // x[1]x[2]=01, x[3]x[4]=01\n            4'b1100: f = 1; // x[1]x[2]=00, x[3]x[4]=11\n            4'b1101: f = 1; // x[1]x[2]=01, x[3]x[4]=11\n            4'b1110: f = 0; // x[1]x[2]=10, x[3]x[4]=11\n            4'b1000: f = 1; // x[1]x[2]=00, x[3]x[4]=10\n            4'b1001: f = 1; // x[1]x[2]=01, x[3]x[4]=10\n            default: f = 0; // For all other cases including don't-care\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case (x)\n            4'b0101: f = 1; // x[4:1] = 0101\n            4'b0110: f = 0; // x[4:1] = 0110\n            4'b1100: f = 1; // x[4:1] = 1100\n            4'b1101: f = 1; // x[4:1] = 1101\n            4'b1010: f = 1; // x[4:1] = 1010\n            4'b1011: f = 1; // x[4:1] = 1011\n            default: f = 0; // Default to 0 for all other combinations and don't care conditions\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case(x)\n            4'b0100, 4'b0110, 4'b1110: f = 0;\n            4'b1100, 4'b1101, 4'b1111, 4'b0111: f = 1;\n            default: f = 0; // Assuming don't-cares as 0 for simplicity\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implementing the function based on the Karnaugh map\n    assign f = (x[4:3] == 2'b11) | \n               (x[4:3] == 2'b01 & x[2] & ~x[1]) | \n               (x[4:3] == 2'b10);\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(x) begin\n        case (x)\n            4'b0100, 4'b0110, 4'b1100, 4'b1101, 4'b1000, 4'b1001: f = 1;\n            4'b0101, 4'b0111, 4'b1010, 4'b1011: f = 0;\n            default: f = 1'bx; // for don't care conditions\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case (x)\n            4'b0000, 4'b0001, 4'b0010, 4'b0011: f = 1'bx; // don't care for 00xx\n            4'b0100: f = 0; // 0100\n            4'b0101: f = 1'bx; // don't care for 0101\n            4'b0110: f = 1; // 0110\n            4'b0111: f = 0; // 0111\n            4'b1000, 4'b1001: f = 1; // 10xx\n            4'b1010: f = 1; // 1010\n            4'b1011: f = 1'bx; // don't care for 1011\n            4'b1100, 4'b1101, 4'b1110, 4'b1111: f = 1'bx; // don't care for 11xx\n            default: f = 0; // Default case\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n// Simplifying the Karnaugh map, we derive the minimized boolean expression for f\n// After analyzing the Karnaugh map, the minimized expression for the function can be given as:\n// f = x[1]x[3] + x[2]x[3] + x[1]x[4]'\n\n    assign f = (x[1] & x[3]) | (x[2] & x[3]) | (x[1] & ~x[4]);\n\nendmodule\n"]}
{"task_id": "notgate", "gptgen_RTL": ["module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n"]}
{"task_id": "mux2to1v", "gptgen_RTL": ["module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n"]}
{"task_id": "gates", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n// (1) out_and: a and b\nassign out_and = a & b;\n\n// (2) out_or: a or b\nassign out_or = a | b;\n\n// (3) out_xor: a xor b\nassign out_xor = a ^ b;\n\n// (4) out_nand: a nand b\nassign out_nand = ~(a & b);\n\n// (5) out_nor: a nor b\nassign out_nor = ~(a | b);\n\n// (6) out_xnor: a xnor b\nassign out_xnor = ~(a ^ b);\n\n// (7) out_anotb: a and-not b\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule\n"]}
{"task_id": "7458", "gptgen_RTL": ["module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1_out, and2_out, and3_out, and4_out;\n\n// For p1y: AND gates for three inputs\nassign and1_out = p1a & p1b & p1c;\nassign and2_out = p1d & p1e & p1f;\n// OR gate for the above AND gates\nassign p1y = and1_out | and2_out;\n\n// For p2y: AND gates for two inputs\nassign and3_out = p2a & p2b;\nassign and4_out = p2c & p2d;\n// OR gate for the above AND gates\nassign p2y = and3_out | and4_out;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1_out, and2_out, and3_out, and4_out;\n\n// AND gates for p1y\nassign and1_out = p1a & p1b & p1c;\nassign and2_out = p1d & p1e & p1f;\n\n// OR gate for p1y\nassign p1y = and1_out | and2_out;\n\n// AND gates for p2y\nassign and3_out = p2a & p2b;\nassign and4_out = p2c & p2d;\n\n// OR gate for p2y\nassign p2y = and3_out | and4_out;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\n// AND gates for p1y\nassign and1 = p1a & p1b & p1c; // 3-input AND gate\nassign and2 = p1d & p1e & p1f; // 3-input AND gate\n// OR gate for p1y\nassign p1y = and1 | and2;\n\n// AND gates for p2y\nassign and3 = p2a & p2b; // 2-input AND gate\nassign and4 = p2c & p2d; // 2-input AND gate\n// OR gate for p2y\nassign p2y = and3 | and4;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\n// AND gates for p1y\nassign and1 = p1a & p1b & p1c;\nassign and2 = p1d & p1e & p1f;\n\n// AND gates for p2y\nassign and3 = p2a & p2b;\nassign and4 = p2c & p2d;\n\n// OR gates for outputs\nassign p1y = and1 | and2;\nassign p2y = and3 | and4;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\n// First three-input AND gates for p1y\nassign and1 = p1a & p1b & p1c;\nassign and2 = p1d & p1e & p1f;\n\n// OR gate for p1y\nassign p1y = and1 | and2;\n\n// Two-input AND gates for p2y\nassign and3 = p2a & p2b;\nassign and4 = p2c & p2d;\n\n// OR gate for p2y\nassign p2y = and3 | and4;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\nassign and1 = p1a & p1b & p1c; // First 3-input AND gate for p1y\nassign and2 = p1d & p1e & p1f; // Second 3-input AND gate for p1y\nassign p1y = and1 | and2; // OR gate combining the two 3-input AND gates\n\nassign and3 = p2a & p2b; // First 2-input AND gate for p2y\nassign and4 = p2c & p2d; // Second 2-input AND gate for p2y\nassign p2y = and3 | and4; // OR gate combining the two 2-input AND gates\n\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\nwire and1, and2, and3, and4;\n\n// Four AND gates for the intermediate signals\nassign and1 = p1a & p1b & p1c; // AND gate for p1a, p1b, and p1c\nassign and2 = p1d & p1e & p1f; // AND gate for p1d, p1e, and p1f\nassign and3 = p2a & p2b;       // AND gate for p2a and p2b\nassign and4 = p2c & p2d;       // AND gate for p2c and p2d\n\n// Two OR gates for the output signals\nassign p1y = and1 | and2;      // OR gate combining and1 and and2\nassign p2y = and3 | and4;      // OR gate combining and3 and and4\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\n// First 3-input AND gates for p1y\nassign and1 = p1a & p1b & p1c;\n// Second 3-input AND gate for p1y\nassign and2 = p1d & p1e & p1f;\n// First 2-input AND gate for p2y\nassign and3 = p2a & p2b;\n// Second 2-input AND gate for p2y\nassign and4 = p2c & p2d;\n\n// OR gates to produce final outputs\nassign p1y = and1 | and2;\nassign p2y = and3 | and4;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1_out, and2_out, and3_out, and4_out;\n\n// For p1y output\nassign and1_out = p1a & p1b & p1c; // AND gate for p1a, p1b, and p1c\nassign and2_out = p1d & p1e & p1f; // AND gate for p1d, p1e, and p1f\nassign p1y = and1_out | and2_out;  // OR gate for the outputs of the two AND gates above\n\n// For p2y output\nassign and3_out = p2a & p2b; // AND gate for p2a and p2b\nassign and4_out = p2c & p2d; // AND gate for p2c and p2d\nassign p2y = and3_out | and4_out; // OR gate for the outputs of the two AND gates above\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\n// AND gates for p1y\nassign and1 = p1a & p1b & p1c; // 3-input AND gate\nassign and2 = p1d & p1e & p1f; // 3-input AND gate\n// OR gate for p1y\nassign p1y = and1 | and2; // OR gate combining the outputs of the two 3-input AND gates\n\n// AND gates for p2y\nassign and3 = p2a & p2b; // 2-input AND gate\nassign and4 = p2c & p2d; // 2-input AND gate\n// OR gate for p2y\nassign p2y = and3 | and4; // OR gate combining the outputs of the two 2-input AND gates\n\nendmodule\n"]}
{"task_id": "wire", "gptgen_RTL": ["module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n"]}
{"task_id": "m2014_q4e", "gptgen_RTL": ["module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n"]}
{"task_id": "m2014_q4h", "gptgen_RTL": ["module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n"]}
