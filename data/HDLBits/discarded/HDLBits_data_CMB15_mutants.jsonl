{"task_id": "always_nolatches", "mutants": ["module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\t\t// Change: Added an extra case that does nothing, essentially a no-op\n\t\t\t16'he000: ;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t// Change: Initially set {up, left, down, right} to 4'b0001 instead of 0\n\t\t{up, left, down, right} = 4'b0001;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\t// Change: Swapped the order of cases\n\t\tcase (scancode)\n\t\t\t16'he075: up = 1;\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he072: down = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t// Change: Changed the scancode for up arrow\n\t\t\t16'he076: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t// Change: Changed the scancode for left arrow\n\t\t\t16'he06c: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\t\t// Change: Incorrectly mapped scancode for an additional output, should not affect original functionality\n\t\t\t16'he077: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\t// Change: Inverted the initial condition for one of the outputs\n\talways @(*) begin\n\t\t{up, left, down, right} = 4'b1000;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\t// Change: Added a default case that sets all outputs to 1\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\t\tdefault: {up, left, down, right} = 4'b1111;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t// Change: Removed the case for right arrow\n\t\t\t// 16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t// Change: Combined cases for down and right arrows\n\t\t\t16'he072, 16'he074: {down, right} = 2'b11;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n"]}
{"task_id": "fadd", "mutants": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a + b + cin; // No change, for reference\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a - b + cin; // Changed '+' to '-' between a and b\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a + b - cin; // Changed '+' to '-' for cin\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {sum, cout} = a + b + cin; // Swapped cout and sum in the assignment\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = {1'b0, a + b + cin}; // Added a constant bit '0' at the beginning of the result\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a & b + cin; // Changed '+' to '&' between a and b\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a + b + {cin}; // Enclosed cin in braces, no effective change but syntax variation\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a + b + cin ^ 1'b1; // Added XOR with 1 to the sum of a, b, and cin\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = (a + b + cin) | 1'b1; // Added OR with 1 to the result\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a + !b + cin; // Added logical NOT to b\nendmodule\n"]}
{"task_id": "always_case2", "mutants": ["module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0; // No change here; included for reference\n\t\t\t4'h2: pos = 2'h2; // Changed pos from 2'h1 to 2'h2\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h1; // Changed pos from 2'h2 to 2'h1\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h2; // Changed pos from 2'h1 to 2'h2\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h2; // Changed pos from 2'h3 to 2'h2\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n"]}
{"task_id": "m2014_q4j", "mutants": ["module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x+y; // Changed: No change in code; serves as a baseline for comparison.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x+y+1; // Change: Added 1 to the sum.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = {1'b0,x} + {1'b0,y}; // Change: Explicitly extended both operands to 5 bits before addition.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x+y-1; // Change: Subtracted 1 from the sum.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x-y; // Change: Changed addition to subtraction.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = {x[3], x} + {y[3], y}; // Change: Extended each operand to 5 bits using MSB before addition.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x+y; // Change: No functional change; included for diversity.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x^y; // Change: Changed addition to XOR operation.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = (x+y)^5'b00001; // Change: XORed the result with 1.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x|y; // Change: Changed addition to OR operation.\nendmodule\n"]}
{"task_id": "vector0", "mutants": ["module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign {o2, o1, o0} = {vec[1], vec[0], vec[2]}; // Changed the ordering in the bit assignment\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = {vec[0], vec[2], vec[1]}; // Changed the order of bits in the output vector\n    assign {o2, o1, o0} = vec;\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign {o2, o0, o1} = vec; // Swapped o1 and o0 in the bit assignment\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = ~vec; // Inverted the bits of vec for the output vector\n    assign {o2, o1, o0} = vec;\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = {3{vec[0]}}; // Replicated the first bit of vec across the outv\n    assign {o2, o1, o0} = vec;\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign {o2, o1, o0} = vec ^ 3'b101; // XORed vec with a bit pattern before assignment\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign {o2, o1} = vec[2:1]; // Only assigned the first two bits, leaving o0 disconnected\n    // o0 is not assigned\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = {vec[1:0], vec[2]}; // Rearranged bits in outv\n    assign {o2, o1, o0} = vec;\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign {o2, o1, o0} = {2'b00, vec[0]}; // Only the least significant bit of vec is used, zeros for others\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = {vec[2], vec[2:1]}; // Incorrect bit-width for assignment, potentially causing a warning\n    assign {o2, o1, o0} = vec;\n\nendmodule\n"]}
{"task_id": "2012_q2b", "mutants": ["module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&w; // Unchanged\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & w; // Changed ~w to w\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]|w; // Changed & to |\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w; // Unchanged\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&w; // Unchanged\n    assign Y3 = (y[1]&y[2]|y[4]|y[5]) & ~w; // Changed | to & between y[1] and y[2]\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = !y[0]&w; // Changed y[0] to !y[0]\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w; // Unchanged\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&w; // Unchanged\n    assign Y3 = (y[0]|y[1]|y[2]|y[4]|y[5]) & ~w; // Added y[0] to the Y3 condition\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = (y[0]&w) | y[1]; // Added y[1] to the Y1 condition\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w; // Unchanged\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&w; // Unchanged\n    assign Y3 = (y[1]|y[2]|y[4]) & ~w; // Removed y[5] from the Y3 condition\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&!w; // Changed w to !w for Y1\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w; // Unchanged\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = (y[0]^w); // Changed & to ^ for Y1\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w; // Unchanged\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&w; // Unchanged\n    assign Y3 = (y[1]|y[2]|y[3]|y[4]|y[5]) & ~w; // Added y[3] to the Y3 condition\nendmodule\n"]}
{"task_id": "kmap4", "mutants": ["module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 1; // Mutation: changed out to 1\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0; // Mutation: changed out to 0\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 1; // Mutation: changed out to 1\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 1; // Mutation: changed out to 1\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 0; // Mutation: changed out to 0\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 1; // Mutation: changed out to 1\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 0; // Mutation: changed out to 0\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 0; // Mutation: changed out to 0\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 0; // Mutation: changed out to 0\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 1; // Mutation: changed out to 1\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n"]}
{"task_id": "m2014_q3", "mutants": ["module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1; // Changed from 1'bx to 1\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 0; // Changed from 1'bx to 0\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 0; // Changed from 1'bx to 0\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 0; // Changed from 1 to 0\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 1; // Changed from 0 to 1\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1; // Changed from 1'bx to 1\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 0; // Changed from 1'bx to 0\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 0; // Changed from 1 to 0\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 1; // Changed from 0 to 1\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 1; // Changed from 0 to 1\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 1; // Changed from 0 to 1\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n"]}
{"task_id": "notgate", "mutants": ["module top_module(\n    input in,\n    output out\n);\n    \n    assign out = ~in; // Mutation: No change, control mutation to establish a baseline difference.\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n    \n    assign out = in; // Mutation: Removed NOT operation, making it a buffer instead of a NOT gate.\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n    \n    assign out = ~in | in; // Mutation: Added OR operation with the same input, making the output always 1.\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n    \n    assign out = ~in & in; // Mutation: Added AND operation with its inverse, making the output always 0.\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n    \n    wire temp; // Mutation: Introduced an intermediary wire but not used.\n    assign out = ~in;\n    \nendmodule\n"]}
{"task_id": "mux2to1v", "mutants": ["module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? a : b; // Change: swapped a and b in the ternary operation\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? b : {a[98:0], a[99]}; // Change: rotated a to the right\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? {b[0], b[99:1]} : a; // Change: rotated b to the left\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? b : ~a; // Change: bitwise NOT operation on a\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? ~b : a; // Change: bitwise NOT operation on b\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? {b[99:50], a[49:0]} : a; // Change: mixed half of b and half of a when sel=1\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? b : {a[49:0], a[99:50]}; // Change: swapped the halves of a\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? {b[50:0], b[99:51]} : a; // Change: swapped the halves of b and made an off by one change\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel && sel ? b : a; // Change: redundant logical AND operation on sel\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = !sel ? b : a; // Change: negated the selector condition\n\nendmodule\n"]}
{"task_id": "gates", "mutants": ["module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = a^~b; // Change: Used a^~b instead of ~(a^b) for xnor, logically same but minor alteration in expression\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b); // No change here \n\tassign out_nor = ~(a|b); // No change here \n\tassign out_xnor = ~(a^b); // No change here \n\tassign out_anotb = a & b; // Change: Incorrectly showing AND result instead of AND-NOT\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^~b; // Change: XOR with inverted b, changing the logic.\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|~b; // Change: OR with inverted b, changing the logic.\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = a&b; // Change: Removed inversion for nand, changing the logic.\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = a|b; // Change: Removed inversion for nor, logically incorrect.\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a|b; // Change: Incorrectly using OR operation for AND output.\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a&b; // Change: Using AND operation for XOR output, logically incorrect.\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a&b; // Change: Using AND operation for OR output, logically incorrect.\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = a|~b; // Change: Used OR with inverted b instead of XNOR logic, altering the logical operation.\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n"]}
{"task_id": "7458", "mutants": ["module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} & &{p1d, p1e, p1f}; // Changed | to &\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = |{p1a, p1b, p1c} | &{p1d, p1e, p1f}; // Changed & to | for first AND\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = |{p2a, p2b} | &{p2c, p2d}; // Changed & to | for first AND in p2y\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = &{p2a, p2b} | |{p2c, p2d}; // Changed & to | for second AND in p2y\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b} | &{p1d, p1e, p1f}; // Removed p1c from first AND\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e}; // Removed p1f from second AND\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c, p1d} | &{p1e, p1f}; // Added p1d to first AND, changing functionality\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = &{p2a} | &{p2c, p2d}; // Removed p2b from first AND\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = &{p2a, p2b} | &{p2d}; // Removed p2c from second AND\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1c} | &{p1d, p1e, p1f}; // Removed p1b from first AND\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n"]}
{"task_id": "wire", "mutants": ["module top_module(\n    input in,\n    output out);\n    \n    assign out = !in; // Changed: Negated input to output\n    \nendmodule\n", "module top_module(\n    input in,\n    output reg out); // Changed: Output from wire to reg\n    \n    always @(in) begin\n        out = in;\n    end\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in | 1'b0; // Changed: OR operation with 0\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in & 1'b1; // Changed: AND operation with 1\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in ^ 1'b0; // Changed: XOR operation with 0\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in; // No change here for control comparison\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = ~in; // Changed: Complement of input to output\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = {in}; // Changed: Concatenation with itself (no actual change in functionality)\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in >>> 1'b0; // Changed: Arithmetic right shift by 0\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in << 1'b0; // Changed: Logical left shift by 0\n    \nendmodule\n"]}
{"task_id": "m2014_q4e", "mutants": ["module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2); // Original: assign out = ~(in1 | in2); Modification: No change to demonstrate the original for comparison.\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 & in2); // Changed OR to AND\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = (in1 | in2); // Removed NOT operator\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2) ^ 1'b1; // Added XOR with 1 after original operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~((in1 | in2) & 1'b1); // Added AND with 1 before NOT operator\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~((in1 | in2) | 1'b0); // Added OR with 0 before NOT operator\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1); // Only considering in1 for the NOR operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in2); // Only considering in2 for the NOR operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2 | in1); // Duplicated in1 in OR operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~((in1 & in2) | in2); // Combined AND with in2 and OR with in2\nendmodule\n"]}
{"task_id": "m2014_q4h", "mutants": ["module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = ~in; // Negated the input signal\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in & in; // AND operation with itself, essentially the same but logically different\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in | in; // OR operation with itself, essentially the same but logically different\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\twire internal; // Added an internal wire\n\tassign internal = in;\n\tassign out = internal; // Routed input through an internal wire before output\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in ^ in; // XOR operation with itself, should result in 0\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in; // Original line\n\t//Added redundant assignment which is functionally the same\n\tassign out = in;\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\t// Change made to use a ternary operator, logically identical\n\tassign out = in ? 1'b1 : 1'b0;\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\t// Negated the input, then negated it again\n\tassign out = ~(~in);\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\t// Changed to add a delay to the assignment, may introduce simulation mismatches\n\tassign #1 out = in;\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\t// Use of buffer operation via ANDing with 1, though logically unnecessary\n\tassign out = in & 1'b1;\nendmodule\n"]}
