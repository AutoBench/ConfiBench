{"task_id": "m2014_q6b", "mutants": ["module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0; // No change\n\t\t\t4'h1: Y2 = 1'b0; // No change\n\t\t\t4'h2: Y2 = 1'b1; // No change\n\t\t\t4'h3: Y2 = 1'b1; // No change\n\t\t\t4'h4: Y2 = 1'b0; // No change\n\t\t\t4'h5: Y2 = 1'b1; // No change\n\t\t\t4'h6: Y2 = 1'b0; // No change\n\t\t\t4'h7: Y2 = 1'b1; // Changed 0 to 1\n\t\t\t4'h8: Y2 = 1'b0; // No change\n\t\t\t4'h9: Y2 = 1'b1; // No change\n\t\t\t4'ha: Y2 = 1'b1; // No change\n\t\t\t4'hb: Y2 = 1'b1; // No change\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0; // No change\n\t\t\t4'h1: Y2 = 1'b1; // Changed 0 to 1\n\t\t\t4'h2: Y2 = 1'b1; // No change\n\t\t\t4'h3: Y2 = 1'b1; // No change\n\t\t\t4'h4: Y2 = 1'b0; // No change\n\t\t\t4'h5: Y2 = 1'b1; // No change\n\t\t\t4'h6: Y2 = 1'b0; // No change\n\t\t\t4'h7: Y2 = 1'b0; // No change\n\t\t\t4'h8: Y2 = 1'b0; // No change\n\t\t\t4'h9: Y2 = 1'b1; // No change\n\t\t\t4'ha: Y2 = 1'b1; // No change\n\t\t\t4'hb: Y2 = 1'b1; // No change\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0; // No change\n\t\t\t4'h1: Y2 = 1'b0; // No change\n\t\t\t4'h2: Y2 = 1'b0; // Changed 1 to 0\n\t\t\t4'h3: Y2 = 1'b1; // No change\n\t\t\t4'h4: Y2 = 1'b0; // No change\n\t\t\t4'h5: Y2 = 1'b1; // No change\n\t\t\t4'h6: Y2 = 1'b0; // No change\n\t\t\t4'h7: Y2 = 1'b0; // No change\n\t\t\t4'h8: Y2 = 1'b0; // No change\n\t\t\t4'h9: Y2 = 1'b1; // No change\n\t\t\t4'ha: Y2 = 1'b1; // No change\n\t\t\t4'hb: Y2 = 1'b1; // No change\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b1; // Changed 0 to 1\n\t\t\t4'h1: Y2 = 1'b0; // No change\n\t\t\t4'h2: Y2 = 1'b1; // No change\n\t\t\t4'h3: Y2 = 1'b1; // No change\n\t\t\t4'h4: Y2 = 1'b0; // No change\n\t\t\t4'h5: Y2 = 1'b1; // No change\n\t\t\t4'h6: Y2 = 1'b0; // No change\n\t\t\t4'h7: Y2 = 1'b0; // No change\n\t\t\t4'h8: Y2 = 1'b0; // No change\n\t\t\t4'h9: Y2 = 1'b1; // No change\n\t\t\t4'ha: Y2 = 1'b1; // No change\n\t\t\t4'hb: Y2 = 1'b1; // No change\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0; // No change\n\t\t\t4'h1: Y2 = 1'b0; // No change\n\t\t\t4'h2: Y2 = 1'b1; // No change\n\t\t\t4'h3: Y2 = 1'b1; // No change\n\t\t\t4'h4: Y2 = 1'b1; // Changed 0 to 1\n\t\t\t4'h5: Y2 = 1'b1; // No change\n\t\t\t4'h6: Y2 = 1'b0; // No change\n\t\t\t4'h7: Y2 = 1'b0; // No change\n\t\t\t4'h8: Y2 = 1'b0; // No change\n\t\t\t4'h9: Y2 = 1'b1; // No change\n\t\t\t4'ha: Y2 = 1'b1; // No change\n\t\t\t4'hb: Y2 = 1'b1; // No change\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0; // No change\n\t\t\t4'h1: Y2 = 1'b0; // No change\n\t\t\t4'h2: Y2 = 1'b1; // No change\n\t\t\t4'h3: Y2 = 1'b1; // No change\n\t\t\t4'h4: Y2 = 1'b0; // No change\n\t\t\t4'h5: Y2 = 1'b0; // Changed 1 to 0\n\t\t\t4'h6: Y2 = 1'b0; // No change\n\t\t\t4'h7: Y2 = 1'b0; // No change\n\t\t\t4'h8: Y2 = 1'b0; // No change\n\t\t\t4'h9: Y2 = 1'b1; // No change\n\t\t\t4'ha: Y2 = 1'b1; // No change\n\t\t\t4'hb: Y2 = 1'b1; // No change\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0; // No change\n\t\t\t4'h1: Y2 = 1'b0; // No change\n\t\t\t4'h2: Y2 = 1'b1; // No change\n\t\t\t4'h3: Y2 = 1'b0; // Changed 1 to 0\n\t\t\t4'h4: Y2 = 1'b0; // No change\n\t\t\t4'h5: Y2 = 1'b1; // No change\n\t\t\t4'h6: Y2 = 1'b0; // No change\n\t\t\t4'h7: Y2 = 1'b0; // No change\n\t\t\t4'h8: Y2 = 1'b0; // No change\n\t\t\t4'h9: Y2 = 1'b1; // No change\n\t\t\t4'ha: Y2 = 1'b1; // No change\n\t\t\t4'hb: Y2 = 1'b1; // No change\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0; // No change\n\t\t\t4'h1: Y2 = 1'b0; // No change\n\t\t\t4'h2: Y2 = 1'b1; // No change\n\t\t\t4'h3: Y2 = 1'b1; // No change\n\t\t\t4'h4: Y2 = 1'b0; // No change\n\t\t\t4'h5: Y2 = 1'b1; // No change\n\t\t\t4'h6: Y2 = 1'b1; // Changed 0 to 1\n\t\t\t4'h7: Y2 = 1'b0; // No change\n\t\t\t4'h8: Y2 = 1'b0; // No change\n\t\t\t4'h9: Y2 = 1'b1; // No change\n\t\t\t4'ha: Y2 = 1'b1; // No change\n\t\t\t4'hb: Y2 = 1'b1; // No change\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0; // No change\n\t\t\t4'h1: Y2 = 1'b0; // No change\n\t\t\t4'h2: Y2 = 1'b1; // No change\n\t\t\t4'h3: Y2 = 1'b1; // No change\n\t\t\t4'h4: Y2 = 1'b0; // No change\n\t\t\t4'h5: Y2 = 1'b1; // No change\n\t\t\t4'h6: Y2 = 1'b0; // No change\n\t\t\t4'h7: Y2 = 1'b0; // No change\n\t\t\t4'h8: Y2 = 1'b1; // Changed 0 to 1\n\t\t\t4'h9: Y2 = 1'b1; // No change\n\t\t\t4'ha: Y2 = 1'b1; // No change\n\t\t\t4'hb: Y2 = 1'b1; // No change\n\t\t\tdefault: Y2 = 1'bx; // No change\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0; // No change\n\t\t\t4'h1: Y2 = 1'b0; // No change\n\t\t\t4'h2: Y2 = 1'b1; // No change\n\t\t\t4'h3: Y2 = 1'b1; // No change\n\t\t\t4'h4: Y2 = 1'b0; // No change\n\t\t\t4'h5: Y2 = 1'b1; // No change\n\t\t\t4'h6: Y2 = 1'b0; // No change\n\t\t\t4'h7: Y2 = 1'b0; // No change\n\t\t\t4'h8: Y2 = 1'b0; // No change\n\t\t\t4'h9: Y2 = 1'b0; // Changed 1 to 0\n\t\t\t4'ha: Y2 = 1'b1; // No change\n\t\t\t4'hb: Y2 = 1'b1; // No change\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\nendmodule\n"]}
{"task_id": "ringer", "mutants": ["module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring & ~vibrate_mode; // No change\n\tassign motor = ring | vibrate_mode; // Changed & to | for motor assignment\n\nendmodule\n", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring | ~vibrate_mode; // Changed & to | for ringer assignment\n\tassign motor = ring & vibrate_mode; // No change\n\nendmodule\n", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring ^ ~vibrate_mode; // Changed & to ^ for ringer assignment\n\tassign motor = ring & vibrate_mode; // No change\n\nendmodule\n", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring & ~vibrate_mode; // No change\n\tassign motor = ring ^ vibrate_mode; // Changed & to ^ for motor assignment\n\nendmodule\n", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ~ring & ~vibrate_mode; // Added ~ before ring for ringer assignment\n\tassign motor = ring & vibrate_mode; // No change\n\nendmodule\n", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring & ~vibrate_mode; // No change\n\tassign motor = ~ring & vibrate_mode; // Added ~ before ring for motor assignment\n\nendmodule\n", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring & vibrate_mode; // Changed ~vibrate_mode to vibrate_mode for ringer assignment\n\tassign motor = ring & vibrate_mode; // No change\n\nendmodule\n", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring & ~vibrate_mode; // No change\n\tassign motor = !ring & vibrate_mode; // Changed & to & and ring to !ring for motor assignment\n\nendmodule\n", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = !ring & ~vibrate_mode; // Changed ring to !ring for ringer assignment\n\tassign motor = ring & vibrate_mode; // No change\n\nendmodule\n", "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring & ~vibrate_mode; // No change\n\tassign motor = ring & !vibrate_mode; // Changed vibrate_mode to !vibrate_mode for motor assignment\n\nendmodule\n"]}
{"task_id": "alwaysblock1", "mutants": ["module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = a & b; // No change\n\talways @(a) out_alwaysblock = a & b; // Changed from always @(*) to always @(a)\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = a | b; // Changed & to |\n\talways @(*) out_alwaysblock = a & b; // No change\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = a & b; // No change\n\talways @(*) out_alwaysblock = a | b; // Changed & to |\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = ~a & b; // Added NOT operation to a\n\talways @(*) out_alwaysblock = a & b; // No change\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = a & b; // No change\n\talways @(*) out_alwaysblock = ~a & b; // Added NOT operation to a\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = a & ~b; // Added NOT operation to b\n\talways @(*) out_alwaysblock = a & b; // No change\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = a & b; // No change\n\talways @(*) out_alwaysblock = a & ~b; // Added NOT operation to b\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = a & b; // No change\n\talways @(b) out_alwaysblock = a & b; // Changed from always @(*) to always @(b)\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = a ^ b; // Changed & to ^\n\talways @(*) out_alwaysblock = a & b; // No change\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = a & b; // No change\n\talways @(*) out_alwaysblock = a ^ b; // Changed & to ^\n\t\nendmodule\n"]}
{"task_id": "zero", "mutants": ["module top_module(\n\toutput zero);\n\t\n\tassign zero = ~1'b1; // Changed 1'b0 to ~1'b1\n\nendmodule\n", "module top_module(\n\toutput zero);\n\t\n\tassign zero = 1'b0 & 1'b1; // Added an AND operation with 1\n\nendmodule\n", "module top_module(\n\toutput zero);\n\t\n\tassign zero = 1'b0 | 1'b0; // Added an OR operation with 0\n\nendmodule\n", "module top_module(\n\toutput zero);\n\t\n\tassign zero = 0; // Changed 1'b0 to 0\n\nendmodule\n", "module top_module(\n\toutput zero);\n\t\n\tassign zero = 1'b0 ^ 1'b0; // Added an XOR operation with 0\n\nendmodule\n"]}
{"task_id": "vector2", "mutants": ["module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[15:8], in[7:0], in[23:16], in[31:24]}; // Swapped first two bytes\n    \nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[31:24], in[23:16]}; // Swapped last two bytes\n    \nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[7:0], in[23:16], in[15:8], in[31:24]}; // Moved the third byte to the second position\n    \nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[22:16], in[31:24]}; // Shortened the third byte by one bit\n    \nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[6:0], in[15:8], in[23:16], in[31:24]}; // Shortened the first byte by one bit\n    \nendmodule\n"]}
{"task_id": "mt2015_q4a", "mutants": ["module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x^y) & y; // Change: replaced 'x' with 'y' in the expression\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x^y) | x; // Change: replaced '&' with '|'\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput reg z); // Change: 'output' type changed from wire to reg\n\n\talways @(x or y) begin\n\t\tz = (x^y) & x;\n\tend\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (~x^y) & x; // Change: added '~' to 'x' in the expression\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x^~y) & x; // Change: added '~' to 'y' in the expression\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x^y) & ~x; // Change: added '~' to the second 'x' in the expression\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x^y); // Change: removed '& x' from the expression\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = x; // Change: simplified the expression to just 'x'\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = y; // Change: simplified the expression to just 'y'\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x^y) ^ x; // Change: replaced '&' with '^' for a different operation\nendmodule\n"]}
{"task_id": "vector1", "mutants": ["module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign {out_hi, out_lo} = {in[15:8], in[7:0]}; // Changed to explicit bit selection, no functional change.\n\nendmodule\n", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign {out_hi, out_lo} = {in[7:0], in[15:8]}; // Swapped high and low byte assignments.\n\nendmodule\n", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign out_hi = in[14:7]; // Change upper byte range.\n\tassign out_lo = in[6:0]; // Change lower byte range, losing 1 bit.\n\nendmodule\n", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[8:1]; // Shifted lower byte to the right by 1 bit.\n\nendmodule\n", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign out_hi = in[15:8] ^ 8'hFF; // Inverted the bits of out_hi.\n\tassign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign out_hi = in[15:8];\n\tassign out_lo = in[7:0] & 8'hFF; // Logical AND with 0xFF, no functional change but adds redundancy.\n\nendmodule\n", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign out_hi = in[15:8] | 8'h00; // Logical OR with 0x00, no functional change but adds redundancy.\n\tassign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign out_hi = {1'b0, in[15:9]}; // Removed the MSB of out_hi and replaced with 0.\n\tassign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign out_hi = {in[14:8], 1'b0}; // Removed the LSB of the original out_hi and appended 0 at the end.\n\tassign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign out_hi = in[15:8];\n\tassign out_lo = {2'b00, in[6:1]}; // Reduced out_lo range and padded with 2'b00.\n\nendmodule\n"]}
{"task_id": "norgate", "mutants": ["module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a & b); // Changed | to &\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a | b | a); // Added an extra 'a' in the NOR operation\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a | b) & a; // Added an AND operation with 'a'\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a | b) | a; // Added an OR operation with 'a'\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output reg out // Changed output type to reg\n);\n    \n    always @(a or b) begin\n        out = ~(a | b); // Changed assign to always block\n    end\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~((a | b) ^ a); // Added an XOR operation with 'a'\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a | b) ^ b; // Added an XOR operation with 'b'\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~((a | b) & b); // Changed the NOR operation to include an AND with 'b'\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~((a | b) | a); // Changed the NOR operation to include an OR with 'a'\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\n    assign out = ~(a ^ b); // Changed | to ^ for XOR operation\n    \nendmodule\n"]}
{"task_id": "m2014_q6c", "mutants": ["module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = y[1]&w; // Changed ~w to w\n\tassign Y4 = (y[2]|y[3]|y[5]|y[6]) & w;\nendmodule\n", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = y[1]&~w;\n\tassign Y4 = (y[2]&y[3]|y[5]|y[6]) & w; // Changed | to & for y[2] and y[3]\nendmodule\n", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = y[1]&~w;\n\tassign Y4 = (y[2]|y[3]|y[4]|y[5]|y[6]) & w; // Added y[4] in the equation\nendmodule\n", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = y[1]|~w; // Changed & to |\n\tassign Y4 = (y[2]|y[3]|y[5]|y[6]) & w;\nendmodule\n", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = y[1]&~w;\n\tassign Y4 = (y[1]|y[2]|y[3]|y[5]|y[6]) & w; // Added y[1] in the equation\nendmodule\n", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = y[2]&~w; // Changed y[1] to y[2]\n\tassign Y4 = (y[2]|y[3]|y[5]|y[6]) & w;\nendmodule\n", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = y[1]&~w;\n\tassign Y4 = !(y[2]|y[3]|y[5]|y[6]) & w; // Added negation ! in front of the equation\nendmodule\n", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = (y[1]&y[6])&~w; // Added y[6] in conjunction with y[1]\n\tassign Y4 = (y[2]|y[3]|y[5]|y[6]) & w;\nendmodule\n", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = y[1]&~w;\n\tassign Y4 = (y[2]|y[3]|y[5]) & w; // Removed y[6] from the equation\nendmodule\n", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = ~y[1]&~w; // Added negation ~ in front of y[1]\n\tassign Y4 = (y[2]|y[3]|y[5]|y[6]) & w;\nendmodule\n"]}
{"task_id": "mux256to1", "mutants": ["module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = in[sel ^ 1'b1]; // Modification: XOR sel with 1 to slightly change selection logic\n\nendmodule\n", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = in[sel] & 1'b1; // Modification: AND the output with 1 (logically same but adds an operation)\n\nendmodule\n", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = in[sel | 1'b0]; // Modification: OR sel with 0 (no change in logic, but adds an operation)\n\nendmodule\n", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = ~in[sel]; // Modification: Negate the selected output\n\nendmodule\n", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = in[sel + 1'b1]; // Modification: Select the next bit instead of the current one\n\nendmodule\n", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = in[sel - 1'b1]; // Modification: Select the previous bit instead of the current one\n\nendmodule\n", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = in[255 - sel]; // Modification: Invert selection order\n\nendmodule\n", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = in[sel] || 1'b0; // Modification: OR the output with 0 (no logical change, but adds an operation)\n\nendmodule\n", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = (in[sel] == 1'b1) ? 1'b0 : 1'b1; // Modification: Output the opposite value of the selected input\n\nendmodule\n", "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = in[sel & 255]; // Modification: AND sel with 255 (no change in logic since sel is 8 bits)\n\nendmodule\n"]}
{"task_id": "circuit4", "mutants": ["module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = c | b; // Minor change: no change (control example, not a valid mutant).\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = c & b; // Changed | to &\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = c | b | d; // Added d to the expression\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~c | b; // Complemented c\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = c | ~b; // Complemented b\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (c | b) & d; // Added d with an AND operation\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = c | (b & a); // Added a with an AND operation to b\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (c ^ b); // Changed | to ^ (XOR operation)\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = !(c | b); // Negated the entire expression\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = c & b & d; // Changed | to & and added d\n\nendmodule\n"]}
{"task_id": "circuit5", "mutants": ["module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = b; // No change\n\t\t\t1: q = e; // No change\n\t\t\t2: q = a; // No change\n\t\t\t3: q = d; // No change\n\t\t\tdefault: q = 4'hf; // No change\n\t\tendcase\nendmodule\n// Note: No actual change made, serving as a control.\n", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = b;\n\t\t\t1: q = e;\n\t\t\t2: q = d; // Changed from q = a to q = d\n\t\t\t3: q = d;\n\t\t\tdefault: q = 4'hf;\n\t\tendcase\nendmodule\n", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = b;\n\t\t\t1: q = e;\n\t\t\t2: q = a;\n\t\t\t3: q = d;\n\t\t\tdefault: q = 4'he; // Changed default to 4'he\n\t\tendcase\nendmodule\n", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = a; // Changed from q = b to q = a\n\t\t\t1: q = e;\n\t\t\t2: q = a;\n\t\t\t3: q = d;\n\t\t\tdefault: q = 4'hf;\n\t\tendcase\nendmodule\n", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = b;\n\t\t\t1: q = d; // Changed from q = e to q = d\n\t\t\t2: q = a;\n\t\t\t3: q = d;\n\t\t\tdefault: q = 4'hf;\n\t\tendcase\nendmodule\n", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = b;\n\t\t\t1: q = e;\n\t\t\t2: q = a;\n\t\t\t3: q = a; // Changed from q = d to q = a\n\t\t\tdefault: q = 4'hf;\n\t\tendcase\nendmodule\n", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = e; // Changed from q = b to q = e\n\t\t\t1: q = e;\n\t\t\t2: q = a;\n\t\t\t3: q = d;\n\t\t\tdefault: q = 4'hf;\n\t\tendcase\nendmodule\n", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = b;\n\t\t\t1: q = e;\n\t\t\t2: q = e; // Changed from q = a to q = e\n\t\t\t3: q = d;\n\t\t\tdefault: q = 4'hf;\n\t\tendcase\nendmodule\n", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = b;\n\t\t\t1: q = a; // Changed from q = e to q = a\n\t\t\t2: q = a;\n\t\t\t3: q = d;\n\t\t\tdefault: q = 4'hf;\n\t\tendcase\nendmodule\n", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = b;\n\t\t\t1: q = e;\n\t\t\t2: q = a;\n\t\t\t3: q = e; // Changed from q = d to q = e\n\t\t\tdefault: q = 4'hf;\n\t\tendcase\nendmodule\n"]}
{"task_id": "bugs_mux2", "mutants": ["module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    assign out = sel ? b : a; // Changed the ternary operator operands\nendmodule\n", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    assign out = sel ? a : b; // No change in logic; changed 'assign' to 'always @(sel or a or b)'\n    always @(sel or a or b) begin\n        out = sel ? a : b;\n    end\nendmodule\n", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    assign out = sel ? a[7:0] : b[7:0]; // Explicitly specified bit range, though no functional change\nendmodule\n", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    assign out = sel ? a : b ^ 8'hFF; // Added bitwise NOT to b\nendmodule\n", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    assign out = sel ? a & 8'hFF : b; // Added bitwise AND with FF to a\nendmodule\n", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    assign out = (sel & sel) ? a : b; // Redundantly used 'sel & sel'\nendmodule\n", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    assign out = (~sel) ? a : b; // Used '~sel' instead of 'sel'\nendmodule\n", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    assign out = sel ? {a[3:0], a[7:4]} : b; // Swapped nibbles of 'a'\nendmodule\n", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    assign out = sel ? a : {b[3:0], b[7:4]}; // Swapped nibbles of 'b'\nendmodule\n", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n    assign out = sel ? {a[6:0], a[7]} : b; // Circular shift left by 1 on 'a'\nendmodule\n"]}
{"task_id": "ece241_2014_q1c", "mutants": ["module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [8:0] sum = a+b; // No change\n\tassign s = sum[8:1]; // Changed from sum[7:0] to sum[8:1]\n\tassign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [8:0] sum = a+b; // No change\n\tassign s = sum[7:0]; // No change\n\tassign overflow = (a[7]^b[7]) && (a[7] != s[7]); // Changed ! to remove negation\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [8:0] sum = a-b; // Changed from a+b to a-b\n\tassign s = sum[7:0];\n\tassign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [8:0] sum = a+b; // No change\n\tassign s = sum[7:0]; // No change\n\tassign overflow = !(a[7]^b[7]) && (a[7] == s[7]); // Changed != to ==\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [9:0] sum = a+b; // Changed wire [8:0] to wire [9:0]\n\tassign s = sum[7:0];\n\tassign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [8:0] sum = {1'b0, a} + {1'b0, b}; // Added 0 extension to operands\n\tassign s = sum[7:0];\n\tassign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [8:0] sum = a+b; // No change\n\tassign s = {sum[6:0], 1'b0}; // Changed output to shift right with LSB as 0\n\tassign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [8:0] sum = a&b; // Changed operator to &\n\tassign s = sum[7:0];\n\tassign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [8:0] sum = a|b; // Changed operator to |\n\tassign s = sum[7:0];\n\tassign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [8:0] sum = a+b; // No change\n\tassign s = ~sum[7:0]; // Inverted the sum bits\n\tassign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\t\nendmodule\n"]}
{"task_id": "review2015_fsmonehot", "mutants": ["module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B1]; // Mutation: Changed from state[B2] to state[B1]\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&~ack; // Mutation: Changed ack to ~ack\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n\tassign S1_next = state[S]&~d; // Mutation: Changed d to ~d\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&done_counting; // Mutation: Changed ~done_counting to done_counting\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&ack; // Mutation: Changed ~ack to ack\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&d | state[S1]&~d | state[S110]&~d | state[Wait]&ack; // Mutation: Changed state[S]&~d to state[S]&d\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&d | state[Wait]&ack; // Mutation: Changed state[S110]&~d to state[S110]&d\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&~done_counting | state[Wait]&~ack; // Mutation: Changed done_counting to ~done_counting in Wait_next\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&d | state[S110]&~d | state[Wait]&ack; // Mutation: Changed state[S1]&~d to state[S1]&d\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&done_counting; // Mutation: Changed ~done_counting to done_counting, same as mutant 4 but in a different position\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n"]}
{"task_id": "always_casez", "mutants": ["module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 2'h0; // No change\n\t\t\t8'bzzzzzzz1: pos = 3'h0; // No change\n\t\t\t8'bzzzzzz1z: pos = 3'h1; // No change\n\t\t\t8'bzzzzz1zz: pos = 3'h2; // No change\n\t\t\t8'bzzzz1zzz: pos = 3'h3; // No change\n\t\t\t8'bzzz1zzzz: pos = 3'h4; // No change\n\t\t\t8'bzz1zzzzz: pos = 3'h5; // No change\n\t\t\t8'bz1zzzzzz: pos = 3'h6; // No change\n\t\t\t8'b1zzzzzzz: pos = 3'h6; // Changed pos = 3'h7 to pos = 3'h6\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 2'h1; // Changed default case to pos = 2'h1\n\t\t\t8'bzzzzzzz1: pos = 3'h0; // No change\n\t\t\t8'bzzzzzz1z: pos = 3'h1; // No change\n\t\t\t8'bzzzzz1zz: pos = 3'h2; // No change\n\t\t\t8'bzzzz1zzz: pos = 3'h3; // No change\n\t\t\t8'bzzz1zzzz: pos = 3'h4; // No change\n\t\t\t8'bzz1zzzzz: pos = 3'h5; // No change\n\t\t\t8'bz1zzzzzz: pos = 3'h6; // No change\n\t\t\t8'b1zzzzzzz: pos = 3'h7; // No change\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 2'h0; // No change\n\t\t\t8'bzzzzzzz1: pos = 3'h0; // No change\n\t\t\t8'bzzzzzz1z: pos = 3'h1; // No change\n\t\t\t8'bzzzzz1zz: pos = 3'h1; // Changed pos = 3'h2 to pos = 3'h1\n\t\t\t8'bzzzz1zzz: pos = 3'h3; // No change\n\t\t\t8'bzzz1zzzz: pos = 3'h4; // No change\n\t\t\t8'bzz1zzzzz: pos = 3'h5; // No change\n\t\t\t8'bz1zzzzzz: pos = 3'h6; // No change\n\t\t\t8'b1zzzzzzz: pos = 3'h7; // No change\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 2'h0; // No change\n\t\t\t8'bzzzzzzz1: pos = 3'h0; // No change\n\t\t\t8'bzzzzzz1z: pos = 3'h1; // No change\n\t\t\t8'bzzzzz1zz: pos = 3'h2; // No change\n\t\t\t8'bzzzz1zzz: pos = 3'h2; // Changed pos = 3'h3 to pos = 3'h2\n\t\t\t8'bzzz1zzzz: pos = 3'h4; // No change\n\t\t\t8'bzz1zzzzz: pos = 3'h5; // No change\n\t\t\t8'bz1zzzzzz: pos = 3'h6; // No change\n\t\t\t8'b1zzzzzzz: pos = 3'h7; // No change\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 2'h0; // No change\n\t\t\t8'bzzzzzzz1: pos = 3'h1; // Changed pos = 3'h0 to pos = 3'h1\n\t\t\t8'bzzzzzz1z: pos = 3'h1; // No change\n\t\t\t8'bzzzzz1zz: pos = 3'h2; // No change\n\t\t\t8'bzzzz1zzz: pos = 3'h3; // No change\n\t\t\t8'bzzz1zzzz: pos = 3'h4; // No change\n\t\t\t8'bzz1zzzzz: pos = 3'h5; // No change\n\t\t\t8'bz1zzzzzz: pos = 3'h6; // No change\n\t\t\t8'b1zzzzzzz: pos = 3'h7; // No change\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 2'h0; // No change\n\t\t\t8'bzzzzzzz1: pos = 3'h0; // No change\n\t\t\t8'bzzzzzz1z: pos = 3'h0; // Changed pos = 3'h1 to pos = 3'h0\n\t\t\t8'bzzzzz1zz: pos = 3'h2; // No change\n\t\t\t8'bzzzz1zzz: pos = 3'h3; // No change\n\t\t\t8'bzzz1zzzz: pos = 3'h4; // No change\n\t\t\t8'bzz1zzzzz: pos = 3'h5; // No change\n\t\t\t8'bz1zzzzzz: pos = 3'h6; // No change\n\t\t\t8'b1zzzzzzz: pos = 3'h7; // No change\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 2'h0; // No change\n\t\t\t8'bzzzzzzz1: pos = 3'h0; // No change\n\t\t\t8'bzzzzzz1z: pos = 3'h1; // No change\n\t\t\t8'bzzzzz1zz: pos = 3'h2; // No change\n\t\t\t8'bzzzz1zzz: pos = 3'h3; // No change\n\t\t\t8'bzzz1zzzz: pos = 3'h5; // Changed pos = 3'h4 to pos = 3'h5\n\t\t\t8'bzz1zzzzz: pos = 3'h5; // No change\n\t\t\t8'bz1zzzzzz: pos = 3'h6; // No change\n\t\t\t8'b1zzzzzzz: pos = 3'h7; // No change\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 2'h0; // No change\n\t\t\t8'bzzzzzzz1: pos = 3'h0; // No change\n\t\t\t8'bzzzzzz1z: pos = 3'h1; // No change\n\t\t\t8'bzzzzz1zz: pos = 3'h2; // No change\n\t\t\t8'bzzzz1zzz: pos = 3'h3; // No change\n\t\t\t8'bzzz1zzzz: pos = 3'h4; // No change\n\t\t\t8'bzz1zzzzz: pos = 3'h4; // Changed pos = 3'h5 to pos = 3'h4\n\t\t\t8'bz1zzzzzz: pos = 3'h6; // No change\n\t\t\t8'b1zzzzzzz: pos = 3'h7; // No change\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 2'h0; // No change\n\t\t\t8'bzzzzzzz1: pos = 3'h0; // No change\n\t\t\t8'bzzzzzz1z: pos = 3'h1; // No change\n\t\t\t8'bzzzzz1zz: pos = 3'h2; // No change\n\t\t\t8'bzzzz1zzz: pos = 3'h3; // No change\n\t\t\t8'bzzz1zzzz: pos = 3'h4; // No change\n\t\t\t8'bzz1zzzzz: pos = 3'h5; // No change\n\t\t\t8'bz1zzzzzz: pos = 3'h7; // Changed pos = 3'h6 to pos = 3'h7\n\t\t\t8'b1zzzzzzz: pos = 3'h7; // No change\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 3'h7; // Changed default to pos = 3'h7\n\t\t\t8'bzzzzzzz1: pos = 3'h0; // No change\n\t\t\t8'bzzzzzz1z: pos = 3'h1; // No change\n\t\t\t8'bzzzzz1zz: pos = 3'h2; // No change\n\t\t\t8'bzzzz1zzz: pos = 3'h3; // No change\n\t\t\t8'bzzz1zzzz: pos = 3'h4; // No change\n\t\t\t8'bzz1zzzzz: pos = 3'h5; // No change\n\t\t\t8'bz1zzzzzz: pos = 3'h6; // No change\n\t\t\t8'b1zzzzzzz: pos = 3'h7; // No change\n\t\tendcase\n\tend\n\t\nendmodule\n"]}
{"task_id": "wire_decl", "mutants": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n\twire w1, w2;\n\tassign w1 = a&b;\n\tassign w2 = c&d;\n\tassign out = w1|w2;\n\tassign out_n = ~out; // Change: No change, serves as a baseline for comparison.\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n\twire w1, w2;\n\tassign w1 = a|b; // Changed & to | in this line for wire w1.\n\tassign w2 = c&d;\n\tassign out = w1|w2;\n\tassign out_n = ~out;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n\twire w1, w2;\n\tassign w1 = a&b;\n\tassign w2 = c|d; // Changed & to | in this line for wire w2.\n\tassign out = w1|w2;\n\tassign out_n = ~out;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n\twire w1, w2;\n\tassign w1 = a&b;\n\tassign w2 = c&d;\n\tassign out = w1&w2; // Changed | to & in this line for output out.\n\tassign out_n = ~out;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n\twire w1, w2;\n\tassign w1 = a&b;\n\tassign w2 = c&d;\n\tassign out = w1|w2;\n\tassign out_n = out; // Changed ~out to out, inverting the functionality for out_n.\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n\twire w1, w2;\n\tassign w1 = ~(a&b); // Added NOT operation to w1.\n\tassign w2 = c&d;\n\tassign out = w1|w2;\n\tassign out_n = ~out;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n\twire w1, w2;\n\tassign w1 = a&b;\n\tassign w2 = ~(c&d); // Added NOT operation to w2.\n\tassign out = w1|w2;\n\tassign out_n = ~out;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n\twire w1, w2;\n\tassign w1 = a^b; // Changed & to ^ (XOR) for wire w1.\n\tassign w2 = c&d;\n\tassign out = w1|w2;\n\tassign out_n = ~out;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n\twire w1, w2;\n\tassign w1 = a&b;\n\tassign w2 = c^d; // Changed & to ^ (XOR) for wire w2.\n\tassign out = w1|w2;\n\tassign out_n = ~out;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\n\twire w1, w2;\n\tassign w1 = a&!b; // Added NOT operation to b for wire w1.\n\tassign w2 = c&d;\n\tassign out = w1|w2;\n\tassign out_n = ~out;\n\t\nendmodule\n"]}
{"task_id": "thermostat", "mutants": ["module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\t\n\tassign fan = (mode ? too_cold : too_hot) | fan_on; // No change\n\tassign heater = (mode & too_cold); // No change\n\tassign aircon = (~mode & too_hot); // No change\n\tassign heater = (~mode & too_cold); // Change: added incorrect heater control logic for cooling mode\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign fan = (mode ? too_cold : too_hot); // Change: Removed | fan_on, so fan control doesn't include manual fan on\n    assign heater = (mode & too_cold);\n    assign aircon = (~mode & too_hot);\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign fan = (mode ? too_cold : too_hot) | fan_on; \n    assign heater = (mode | too_cold); // Change: Used OR instead of AND for heater control logic\n    assign aircon = (~mode & too_hot);\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign fan = fan_on; // Change: Only fan_on controls the fan, ignoring heating or cooling\n    assign heater = (mode & too_cold);\n    assign aircon = (~mode & too_hot);\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign fan = (mode ? too_cold : too_hot) | fan_on;\n    assign heater = (mode & too_cold);\n    assign aircon = (~mode | too_hot); // Change: Used OR instead of AND for aircon control logic\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign fan = (mode ? too_hot : too_cold) | fan_on; // Change: Swapped conditions for too_hot and too_cold\n    assign heater = (mode & too_cold);\n    assign aircon = (~mode & too_hot);\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign fan = (mode & too_cold) | (mode & too_hot) | fan_on; // Change: Added too_hot to fan condition erroneously\n    assign heater = (mode & too_cold);\n    assign aircon = (~mode & too_hot);\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign fan = (mode ? too_cold : too_hot) & fan_on; // Change: Used AND instead of OR with fan_on\n    assign heater = (mode & too_cold);\n    assign aircon = (~mode & too_hot);\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign fan = (mode ? too_cold : too_hot) | fan_on;\n    // Change: Added redundant condition for heater and aircon, simulating a bug\n    assign heater = (mode & too_cold) | (mode & too_hot);\n    assign aircon = (~mode & too_hot) | (~mode & too_cold);\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign fan = (mode ? too_cold : too_hot) | fan_on;\n    assign heater = mode; // Change: Incorrectly assigns mode directly to heater, ignoring too_cold\n    assign aircon = ~mode; // Change: Incorrectly assigns inverted mode directly to aircon, ignoring too_hot\nendmodule\n"]}
{"task_id": "ece241_2013_q2", "mutants": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\tassign out_sop = c&d | ~a&~b&c; // No change\n\tassign pos0 = c & (~b|d)&(~a|b); // No change\n\tassign pos1 = c & (~b|d)&(~a|d); // No change\n\t\n\t// Change: Changed the unknown condition to 0 instead of x\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'b0; \nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\t// Change: Altered the expression slightly to include b in the SOP\n\tassign out_sop = c&d | ~a&~b&c | b&c; \n\tassign pos0 = c & (~b|d)&(~a|b); // No change\n\tassign pos1 = c & (~b|d)&(~a|d); // No change\n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\tassign out_sop = c&d | ~a&~b&c; // No change\n\t// Change: Removed the condition involving d in pos0\n\tassign pos0 = c & (~b)&(~a|b); \n\tassign pos1 = c & (~b|d)&(~a|d); // No change\n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\tassign out_sop = c&d | ~a&~b&c; // No change\n\tassign pos0 = c & (~b|d)&(~a|b); // No change\n\t// Change: Removed the condition involving b in pos1\n\tassign pos1 = c & (~b|d)&(~a); \n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\t// Change: Simplified the SOP expression\n\tassign out_sop = c; \n\tassign pos0 = c & (~b|d)&(~a|b); // No change\n\tassign pos1 = c & (~b|d)&(~a|d); // No change\n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\tassign out_sop = c&d | ~a&~b&c; // No change\n\t// Change: Inverted the condition for pos0\n\tassign pos0 = c & (b|~d)&(a|~b); \n\tassign pos1 = c & (~b|d)&(~a|d); // No change\n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\t// Change: Added d in the SOP condition\n\tassign out_sop = c&d | ~a&~b&c&d; \n\tassign pos0 = c & (~b|d)&(~a|b); // No change\n\tassign pos1 = c & (~b|d)&(~a|d); // No change\n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\tassign out_sop = c&d | ~a&~b&c; // No change\n\t// Change: Switched the conditions involving a and b in pos0\n\tassign pos0 = c & (~a|d)&(~b|b); \n\tassign pos1 = c & (~b|d)&(~a|d); // No change\n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\tassign out_sop = c&d | ~a&~b&c; // No change\n\t// Change: Added an extra condition to pos1 to make it false\n\tassign pos0 = c & (~b|d)&(~a|b); // No change\n\tassign pos1 = c & (~b|d)&(~a|d)&~c; \n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\t// Change: Altered SOP to not include c&d\n\tassign out_sop = ~a&~b&c; \n\tassign pos0 = c & (~b|d)&(~a|b); // No change\n\tassign pos1 = c & (~b|d)&(~a|d); // No change\n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n"]}
{"task_id": "circuit3", "mutants": ["module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (a&b) & (c|d); // Changed | to & for (a|b)\n\t\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (a|b) & (c&d); // Changed | to & for (c|d)\n\t\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (a|b) | (c|d); // Changed & to | between (a|b) and (c|d)\n\t\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (a^b) & (c|d); // Changed | to ^ for (a|b)\n\t\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = !(a|b) & (c|d); // Added ! to (a|b)\n\t\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (a|b) & !(c|d); // Added ! to (c|d)\n\t\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (a & b) | (c|d); // Changed | to & for (a|b) and then & to | between (a&b) and (c|d)\n\t\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (a|!b) & (c|d); // Added ! to b in (a|b)\n\t\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (a|b) & (c|!d); // Added ! to d in (c|d)\n\t\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ((a|b) & (c|d)) | a; // Added \"| a\" at the end\n\t\nendmodule\n"]}
{"task_id": "7420", "mutants": ["module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~|( {p1a, p1b, p1c, p1d} ); // Changed & to | for p1y\n    assign p2y = ~&( {p2a, p2b, p2c, p2d} );\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~&( {p1a, p1b, p1c, p1d} );\n    assign p2y = ~|( {p2a, p2b, p2c, p2d} ); // Changed & to | for p2y\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~&( {p1a, p1b, p1c, ~p1d} ); // Inverted p1d\n    assign p2y = ~&( {p2a, p2b, p2c, p2d} );\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~&( {p1a, p1b, p1c, p1d} );\n    assign p2y = ~&( {p2a, p2b, p2c, ~p2d} ); // Inverted p2d\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~&( {p1a, p1c, p1b, p1d} ); // Swapped p1b and p1c\n    assign p2y = ~&( {p2a, p2b, p2c, p2d} );\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~&( {p1a, p1b, p1c, p1d} );\n    assign p2y = ~&( {p2a, p2c, p2b, p2d} ); // Swapped p2b and p2c\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~&( {p1a, p1b, p1c} ); // Removed p1d from the grouping\n    assign p2y = ~&( {p2a, p2b, p2c, p2d} );\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~&( {p1a, p1b, p1c, p1d} );\n    assign p2y = ~&( {p2a, p2b, p2c} ); // Removed p2d from the grouping\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~&( {p1d, p1a, p1b, p1c} ); // Rotated left the inputs for p1y\n    assign p2y = ~&( {p2a, p2b, p2c, p2d} );\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~&( {p1a, p1b, p1c, p1d} );\n    assign p2y = ~&( {p2d, p2a, p2b, p2c} ); // Rotated left the inputs for p2y\n\nendmodule\n"]}
{"task_id": "popcount255", "mutants": ["module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 0;\n\t\tfor (int i=0;i<254;i++) // Changed loop condition i<255 to i<254, reducing loop count by 1\n\t\t\tout = out + in[i];\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 1; // Changed initial value of out from 0 to 1\n\t\tfor (int i=0;i<255;i++)\n\t\t\tout = out + in[i];\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 0;\n\t\tfor (int i=0;i<255;i+=2) // Changed increment of i from i++ to i+=2, skipping every other bit\n\t\t\tout = out + in[i];\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 0;\n\t\tfor (int i=1;i<255;i++) // Changed starting index of loop from i=0 to i=1, skipping the first bit\n\t\t\tout = out + in[i];\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 0;\n\t\tfor (int i=0;i<255;i++)\n\t\t\tout = out - in[i]; // Changed addition to subtraction, which logically doesn't make sense for counting\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 0;\n\t\tfor (int i=0;i<255;i++)\n\t\t\tout = out + (in[i] && 1'b1); // Changed addition operand to bitwise AND with 1'b1\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 0;\n\t\tfor (int i=0;i<=254;i++) // Explicitly used i<=254 instead of i<255 for loop condition\n\t\t\tout = out + in[i];\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 0;\n\t\tfor (int i=0;i<255;i++)\n\t\t\tout = out + in[i] ^ 1'b0; // Added XOR with 1'b0 which doesn't change the logic\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 0;\n\t\tfor (int i=0;i<255;i++)\n\t\t\tout = out + (in[i] | 1'b0); // Added OR with 1'b0 which doesn't change the logic\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 0;\n\t\tfor (int i=255;i>0;i--) // Changed loop to count backwards, which logically will produce the same result but is a minor modification\n\t\t\tout = out + in[i-1];\n\tend\n\t\nendmodule\n"]}
{"task_id": "gatesv", "mutants": ["module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = in[2:0] | in[3:1];\n\tassign out_different = in^{in[3], in[3:1]}; // Changed in[0] to in[3] in the XOR operation for out_different.\n\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] | in[3:1]; // Changed & to | for out_both calculation.\n\tassign out_any = in[2:0] | in[3:1];\n\tassign out_different = in^{in[0], in[3:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = in[2:0] & in[3:1]; // Changed | to & for out_any calculation.\n\tassign out_different = in^{in[0], in[3:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = in[2:0] | in[3:1];\n\tassign out_different = in[3:0] ^{in[0], in[3:1]}; // Added [3:0] to explicitly specify the bit selection for in in out_different calculation.\n\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = {1'b0, in[2:0] & in[3:1]}; // Prepended 1'b0 to out_both to change its calculation.\n\tassign out_any = in[2:0] | in[3:1];\n\tassign out_different = in^{in[0], in[3:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = in[2:0] | in[3:1];\n\tassign out_different = {in[0], in[3:1]} ^ in; // Swapped the order of operands in the XOR for out_different.\n\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = ~in[2:0] | in[3:1]; // Applied bitwise NOT to in[2:0] in the out_any calculation.\n\tassign out_different = in^{in[0], in[3:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = in[2:0] | ~in[3:1]; // Applied bitwise NOT to in[3:1] in the out_any calculation.\n\tassign out_different = in^{in[0], in[3:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = (in[2:0] & in[3:1]) ^ 4'b0001; // Applied XOR with 4'b0001 to out_both calculation.\n\tassign out_any = in[2:0] | in[3:1];\n\tassign out_different = in^{in[0], in[3:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = in[2:0] | in[3:1];\n\tassign out_different = in^{in[1], in[3:1]}; // Changed in[0] to in[1] in the XOR operation for out_different.\n\nendmodule\n"]}
{"task_id": "circuit6", "mutants": ["module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4658; // No change\n\t\t\t1: q = 44768; // No change\n\t\t\t2: q = 10196; // No change\n\t\t\t3: q = 23055; // Changed 23054 to 23055\n\t\t\t4: q = 8294; // No change\n\t\t\t5: q = 25806; // No change\n\t\t\t6: q = 50470; // No change\n\t\t\t7: q = 12057; // No change\n\t\tendcase\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4659; // Changed 4658 to 4659\n\t\t\t1: q = 44768; // No change\n\t\t\t2: q = 10196; // No change\n\t\t\t3: q = 23054; // No change\n\t\t\t4: q = 8294; // No change\n\t\t\t5: q = 25806; // No change\n\t\t\t6: q = 50470; // No change\n\t\t\t7: q = 12057; // No change\n\t\tendcase\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4658; // No change\n\t\t\t1: q = 44768; // No change\n\t\t\t2: q = 10197; // Changed 10196 to 10197\n\t\t\t3: q = 23054; // No change\n\t\t\t4: q = 8294; // No change\n\t\t\t5: q = 25806; // No change\n\t\t\t6: q = 50470; // No change\n\t\t\t7: q = 12057; // No change\n\t\tendcase\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4658; // No change\n\t\t\t1: q = 44769; // Changed 44768 to 44769\n\t\t\t2: q = 10196; // No change\n\t\t\t3: q = 23054; // No change\n\t\t\t4: q = 8294; // No change\n\t\t\t5: q = 25806; // No change\n\t\t\t6: q = 50470; // No change\n\t\t\t7: q = 12057; // No change\n\t\tendcase\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4658; // No change\n\t\t\t1: q = 44768; // No change\n\t\t\t2: q = 10196; // No change\n\t\t\t3: q = 23054; // No change\n\t\t\t4: q = 8295; // Changed 8294 to 8295\n\t\t\t5: q = 25806; // No change\n\t\t\t6: q = 50470; // No change\n\t\t\t7: q = 12057; // No change\n\t\tendcase\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4658; // No change\n\t\t\t1: q = 44768; // No change\n\t\t\t2: q = 10196; // No change\n\t\t\t3: q = 23054; // No change\n\t\t\t4: q = 8294; // No change\n\t\t\t5: q = 25807; // Changed 25806 to 25807\n\t\t\t6: q = 50470; // No change\n\t\t\t7: q = 12057; // No change\n\t\tendcase\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4658; // No change\n\t\t\t1: q = 44768; // No change\n\t\t\t2: q = 10196; // No change\n\t\t\t3: q = 23054; // No change\n\t\t\t4: q = 8294; // No change\n\t\t\t5: q = 25806; // No change\n\t\t\t6: q = 50471; // Changed 50470 to 50471\n\t\t\t7: q = 12057; // No change\n\t\tendcase\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4657; // Changed 4658 to 4657\n\t\t\t1: q = 44768; // No change\n\t\t\t2: q = 10196; // No change\n\t\t\t3: q = 23054; // No change\n\t\t\t4: q = 8294; // No change\n\t\t\t5: q = 25806; // No change\n\t\t\t6: q = 50470; // No change\n\t\t\t7: q = 12057; // No change\n\t\tendcase\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4658; // No change\n\t\t\t1: q = 44768; // No change\n\t\t\t2: q = 10196; // No change\n\t\t\t3: q = 23054; // No change\n\t\t\t4: q = 8294; // No change\n\t\t\t5: q = 25806; // No change\n\t\t\t6: q = 50470; // No change\n\t\t\t7: q = 12058; // Changed 12057 to 12058\n\t\tendcase\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4660; // Changed 4658 to 4660\n\t\t\t1: q = 44768; // No change\n\t\t\t2: q = 10196; // No change\n\t\t\t3: q = 23054; // No change\n\t\t\t4: q = 8294; // No change\n\t\t\t5: q = 25806; // No change\n\t\t\t6: q = 50470; // No change\n\t\t\t7: q = 12057; // No change\n\t\tendcase\n\t\nendmodule\n"]}
{"task_id": "m2014_q4f", "mutants": ["module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = in1 & in2; // Changed ~in2 to in2, removing the inversion\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = in1 | ~in2; // Changed & to | for OR operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = in1 ^ ~in2; // Changed & to ^ for XOR operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = in1 ~& in2; // Changed & to ~&, NAND operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = (in1 & ~in2) == 1'b0; // Added equality check to 0\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~in1 & ~in2; // Changed in1 to ~in1, inverting it\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = in1 & ~in2 & in1; // Added an extra in1 at the end, redundant logic\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = in1 & (~in2 | in2); // Added OR operation with in2 and its inverse\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = (in1 & ~in2) != 1'b1; // Added inequality check to 1\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = (in1 | ~in2) & in1; // Changed initial AND to OR, then AND with in1\nendmodule\n"]}
{"task_id": "xnorgate", "mutants": ["module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~(a^b); // Change: None, this is the original for reference.\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = (a^b); // Change: Removed the NOT operation, making it an XOR instead of XNOR.\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~(a|b); // Change: Replaced XOR with OR, then NOTed it.\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~(a&b); // Change: Replaced XOR with AND, then NOTed it.\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~(a^~b); // Change: Inverted input b before XOR, altering the gate's logic.\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~(~a^b); // Change: Inverted input a before XOR, altering the gate's logic.\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~a^b; // Change: Inverted input a then directly XOR with b, without NOTing the result.\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = a^~b; // Change: Inverted input b then directly XOR with a, without NOTing the result.\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = a^b; // Change: Directly XOR without NOTing it, similar to mutant 2 but restated for emphasis on direct XOR operation.\n\t\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~(a^b^1); // Change: Added an XOR with 1 (logical negation) to the original expression, altering the logic.\n\t\nendmodule\n"]}
{"task_id": "mt2015_q4", "mutants": ["module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = x & ~y; // Changed | to &\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~x | ~y; // Added ~ before x\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = x | y; // Removed ~ before y\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = x ^ ~y; // Changed | to ^\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x | ~y) & x; // Added & x at the end of the expression\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x | ~y) | x; // Added | x at the end of the expression\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = x | (~y & x); // Added & x inside the parentheses with ~y\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = x | (~y | x); // Changed & to | inside the parentheses with ~y\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x | ~y) ^ y; // Added ^ y at the end of the expression\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x | ~y) ~^ x; // Changed ^ to ~^ at the end of the expression\n\t\nendmodule\n"]}
{"task_id": "fsm_onehot", "mutants": ["module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[9]; // Unchanged\n\n\tassign next_state[0] = !in && (|state[4:1] | state[7] | state[8] | state[9]); // Changed |state[4:0] to |state[4:1]\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[8]; // Changed state[9] to state[8]\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[9];\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8]); // Removed state[9] from the equation\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[9];\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8]); // Removed state[9] from the equation\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[9];\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = !in && state[3]; // Changed in to !in\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[9];\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = !in && state[5]; // Changed in to !in\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[6] | state[9]; // Changed state[7] to state[6]\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[7] | state[9]; // Changed state[8] to state[7]\n\tassign out2 = state[7] | state[9];\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[9];\n\n\tassign next_state[0] = !in && (|state[3:0] | state[7] | state[8] | state[9]); // Changed |state[4:0] to |state[3:0]\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9]; // Unchanged\n\tassign out2 = state[7] | !state[9]; // Changed state[9] to !state[9]\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\nendmodule\n"]}
{"task_id": "popcount3", "mutants": ["module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = in[0]+in[1]+in[2] + 1; // Added 1 to the output sum\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = in[0]+in[1]; // Removed in[2] from the sum\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [2:0] out // Changed output bit width to 3\n);\n\n    assign out = in[0]+in[1]+in[2];\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = in[0] ^ in[1] ^ in[2]; // Changed addition to XOR\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output reg [1:0] out // Changed output to reg and used always block\n);\n\n    always @(in) begin\n        out = in[0] + in[1] + in[2];\n    end\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = in[0] | in[1] | in[2]; // Changed addition to OR\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = {in[2], in[0] + in[1]}; // Changed the output composition\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = (in[0] + in[1] + in[2]) - 1; // Subtracted 1 from the output sum\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = in[0] & in[1] & in[2]; // Changed addition to AND\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = in[0]+in[1]+~in[2]; // Inverted in[2] before addition\nendmodule\n"]}
{"task_id": "vector5", "mutants": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {4{e}} } ^ {5{a,b,c,d,e}}; // Changed {5{e}} to {4{e}}, decreasing the replication of 'e' by 1\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {4{a,b,c,d,e}}; // Changed {5{a,b,c,d,e}} to {4{a,b,c,d,e}}, decreasing the replication in the XOR operation by 1\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {4{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}}; // Changed {5{a}} to {4{a}}, decreasing the replication of 'a' by 1\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {5{b}}, {5{c}}, {4{d}}, {5{e}} } ^ {5{a,b,c,d,e}}; // Changed {5{d}} to {4{d}}, decreasing the replication of 'd' by 1\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out[24:1] = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} }[24:1] ^ {5{a,b,c,d,e}}[24:1]; // Removed the last comparison, out[0] will not be assigned\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {6{e}} } ^ {5{a,b,c,d,e}}; // Changed {5{e}} to {6{e}}, increasing the replication of 'e' by 1\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {5{b}}, {4{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}}; // Changed {5{c}} to {4{c}}, decreasing the replication of 'c' by 1\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {6{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}}; // Changed {5{a}} to {6{a}}, increasing the replication of 'a' by 1\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {6{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}}; // Changed {5{b}} to {6{b}}, increasing the replication of 'b' by 1\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}, 1'b0}; // Added a 1'b0 to the end of the vector in the XOR operation\n\nendmodule\n"]}
{"task_id": "circuit1", "mutants": ["module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = a|b; // Changed & to |, altering the logic function\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = a&b; // No change, for baseline comparison\n\tassign q = ~q; // Added inversion of q, inverting the output\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = a^b; // Changed & to ^, making it an XOR operation\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = (a&b)&a; // Added an extra &a, redundantly & with a\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = (a|b)&b; // Changed & to | then & with b, altering the operation\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = a&~b; // Added inversion to b\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = ~a&b; // Added inversion to a\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = (a|~b); // Changed & to | and inverted b\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = (a^~b); // Changed & to ^ and inverted b, making it a negative XOR\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = (a&b)|a; // Added |a at the end, altering the boolean function\nendmodule\n"]}
{"task_id": "2014_q3c", "mutants": ["module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1; // Change: No modification, serves as a baseline.\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx; // Change: was 1'bx, no actual change, just annotating baseline.\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 0; // Change: was Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bz; // Change: was 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 1; // Change: was Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 0; // Change: was Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 1; // Change: was Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 1; // Change: was Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 1; // Change: was Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 0; // Change: was Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 0; // Change: was 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n"]}
{"task_id": "wire4", "mutants": ["module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n    \n    assign {w,x,y,z} = {a,b,c,b}; // Changed the order in the assignment to {a,b,c,b}\n    \nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n    \n    assign {w,x,y,z} = {b,a,b,c}; // Changed the mapping from {a,b,b,c} to {b,a,b,c}\n    \nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n    \n    assign {w,x,z,y} = {a,b,b,c}; // Changed the output order to {w,x,z,y}\n    \nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n    \n    assign {x,w,y,z} = {a,b,b,c}; // Changed the output order to {x,w,y,z}\n    \nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n    \n    assign {w,x,y,z} = {a,a,b,c}; // Changed second input from 'b' to 'a' in assignment\n    \nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n    \n    assign {w,x,y,z} = {1'b0,b,b,c}; // Fixed 'w' to 0 instead of mapping it to 'a'\n    \nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n    \n    assign {w,x,y,z} = {a,b,!b,c}; // Changed 'y' mapping from 'b' to '!b' (inverted 'b')\n    \nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n    \n    assign {w,x,y,z} = {a,b,b,~c}; // Inverted 'c' before assigning to 'z'\n    \nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n    \n    assign {w,x,y,z} = {a,{1'b1},b,c}; // Inserted constant '1' before 'b', this will cause a syntax error, demonstrating a mutation that introduces a bug.\n    \nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z  );\n    \n    assign {w,x,y,z} = {a,b,b,c,1'b1}; // Added an extra 1'b1 at the end, which will cause mismatch in assignment\n    \nendmodule\n"]}
{"task_id": "always_case", "mutants": ["module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t// Changed output for case 3'h5 to be data4 instead of data5\n\t\t\t3'h5: out = data4; // Mutation: output data4 instead of data5\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\t// Changed default output to 4'b1 instead of 4'b0\n\t\t\tdefault: out = 4'b1; // Mutation: default output to 4'b1\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t// Removed the case for 3'h3\n\t\t\t// 3'h3: out = data3; // Mutation: Removed case for 3'h3\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\t// Added an extra case, does nothing but changes the flow\n\t\t\t3'h6: out = out; // Mutation: Added redundant case\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t// Changed the output of case 3'h0 to be data1 instead of data0\n\t\t\t3'h0: out = data1; // Mutation: output data1 instead of data0\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\t// Default behavior changed to output data0 instead of 4'b0\n\t\t\tdefault: out = data0; // Mutation: default to output data0\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t// Swapped the assignments of data4 and data5\n\t\t\t3'h4: out = data5; // Mutation: swap data4 and data5\n\t\t\t3'h5: out = data4;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\t// Added an unrelated modification, changed case notation\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n// Note: This mutant does not introduce a functional change but might confuse regarding the intended mutation.\n", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\t// Introduced a syntax error (missing semicolon) as a minor change\n\t\t\tdefault: out = 4'b0 // Mutation: Missing semicolon\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\t// Added a new case that is unlikely to be true, affecting the flow slightly\n\t\t\t3'h7: out = 4'b1111; // Mutation: Added unrealistic case\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n"]}
{"task_id": "bugs_addsubz", "mutants": ["module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b - 1; // Changed: Subtracted 1 from the subtraction operation\n\t\tendcase\n\t\tresult_is_zero = (out == 0);\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b + 1; // Changed: Added 1 to the addition operation\n\t\t\t1: out = a - b;\n\t\tendcase\n\t\tresult_is_zero = (out == 0);\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b;\n\t\tendcase\n\t\tresult_is_zero = (out == 8'h00); // Changed: Used hexadecimal for comparison\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t// Removed case 1 entirely, altering behavior for subtraction\n\t\tendcase\n\t\tresult_is_zero = (out == 0);\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b;\n\t\tendcase\n\t\tresult_is_zero = (out == 0) ? 0 : 1; // Changed: Inverted logic of result_is_zero\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a;\n\t\t\t1: out = b; // Changed: Directly assign `a` or `b` to `out` instead of performing an operation\n\t\tendcase\n\t\tresult_is_zero = (out == 0);\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b;\n\t\tendcase\n\t\tresult_is_zero = !out; // Changed: Used logical NOT directly on `out` for result_is_zero calculation\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a | b; // Changed: Used bitwise OR instead of addition\n\t\t\t1: out = a & b; // Changed: Used bitwise AND instead of subtraction\n\t\tendcase\n\t\tresult_is_zero = (out == 0);\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b;\n\t\tendcase\n\t\tresult_is_zero = (out == 0) ^ 1; // Changed: Added XOR with 1 to invert result_is_zero calculation\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b >> 1; // Changed: Shifted the subtraction result to the right by 1\n\t\tendcase\n\t\tresult_is_zero = (out == 0);\n\tend\n\t\nendmodule\n"]}
{"task_id": "bugs_case", "mutants": ["module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\talways @(*) begin\n\t\tout = 0;  // No change here\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;  // No change\n\t\t\t8'h16: out = 1;  // No change\n\t\t\t8'h1e: out = 2;  // No change\n\t\t\t8'h26: out = 3;  // No change\n\t\t\t8'h25: out = 4;  // No change\n\t\t\t8'h2e: out = 5;  // No change\n\t\t\t8'h36: out = 6;  // No change\n\t\t\t8'h3d: out = 7;  // No change\n\t\t\t8'h3e: out = 8;  // No change\n\t\t\t8'h46: out = 10; // Changed output from 9 to 10\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 0; // Changed initial valid state to 0\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0; // No change here\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\talways @(*) begin\n\t\tout = 1; // Changed default output to 1\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 7; // Changed output for 8'h36 from 6 to 7\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 3; // Changed output for 8'h1e from 2 to 3\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 2; // Changed output for 8'h16 from 1 to 2\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 6; // Changed output for 8'h3d from 7 to 6\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 1; // Changed output for 8'h45 from 0 to 1\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 5; // Changed output for 8'h25 from 4 to 5\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 6; // Changed output for 8'h2e from 5 to 6\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n"]}
{"task_id": "vectorr", "mutants": ["module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t// Changed out[0] and out[1] positions\n\tassign {out[1],out[0],out[2],out[3],out[4],out[5],out[6],out[7]} = in;\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t// Changed connection for out[7] to be from in[0] directly\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = {in[7:1], in[0]};\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t// Added inversion to out[0]\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = ~{in[7]};\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t// Swapped out[2] and out[3]\n\tassign {out[0],out[1],out[3],out[2],out[4],out[5],out[6],out[7]} = in;\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t// Modified to reverse only the first 4 bits\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = {in[3:0], in[7:4]};\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t// Used bitwise AND with 1 on out[0], which does not change functionality but changes the expression\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in & 8'hFF;\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t// Added bitwise OR with 0, which is a no-operation but changes the code\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in | 8'h00;\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t// Inserted a redundant bitwise XOR with 0\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in ^ 8'h00;\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t// Swapped the positions of out[6] and out[7]\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[7],out[6]} = in;\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t// Changed out[4] to be always 0, altering functionality slightly\n\tassign {out[0],out[1],out[2],out[3],1'b0,out[5],out[6],out[7]} = in;\n\t\nendmodule\n"]}
{"task_id": "kmap3", "mutants": ["module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1; // Changed 1'bx to 1\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 1; // Changed 0 to 1\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 0; // Changed 1'bx to 0\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 1; // Changed 0 to 1\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 1; // Changed 0 to 1\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 0; // Changed 1 to 0\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 1; // Changed 0 to 1\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 0; // Changed 1 to 0\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 0; // Changed 1 to 0\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 0; // Changed 1'bx to 0\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n"]}
{"task_id": "always_if", "mutants": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a; // No change\n\talways @(*) out_always = (sel_b1 | sel_b2) ? b : a; // Changed & to | in always block\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & sel_b2) ? a : b; // Swapped a and b in assign statement\n\talways @(*) out_always = (sel_b1 & sel_b2) ? b : a; // No change\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 | sel_b2) ? b : a; // Changed & to | in assign statement\n\talways @(*) out_always = (sel_b1 & sel_b2) ? b : a; // No change\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a; // No change\n\talways @(*) out_always = (sel_b1 & !sel_b2) ? b : a; // Changed sel_b2 to !sel_b2 in always block\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & !sel_b2) ? b : a; // Changed sel_b2 to !sel_b2 in assign statement\n\talways @(*) out_always = (sel_b1 & sel_b2) ? b : a; // No change\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a; // No change\n\talways @(*) out_always = !(sel_b1 & sel_b2) ? b : a; // Added negation to condition in always block\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = !(sel_b1 & sel_b2) ? b : a; // Added negation to condition in assign statement\n\talways @(*) out_always = (sel_b1 & sel_b2) ? b : a; // No change\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a; // No change\n\talways @(*) out_always = (sel_b1 & sel_b2) ? a : b; // Swapped a and b in always block\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 ^ sel_b2) ? b : a; // Changed & to ^ in assign statement\n\talways @(*) out_always = (sel_b1 & sel_b2) ? b : a; // No change\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a; // No change\n\talways @(*) out_always = (sel_b1 ^ sel_b2) ? b : a; // Changed & to ^ in always block\n\t\nendmodule\n"]}
{"task_id": "kmap1", "mutants": ["module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (a & b | c); // Changed OR to AND between a and b\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (a | b & c); // Changed OR to AND between b and c\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = ~(a | b | c); // Added NOT operator at the beginning\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (a | b | ~c); // Added NOT operator to c\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (a ^ b | c); // Changed OR between a and b to XOR\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (a | b); // Removed c from the equation\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (a | c); // Removed b from the equation\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (b | c); // Removed a from the equation\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = ((a | b) & c); // Changed OR to AND after (a | b)\nendmodule\n", "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (!(a | b | c)); // Added an extra NOT operator, making it a double negative\nendmodule\n"]}
{"task_id": "mux2to1", "mutants": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = sel ? a : b; // Change: swapped a and b in the ternary operator.\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = sel ? b : !a; // Change: negated a.\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = !sel ? b : a; // Change: negated sel.\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = sel && b || !sel && a; // Change: converted ternary operation to logical operation.\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput reg out // Change: output changed from wire to reg.\n);\n\n\talways @(sel or a or b) begin\n\t\tout = sel ? b : a; // Used procedural assignment inside always block.\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\t// Change: Added redundant bitwise AND with 1'b1 to sel.\n\tassign out = (sel & 1'b1) ? b : a;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\t// Change: Added redundant bitwise OR with 1'b0 to both a and b.\n\tassign out = sel ? b | 1'b0 : a | 1'b0;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = sel ? (b ^ 1'b0) : (a ^ 1'b0); // Change: Added redundant XOR with 0 which has no effect.\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\t// Change: Directly use !sel for a and sel for b, logically equivalent to original but syntactically different.\n\tassign out = (!sel & a) | (sel & b);\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\t// Change: Implemented using a case statement, functionally same but structurally different.\n\talways @(*) begin\n\t\tcase(sel)\n\t\t\t1'b0: out = a;\n\t\t\t1'b1: out = b;\n\t\t\tdefault: out = 1'bx; // Added an undefined case handling even though it's unreachable with a 1-bit sel.\n\t\tendcase\n\tend\n\t\nendmodule\n"]}
{"task_id": "gates4", "mutants": ["module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in; // Unchanged\n\tassign out_or = |in[3:1]; // Changed: OR operation now uses bits [3:1] instead of [3:0]\n\tassign out_xor = ^in; // Unchanged\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in[3:1]; // Changed: AND operation now uses bits [3:1] instead of [3:0]\n\tassign out_or = |in; // Unchanged\n\tassign out_xor = ^in; // Unchanged\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in; // Unchanged\n\tassign out_or = |in; // Unchanged\n\tassign out_xor = ^in[3:1]; // Changed: XOR operation now uses bits [3:1] instead of [3:0]\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = in[0] & in[1] & in[2]; // Changed: AND operation explicitly defined for bits [2:0], excluding [3]\n\tassign out_or = |in; // Unchanged\n\tassign out_xor = ^in; // Unchanged\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in; // Unchanged\n\tassign out_or = in[3] | in[2] | in[1]; // Changed: OR operation explicitly defined for bits [3:1], excluding [0]\n\tassign out_xor = ^in; // Unchanged\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in; // Unchanged\n\tassign out_or = |in; // Unchanged\n\tassign out_xor = in[3] ^ in[2] ^ in[1]; // Changed: XOR operation explicitly defined for bits [3:1], excluding [0]\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &(in & 4'b1110); // Changed: AND operation with masked input, forcing bit 0 to 0\n\tassign out_or = |in; // Unchanged\n\tassign out_xor = ^in; // Unchanged\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in; // Unchanged\n\tassign out_or = |(in | 4'b0001); // Changed: OR operation with forced bit 0 to 1\n\tassign out_xor = ^in; // Unchanged\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in; // Unchanged\n\tassign out_or = |in; // Unchanged\n\tassign out_xor = ^in ^ 1'b1; // Changed: XOR operation result is inverted\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in; // Unchanged\n\tassign out_or = |in; // Unchanged\n\tassign out_xor = ^in ^ in[0]; // Changed: XOR operation with an additional XOR against in[0]\n\t\nendmodule\n"]}
{"task_id": "reduction", "mutants": ["module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in[7:1]; // Changed: Exclude the LSB from parity calculation\n\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in[7:0] ^ 1'b1; // Changed: Inverted the final parity bit\n\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\twire intermediate_parity;\n\tassign intermediate_parity = ^in; // Changed: Introduced an intermediate signal\n\tassign parity = intermediate_parity;\n\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput reg parity // Changed: Changed output from wire to reg\n);\n\n\talways @(*) begin\n\t\tparity = ^in;\n\tend\n\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in & 1'b1; // Changed: ANDed the result with 1, which does not change the logic but adds an operation\n\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in | 0; // Changed: ORed the result with 0, which does not change the logic but adds an operation\n\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6]; // Changed: Excluded in[7] from the calculation\n\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ~(^in); // Changed: Negated the entire expression, which changes the parity from even to odd\n\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\t// Changed: Used reduction NAND instead of XOR and then negated to keep even parity logic\n\tassign parity = ~(&in);\n\nendmodule\n", "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in ^ in[0]; // Changed: XORed the result with the LSB of the input, altering the parity calculation\n\nendmodule\n"]}
{"task_id": "fsm3comb", "mutants": ["module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A; // No change\n\t\t\tB: next_state = in ? C : C; // Change here, original: in ? B : C\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : D; // Change here, original: in ? D : A\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : B; // Change here, original: in ? B : A\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? D : C; // Change here, original: in ? B : C\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? C : A; // Change here, original: in ? D : A\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? A : A; // Change here, original: in ? B : A\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? A : C; // Change here, original: in ? B : C\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? C : C; // Change here, original: in ? B : C\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? A : B; // Change here, original: in ? B : A\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n", "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? C : A; // Change here, original: in ? B : A\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n"]}
{"task_id": "mt2015_q4b", "mutants": ["module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~(x^y); // No change in functionality, just formatting.\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x^y); // Change: Removed the NOT operation, altering functionality.\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~(x & y); // Change: Using AND instead of XOR, altering functionality significantly.\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~(x | y); // Change: Using OR instead of XOR, altering functionality.\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~(x^y) | y; // Change: Added OR with y, altering functionality.\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~((x^y) & x); // Change: Added AND with x, altering functionality.\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~(x^y) & x; // Change: Changed OR to AND with x, altering functionality.\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~(x^y) ^ x; // Change: Added XOR with x, altering functionality.\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~((x^y) | y); // Change: Added OR with y inside NOT, altering functionality.\n\t\nendmodule\n", "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~((x^y) ^ y); // Change: Added XOR with y inside NOT, altering functionality.\n\t\nendmodule\n"]}
{"task_id": "mt2015_eq2", "mutants": ["module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = A[1:0]!=B[1:0]; // Changed equality check to inequality\nendmodule\n", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = (A[1:0]==B[1:0])? 0 : 1; // Inverted the output using ternary operator\nendmodule\n", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput reg z); // Changed output type to reg\n\n\talways @(A or B) begin\n\t\tz = A == B; // Using procedural assignment inside always block\n\tend\nendmodule\n", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = A[1:0]==B[1:0] && A[0]; // Added an extra condition that checks A[0]\nendmodule\n", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = (A[1]==B[1]) && (A[0]==B[0]); // Explicitly comparing each bit\nendmodule\n", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = A[1:0]=={B[1], B[0]}; // Explicitly reconstructing B\nendmodule\n", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = A[1:0]<B[1:0]; // Changed equality check to less than\nendmodule\n", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = A[1:0]>B[1:0]; // Changed equality check to greater than\nendmodule\n", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = |(A[1:0]^B[1:0]); // XOR and then OR all bits for comparison\nendmodule\n", "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = &(A[1:0]~^B[1:0]); // XNOR and then AND all bits for comparison\nendmodule\n"]}
{"task_id": "gatesv100", "mutants": ["module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & {in[0], in[99:1]}; // Change: Used {in[0], in[99:1]} instead of in[99:1] for out_both, making the first bit dependent on in[0] and in[99]\n\tassign out_any = in | in[99:1];\n\tassign out_different = in ^ {in[0], in[99:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & in[99:1];\n\tassign out_any = in & in[99:1]; // Change: Used & instead of | for out_any, altering its functionality to require both bits to be '1'\n\tassign out_different = in ^ {in[0], in[99:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & in[99:1];\n\tassign out_any = in | in[99:1];\n\tassign out_different = in ~^ {in[0], in[99:1]}; // Change: Used ~^ for XOR, changing out_different to output when bits are the same.\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in | in[99:1]; // Change: Used | instead of & for out_both, changing its functionality to output '1' if either bit is '1'\n\tassign out_any = in | in[99:1];\n\tassign out_different = in ^ {in[0], in[99:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & in[99:1];\n\tassign out_any = in | {in[0], in[99:1]}; // Change: Used {in[0], in[99:1]} instead of in[99:1] for out_any, making the first bit dependent on in[0] and in[99]\n\tassign out_different = in ^ {in[0], in[99:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & in[99:1];\n\tassign out_any = in | in[99:1];\n\tassign out_different = in ^ in; // Change: Used in ^ in for out_different, resulting in all 0s because a bit XOR with itself is always 0.\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & {1'b0, in[99:1]}; // Change: Used {1'b0, in[99:1]} for out_both, explicitly setting the first bit to 0.\n\tassign out_any = in | in[99:1];\n\tassign out_different = in ^ {in[0], in[99:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & in[99:0]; // Change: Incorrectly used in[99:0], which is effectively the same as the original input vector and doesn't change the functionality.\n\tassign out_any = in | in[99:1];\n\tassign out_different = in ^ {in[0], in[99:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & in[99:1];\n\tassign out_any = in ^ in[99:1]; // Change: Used ^ instead of | for out_any, changing its functionality to indicate when bits are different.\n\tassign out_different = in ^ {in[0], in[99:1]};\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = ~in & in[99:1]; // Change: Used ~in instead of in for out_both, inverting the input bits before the AND operation.\n\tassign out_any = in | in[99:1];\n\tassign out_different = in ^ {in[0], in[99:1]};\n\t\nendmodule\n"]}
{"task_id": "mux256to1v", "mutants": ["module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = {in[sel*4+2], in[sel*4+2], in[sel*4+1], in[sel*4+0]}; // Changed in[sel*4+3] to in[sel*4+2]\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = {in[sel*4+3], in[sel*4+1], in[sel*4+1], in[sel*4+0]}; // Changed in[sel*4+2] to in[sel*4+1]\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = in[sel*4+:4]; // Used part-select instead of concatenation\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = {in[sel*4+0], in[sel*4+1], in[sel*4+2], in[sel*4+3]}; // Reversed the bit order\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = {in[sel*4+3:sel*4+1], in[sel*4]}; // Changed the concatenation to use a range and single bit\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = {in[sel*4+3], in[sel*4+2], in[sel*4+0], in[sel*4+0]}; // Changed one of the in[sel*4+1] to in[sel*4+0]\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = {in[sel*4+3], in[sel*4+1], in[sel*4+2], in[sel*4+0]}; // Swapped in[sel*4+1] and in[sel*4+2]\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = {in[sel*5+3], in[sel*5+2], in[sel*5+1], in[sel*5+0]}; // Changed multiplier from *4 to *5\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = {1'b0, in[sel*4+2], in[sel*4+1], in[sel*4+0]}; // Replaced in[sel*4+3] with constant 1'b0\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = {in[sel*4+3], in[sel*4+3], in[sel*4+1], in[sel*4+3]}; // Repeated in[sel*4+3] multiple times\n\nendmodule\n"]}
{"task_id": "mux9to1v", "mutants": ["module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '0; // Change: Initially set out to '0 instead of '1\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = g;\n\t\t\t4'h7: out = h;\n\t\t\t4'h8: out = i;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = g;\n\t\t\t4'h7: out = {8'h00, h[7:0]}; // Change: Output lower 8 bits of h\n\t\t\t4'h8: out = i;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = g;\n\t\t\t// 4'h7: out = h; // Change: Omitting case for sel=7, making it default to '1'\n\t\t\t4'h8: out = i;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = g;\n\t\t\t4'h7: out = h;\n\t\t\t4'h8: out = i;\n\t\t\t// Change: Adding an additional case, should not impact functionality as it's an unused case\n\t\t\t4'h9: out = '0; \n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = g;\n\t\t\t4'h7: out = h;\n\t\t\t4'h8: out = {i[7:0], i[15:8]}; // Change: Swap the bytes of i\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = {g[7:0], g[15:8]}; // Change: Swap the bytes of g\n\t\t\t4'h7: out = h;\n\t\t\t4'h8: out = i;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = {16{f[0]}}; // Change: Propagate the LSB of f across all bits of out\n\t\t\t4'h6: out = g;\n\t\t\t4'h7: out = h;\n\t\t\t4'h8: out = i;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = {a[14:0], a[15]}; // Change: Rotate the bits of a to the right\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = g;\n\t\t\t4'h7: out = h;\n\t\t\t4'h8: out = i;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = g;\n\t\t\t4'h7: out = h;\n\t\t\t4'h8: out = ~i; // Change: Invert all bits of i\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = g;\n\t\t\t4'h7: out = h;\n\t\t\t4'h8: out = i;\n\t\t\tdefault: out = 16'hFFFF; // Change: Explicitly define default case, technically redundant\n\t\tendcase\n\tend\n\t\nendmodule\n"]}
{"task_id": "vectorgates", "mutants": ["module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\t// Change: Modified bitwise OR to bitwise AND\n\tassign out_or_bitwise = a & b; // Change here\n\tassign out_or_logical = a || b;\n\tassign out_not = {~b,~a};\n\t\nendmodule\n", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\tassign out_or_bitwise = a | b;\n\t// Change: Modified logical OR to logical AND\n\tassign out_or_logical = a && b; // Change here\n\tassign out_not = {~b,~a};\n\t\nendmodule\n", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = a || b;\n\t// Change: Inverted the ordering of NOT outputs\n\tassign out_not = {~a, ~b}; // Change here\n\t\nendmodule\n", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = a || b;\n\t// Change: Only taking inverse of a and ignoring b\n\tassign out_not = {3'b000, ~a}; // Change here\n\t\nendmodule\n", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = a || b;\n\t// Change: Only taking inverse of b and ignoring a\n\tassign out_not = {~b, 3'b000}; // Change here\n\t\nendmodule\n", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\t// Change: Use XOR instead of OR for bitwise\n\tassign out_or_bitwise = a ^ b; // Change here\n\tassign out_or_logical = a || b;\n\tassign out_not = {~b,~a};\n\t\nendmodule\n", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\t// Change: Use NOR instead of OR for bitwise\n\tassign out_or_bitwise = ~(a | b); // Change here\n\tassign out_or_logical = a || b;\n\tassign out_not = {~b,~a};\n\t\nendmodule\n", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = a || b;\n\t// Change: Apply inverse only to lower half of out_not\n\tassign out_not = {3'b111, ~a}; // Change here\n\t\nendmodule\n", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\tassign out_or_bitwise = a | b;\n\t// Change: Logical OR is replaced with XNOR of a and not b\n\tassign out_or_logical = a ~^ ~b; // Change here\n\tassign out_not = {~b,~a};\n\t\nendmodule\n", "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\t// Change: Bitwise OR replaced with bitwise NAND\n\tassign out_or_bitwise = ~(a & b); // Change here\n\tassign out_or_logical = a || b;\n\tassign out_not = {~b,~a};\n\t\nendmodule\n"]}
{"task_id": "fsm3onehot", "mutants": ["module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] | state[C]) & ~in; // No change\n    assign next_state[B] = (state[A] | state[B] | state[D]) & in; // No change\n    assign next_state[C] = (state[B] & state[D]) & ~in; // Changed | to &\n    assign next_state[D] = state[C] & in; // No change\n    \n    assign out = (state[D]); // No change\n    \nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] | state[C]) & ~in; // No change\n    assign next_state[B] = (state[A] | state[B] & state[D]) & in; // Changed | to &\n    assign next_state[C] = (state[B] | state[D]) & ~in; // No change\n    assign next_state[D] = state[C] & in; // No change\n    \n    assign out = (state[D]); // No change\n    \nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] & state[C]) & ~in; // Changed | to &\n    assign next_state[B] = (state[A] | state[B] | state[D]) & in; // No change\n    assign next_state[C] = (state[B] | state[D]) & ~in; // No change\n    assign next_state[D] = state[C] & in; // No change\n    \n    assign out = (state[D]); // No change\n    \nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] | state[C]) & in; // Changed ~in to in\n    assign next_state[B] = (state[A] | state[B] | state[D]) & in; // No change\n    assign next_state[C] = (state[B] | state[D]) & ~in; // No change\n    assign next_state[D] = state[C] & in; // No change\n    \n    assign out = (state[D]); // No change\n    \nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] | state[C]) & ~in; // No change\n    assign next_state[B] = (state[A] | state[B] | state[D]) & ~in; // Changed in to ~in\n    assign next_state[C] = (state[B] | state[D]) & ~in; // No change\n    assign next_state[D] = state[C] & in; // No change\n    \n    assign out = (state[D]); // No change\n    \nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] | state[C]) & ~in; // No change\n    assign next_state[B] = (state[A] | state[B] | state[D]) & in; // No change\n    assign next_state[C] = (state[B] | state[D]) & in; // Changed ~in to in\n    assign next_state[D] = state[C] & in; // No change\n    \n    assign out = (state[D]); // No change\n    \nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] | state[C]) & ~in; // No change\n    assign next_state[B] = (state[A] | state[B] | state[D]) & in; // No change\n    assign next_state[C] = (state[B] | state[D]) & ~in; // No change\n    assign next_state[D] = state[C] | in; // Changed & to |\n    \n    assign out = (state[D]); // No change\n    \nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] | state[C]) & ~in; // No change\n    assign next_state[B] = (state[A] & state[B] | state[D]) & in; // Changed | to &\n    assign next_state[C] = (state[B] | state[D]) & ~in; // No change\n    assign next_state[D] = state[C] & in; // No change\n    \n    assign out = (state[D]); // No change\n    \nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] & state[C]) & ~in; // Changed | to &\n    assign next_state[B] = (state[A] | state[B] | state[D]) & in; // No change\n    assign next_state[C] = (state[B] & state[D]) & ~in; // Changed | to &\n    assign next_state[D] = state[C] & in; // No change\n    \n    assign out = (state[D]); // No change\n    \nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] | state[C]) & ~in; // No change\n    assign next_state[B] = (state[A] | state[B]) & in; // Removed state[D] from condition\n    assign next_state[C] = (state[B] | state[D]) & ~in; // No change\n    assign next_state[D] = state[C] & in; // No change\n    \n    assign out = (state[D]); // No change\n    \nendmodule\n"]}
{"task_id": "conditional", "mutants": ["module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = a;\n\t\tif (min >= b) min = b; // Change: > changed to >=\n\t\tif (min > c) min = c;\n\t\tif (min > d) min = d;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = b; // Change: Initializing min with b instead of a\n\t\tif (min > a) min = a;\n\t\tif (min > c) min = c;\n\t\tif (min > d) min = d;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = a;\n\t\tif (min > b) min = b;\n\t\tif (min > c) min = c;\n\t\t// Removed the last comparison\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = a;\n\t\tif (min > b) min = b;\n\t\tif (min >= c) min = c; // Change: > changed to >=\n\t\tif (min > d) min = d;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = a;\n\t\t// Removed b comparison\n\t\tif (min > c) min = c;\n\t\tif (min > d) min = d;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = a;\n\t\tif (min > b) min = b;\n\t\t// Removed c comparison\n\t\tif (min > d) min = d;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = a;\n\t\tif (min > b) min = b;\n\t\tif (min > c) min = c;\n\t\tif (min >= d) min = d; // Change: > changed to >=\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = a;\n\t\tif (min < b) min = b; // Change: > changed to <\n\t\tif (min > c) min = c;\n\t\tif (min > d) min = d;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = d; // Change: Initializing min with d instead of a\n\t\tif (min > a) min = a;\n\t\tif (min > b) min = b;\n\t\tif (min > c) min = c;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = a;\n\t\tif (min > b) min = b;\n\t\tif (min > c) min = c;\n\t\tif (min > d) {min = d; min = min - 1;} // Change: Added a decrement of min after setting it to d\n\tend\n\t\nendmodule\n"]}
{"task_id": "kmap2", "mutants": ["module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & ~b) | (~d&~a) | (a&c&d) | (b&c&d); // Changed (~d&~a) to (~d&~b)\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & ~b) | (~d&~a) | (a&c&d) | (b&c&~d); // Changed (b&c&d) to (b&c&~d)\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & b) | (~d&~a) | (a&c&d) | (b&c&d); // Changed (~c & ~b) to (~c & b)\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & ~b) | (d&~a) | (a&c&d) | (b&c&d); // Changed (~d&~a) to (d&~a)\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & ~b) | (~d&~a) | (a&~c&d) | (b&c&d); // Changed (a&c&d) to (a&~c&d)\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & ~b) | (~d&~a) | (a&c&d) | (~b&c&d); // Changed (b&c&d) to (~b&c&d)\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & ~b) | (~d&a) | (a&c&d) | (b&c&d); // Changed (~d&~a) to (~d&a)\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (c & ~b) | (~d&~a) | (a&c&d) | (b&c&d); // Changed (~c & ~b) to (c & ~b)\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & ~b) | (~d&~a) | (~a&c&d) | (b&c&d); // Changed (a&c&d) to (~a&c&d)\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & ~b) | (~d&~a) | (a&c&d) | (b&~c&d); // Changed (b&c&d) to (b&~c&d)\nendmodule\n"]}
{"task_id": "vector4", "mutants": ["module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {23{in[7]}}, in }; // Changed number of replicated bits from 24 to 23\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {25{in[7]}}, in[7:1] }; // Increased replication to 25 and used bits 7:1 of 'in'\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {24{in[6]}}, in }; // Replicating bit 6 instead of bit 7\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {24{!in[7]}}, in }; // Inverting the sign bit before replication\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {24{in[7]}}, in[7:0] }; // Explicitly specifying the range of 'in', no actual change in behavior\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {22{in[7]}}, in }; // Changed number of replicated bits from 24 to 22\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {24{in[7]}}, {4{in[7:6]}} }; // Added replication of bits 7:6 of 'in' four times at the end\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {24{in[0]}}, in }; // Replicating bit 0 instead of bit 7\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {24{in[7]}}, in[6:0], in[7] }; // Moved bit 7 to the end of 'in'\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {26{in[7]}}, in[7:2] }; // Increased replication to 26 and used bits 7:2 of 'in'\n\nendmodule\n"]}
{"task_id": "m2014_q4i", "mutants": ["module top_module(\n    output out);\n    \n    assign out = 1'b0; // No change here, demonstrating the correct original behavior\n\nendmodule\n// Note: This mutant is intentionally left unchanged as a control example.\n", "module top_module(\n    output out);\n    \n    assign out = 1'b1; // Changed 0 to 1, altering the output value\n\nendmodule\n", "module top_module(\n    output out);\n    \n    assign out = ~1'b0; // Added a bitwise NOT operator, which does not change the output logically but differs syntactically\n\nendmodule\n", "module top_module(\n    output out);\n    \n    assign out = 1'b0 ^ 1'b1; // Added an XOR with 1, which changes the logic\n\nendmodule\n", "module top_module(\n    output out);\n    \n    assign out = 1'b0 & 1'b1; // Changed logic to AND with 1, which won't change the output but alters the code\n\nendmodule\n", "module top_module(\n    output out);\n    \n    assign out = 1'b0 | 1'b0; // Changed logic to OR with 0, which does not change the output but varies the structure\n\nendmodule\n", "module top_module(\n    output out);\n    \n    assign out = !(1'b1); // Used logical NOT on 1, which gives 0 but changes the implementation\n\nendmodule\n", "module top_module(\n    output out);\n    \n    assign out = 1'bz; // Changed output to high impedance state 'z', differing in behavior\n\nendmodule\n", "module top_module(\n    output out);\n    \n    assign out = 1'b0 ? 1'b0 : 1'b1; // Introduced a conditional operation that results in 0\n\nendmodule\n", "module top_module(\n    output out);\n    \n    assign out = 0; // Simplified the assignment to 0 without specifying bit width\n\nendmodule\n"]}
{"task_id": "step_one", "mutants": ["module top_module(\n\toutput one);\n\t\n\tassign one = 1'b0; // Changed 1'b1 to 1'b0, so the output always drives 0 (logic low)\n\nendmodule\n", "module top_module(\n\toutput one);\n\t\n\tassign one = ~1'b0; // Used bitwise NOT operator, result is still 1'b1 but expressed differently\n\nendmodule\n", "module top_module(\n\toutput one);\n\t\n\treg one_reg; // Introduced a reg type\n\talways @(*) one_reg = 1'b1; // Always block to assign the value\n\tassign one = one_reg; // Output driven by reg\n\nendmodule\n", "module top_module(\n\toutput one);\n\t\n\tassign one = 1'b1 ^ 1'b1; // Changed to XOR operation with itself, resulting in 0\n\nendmodule\n", "module top_module(\n\toutput one);\n\t\n\tassign one = 1'b1 | 1'b0; // Changed to OR operation with logic low, no change in functionality\n\nendmodule\n", "module top_module(\n\toutput one);\n\t\n\tassign one = 1'b1 & 1'b1; // Changed to AND operation, no change in functionality\n\nendmodule\n", "module top_module(\n\toutput one);\n\t\n\tassign one = 1'b1 ^ 1'b0; // Changed to XOR operation with logic low, effectively the same\n\nendmodule\n", "module top_module(\n\toutput one);\n\t\n\tassign one = !(1'b0); // Changed to logical NOT operation on logic low, same as original functionality\n\nendmodule\n", "module top_module(\n\toutput one);\n\t\n\tassign one = 1'b1 - 1'b0; // Subtraction operation, result is 1, minor change in expression\n\nendmodule\n", "module top_module(\n\toutput one);\n\t\n\tassign one = 1'b1 ? 1'b1 : 1'b0; // Ternary operation, if 1 then 1 else 0, unchanged functionality but different syntax\n\nendmodule\n"]}
{"task_id": "vector100r", "mutants": ["module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\talways_comb \n\t\tfor (int i=0;i<$bits(out);i++) // Change: modified the loop condition to run one less iteration\n\t\t\tout[i] = in[$bits(out)-i-2]; // This also shifts the bit assignment by one, creating a different output\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\talways_comb \n\t\tfor (int i=1;i<=$bits(out);i++) // Change: starting the loop from 1 instead of 0\n\t\t\tout[i-1] = in[$bits(out)-i]; // Adjusted indexing to accommodate loop change\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\talways_comb \n\t\tfor (int i=0;i<$bits(out);i++)\n\t\t\tout[i] = in[$bits(out)-i-1] ^ 1'b1; // Change: XOR each bit with 1, flipping bits\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\talways_comb \n\t\tfor (int i=0;i<$bits(out)-1;i++) // Change: Stop the loop one iteration early\n\t\t\tout[i] = in[$bits(out)-i-1];\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\talways_comb \n\t\tfor (int i=0;i<$bits(out);i++)\n\t\t\tout[i] = in[$bits(out)-i-1];\n\t\t\tout[99] = in[0]; // Change: Explicitly set the last bit to the first bit of input, redundant but different\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\talways_comb\n\t\tfor (int i=0;i<$bits(out);i++)\n\t\t\tout[i] = in[$bits(out)-i]; // Change: Removed the -1, causing index out of bounds for in[]\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\talways_comb \n\t\tfor (int i=0;i<$bits(out);i++)\n\t\t\tout[i] = !in[$bits(out)-i-1]; // Change: Used logical NOT instead of bitwise, flipping bits\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\t// Change: Added a temporary variable to add an unnecessary step\n\treg temp;\n\talways_comb \n\t\tfor (int i=0;i<$bits(out);i++) {\n\t\t\ttemp = in[$bits(out)-i-1];\n\t\t\tout[i] = temp;\n\t\t}\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\talways_comb \n\t\tfor (int i=0;i<$bits(out);i+=2) // Change: Increment i by 2, skipping every other bit\n\t\t\tout[i] = in[$bits(out)-i-1];\n\t\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\talways_comb \n\t\tfor (int i=0;i<$bits(out);i++)\n\t\t\tout[i] = in[99-i]; // Change: Directly used 99 instead of calculating $bits(out)-i-1\n\t\nendmodule\n"]}
{"task_id": "truthtable1", "mutants": ["module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( ~x3 & x2 & ~x1 ) | // Change: No change, to demonstrate original logic for reference.\n\t\t\t\t( ~x3 & x2 & x1 ) |\n\t\t\t\t( x3 & ~x2 & x1 ) |\n\t\t\t\t( x3 & x2 & x1 ) ;\n\t\nendmodule\n", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( ~x3 & x2 & ~x1 ) | // Change: No change.\n\t\t\t\t( ~x3 & x2 ) | // Change: Removed & x1\n\t\t\t\t( x3 & ~x2 & x1 ) |\n\t\t\t\t( x3 & x2 & x1 ) ;\n\t\nendmodule\n", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( x3 & x2 & ~x1 ) | // Change: Changed ~x3 to x3.\n\t\t\t\t( ~x3 & x2 & x1 ) |\n\t\t\t\t( x3 & ~x2 & x1 ) |\n\t\t\t\t( x3 & x2 & x1 ) ;\n\t\nendmodule\n", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( ~x3 & x2 & ~x1 ) | \n\t\t\t\t( ~x3 & x2 & x1 ) |\n\t\t\t\t( x3 & x2 & x1 ) | // Change: Removed ~x2 & \n\t\t\t\t( x3 & x2 & x1 ) ; // Repetition for emphasis, logically no change but syntactically a mutant.\n\t\nendmodule\n", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( ~x3 & x2 & ~x1 ) | \n\t\t\t\t( ~x3 & x2 & x1 ) |\n\t\t\t\t( ~x3 & ~x2 & x1 ) | // Change: Changed x3 to ~x3 and x2 to ~x2.\n\t\t\t\t( x3 & x2 & x1 ) ;\n\t\nendmodule\n", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\tassign f = ( ~x3 & x2 & ~x1 ) | \n\t\t\t\t( ~x3 & x2 ) | // Change: Removed & x1 similar to mutant 2 but documenting as a separate change.\n\t\t\t\t( x3 & x2 & x1 ) | // Removed one condition, making it a different logical operation.\n\t\t\t\t( x3 & x2 & x1 ) ;\n\t\nendmodule\n", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( ~x3 & x2 & ~x1 ) | \n\t\t\t\t( x3 & x2 & x1 ) | // Change: Removed one of the middle conditions, altering the logic.\n\t\t\t\t( x3 & x2 & x1 ) ; // Repeated the last condition for effect.\n\t\nendmodule\n", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( ~x3 & x2 & ~x1 ) | \n\t\t\t\t( ~x3 & x2 & ~x1 ) | // Change: Repeated first condition instead of second, minor logical redundancy.\n\t\t\t\t( x3 & ~x2 & x1 ) |\n\t\t\t\t( x3 & x2 & x1 ) ;\n\t\nendmodule\n", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( ~x3 & x2 ) | // Change: Removed & ~x1, simplifying expression.\n\t\t\t\t( ~x3 & x2 & x1 ) |\n\t\t\t\t( x3 & ~x2 & x1 ) |\n\t\t\t\t( x3 & x2 & x1 ) ;\n\t\nendmodule\n", "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( ~x3 & x2 & ~x1 ) | \n\t\t\t\t( ~x3 & x2 & x1 ) |\n\t\t\t\t( x3 & ~x2 ) | // Change: Removed & x1, altering logic.\n\t\t\t\t( x3 & x2 & x1 ) ;\n\t\nendmodule\n"]}
{"task_id": "gates100", "mutants": ["module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in; // No change\n\tassign out_or = |in; // No change\n\tassign out_xor = ~^in; // Change: Negated the XOR output\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in[99:1]; // Change: AND operation from bits 99 to 1, excluding bit 0\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in[98:0]; // Change: OR operation from bits 98 to 0, excluding bit 99\n\tassign out_xor = ^in;\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in[99:1]; // Change: XOR operation from bits 99 to 1, excluding bit 0\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &{in[99:50],in[49:0]}; // Change: Explicit concatenation of the same input, no effective change in logic\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in; // No change\n\tassign out_or = |in; // No change\n\t// Change: Reversed XOR operation by inverting inputs then XOR them\n\tassign out_xor = ^~in;\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &(in | 1'b0); // Change: OR operation with constant zero before AND, no effective change\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\t// Change: XOR operation with an additional XOR with a constant zero\n\tassign out_xor = ^in ^ 1'b0;\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in; // No change\n\t// Change: Inverted the OR output\n\tassign out_or = ~|in;\n\tassign out_xor = ^in;\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\t// Change: AND operation with constant 1 before AND, no effective change\n\tassign out_and = &in & 1'b1;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n"]}
{"task_id": "hadd", "mutants": ["module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign {cout, sum} = a-b; // Change: Subtraction instead of addition\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign {cout, sum} = a&b; // Change: AND operation instead of addition\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign {cout, sum} = a|b; // Change: OR operation instead of addition\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign {cout, sum} = a^b; // Change: XOR operation instead of addition\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign {cout, sum} = {a+b, a+b}; // Change: Duplicate sum for cout and sum\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign cout = a+b; // Change: Only assign cout, remove sum assignment\n\tassign sum = a^b; // Additional: Exclusive OR for sum\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\t// Change: Swapped the order of cout and sum in the concatenation\n\tassign {sum, cout} = a+b; \n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign {cout, sum} = {1'b0, a+b}; // Change: Forced cout to be 0, only sum is calculated\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\t// Change: Added an inverter to the sum output\n\tassign {cout, sum} = ~(a+b);\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign {cout, sum} = (a+b) << 1; // Change: Left shift the result by 1\n\nendmodule\n"]}
{"task_id": "always_if2", "mutants": ["module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1'b1; // Changed 1 to 1'b1 for clarity\n\t\telse\n\t\t\tshut_off_computer = 0;\n\tend\n\t\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = !gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 1'b0;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1;\n\t\telse\n\t\t\tshut_off_computer = 1'b0; // Changed 0 to 1'b0 for clarity\n\tend\n\t\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = !gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 1'b0;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1;\n\t\telse\n\t\t\tshut_off_computer = 0; // No change here for reference\n\tend\n\t\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = !gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 1; // Changed 1'b0 to 1 for a minor difference\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1;\n\t\telse\n\t\t\tshut_off_computer = 0;\n\tend\n\t\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = ~gas_tank_empty; // Changed !gas_tank_empty to ~gas_tank_empty for a minor difference\n\t\telse\n\t\t\tkeep_driving = 1'b0;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 0; // Changed action when cpu_overheated to 0\n\t\telse\n\t\t\tshut_off_computer = 0;\n\tend\n\t\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = !gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 1'b0;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1;\n\t\telse\n\t\t\tshut_off_computer = 1; // Changed else behavior to also set shut_off_computer to 1\n\tend\n\t\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = !gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 1'b0;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1;\n\t\telse\n\t\t\tshut_off_computer = 0;\n\tend\n\t\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = !gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 1'b1; // Changed keep_driving to 1'b1 when arrived\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1;\n\t\telse\n\t\t\tshut_off_computer = 0;\n\tend\n\t\n\talways @(*) begin\n\t\tif (arrived) // Changed condition to if arrived instead of if ~arrived\n\t\t\tkeep_driving = 1'b0;\n\t\telse\n\t\t\tkeep_driving = !gas_tank_empty;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1;\n\t\telse\n\t\t\tshut_off_computer = 1'b1; // Changed else case to set shut_off_computer to 1'b1, creating logical error\n\tend\n\t\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = !gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 1'b0;\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1'b0; // Introducing a logical error by setting shut_off_computer to 0 when overheated\n\t\telse\n\t\t\tshut_off_computer = 0;\n\tend\n\t\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = !gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 1'b0;\n\tend\n\t\nendmodule\n"]}
{"task_id": "vector3", "mutants": ["module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:8] x, // Change: Mistyped bit range for x\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n\tassign { w,x,y,z} = {a,b,c,d,e,f,2'b11};\n\t\nendmodule\n", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [6:0] y, // Change: Reduced bit width of y\n\toutput [7:0] z\n);\n\n\tassign { w,x,y,z} = {a,b,c,d,e,f,2'b11};\n\t\nendmodule\n", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n\tassign { w,x,y,z } = {a,b,c,d,e,f,2'b00}; // Change: 2'b11 changed to 2'b00\nendmodule\n", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n\tassign { w,x,y,z} = {a,b,c,d,f,e,2'b11}; // Change: Swapped e and f\nendmodule\n", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n\tassign { w,x,y,z} = {a,c,b,d,e,f,2'b11}; // Change: Swapped b and c\nendmodule\n", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n\tassign { x,w,y,z} = {a,b,c,d,e,f,2'b11}; // Change: Swapped w and x in the assign statement\nendmodule\n", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n\tassign { w,x,y,z} = {a,b,c,d,e,f,2'b10}; // Change: Changed the last 2'b11 to 2'b10\nendmodule\n", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n\tassign { w,x,y,z} = {b,a,c,d,e,f,2'b11}; // Change: Swapped a and b\nendmodule\n", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n\tassign { w,x,y,z} = {a,b,d,c,e,f,2'b11}; // Change: Swapped c and d\nendmodule\n", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n\tassign { w,x,y,z} = {a,b,c,e,d,f,2'b11}; // Change: Swapped d and e\nendmodule\n"]}
{"task_id": "circuit2", "mutants": ["module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~a^b^c^~d; // Changed d to ~d\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = a^b^c^d; // Removed the negation of a\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~a^~b^c^d; // Negated b instead of only a\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~a^b^~c^d; // Negated c\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~a^b^c&d; // Changed XOR of c and d to AND\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~a^b|c^d; // Changed XOR of b and c to OR\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~a^b^c^(d&c); // Changed d to d&c\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~a^b^c^d^a; // Added a at the end\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (~a^b^c^d); // Added parentheses for clarity, minor change in formatting\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~a&b^c^d; // Changed XOR of a and b to AND\nendmodule\n"]}
{"task_id": "andgate", "mutants": ["module top_module(\n    input a, \n    input b,\n    output out\n);\n    \n    assign out = a | b; // Changed & to | to create an OR gate instead of an AND gate\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n    \n    assign out = a ^ b; // Changed & to ^ to create an XOR gate\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n    \n    assign out = ~(a & b); // Added ~ operator to invert the AND gate result\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n    \n    assign out = a & ~b; // Inverted input b\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n    \n    assign out = ~a & b; // Inverted input a\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n    \n    assign out = a && b; // Changed bitwise AND to logical AND (though in Verilog, this is typically the same for single-bit inputs)\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n    \n    assign out = (a & b) | (a & b); // Redundantly OR'ed the AND gate with itself\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n    \n    assign out = (a & a) & (b & b); // Used each input twice redundantly\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n    \n    assign out = !a & b; // Used logical NOT on a instead of bitwise NOT\n    \nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n    \n    assign out = a & b & b; // Added an extra b input to the AND gate\n    \nendmodule\n"]}
{"task_id": "m2014_q4g", "mutants": ["module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = (in1 ^ in2) ^ in3; // Changed ~() to ()\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = ~((in1 ^ in2) ^ in3); // Added ~ outside the expression\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = (~(in1 ^ in2)) ^ ~in3; // Changed in3 to ~in3\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = (~(in1 ~^ in2)) ^ in3; // Changed ^ to ~^ for in1 and in2\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = (~(in1 ^ in2)) ~^ in3; // Changed ^ to ~^ for the final operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = (~(in1 | in2)) ^ in3; // Changed ^ to | between in1 and in2\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = (~(in1 & in2)) ^ in3; // Changed ^ to & between in1 and in2\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = ((in1 ^ in2) ^ in3); // Removed one layer of ~()\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = (~(in1 ^ in2)) ^ !in3; // Changed in3 to !in3\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = (~(in1 ^ in2)) ^ (in3 & in3); // Changed in3 to (in3 & in3)\nendmodule\n"]}
{"task_id": "ece241_2014_q3", "mutants": ["module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = c & d; // Changed | to &\n\tassign mux_in[1] = 0;\n\tassign mux_in[2] = ~d;\t\n\tassign mux_in[3] = c&d;\n\t\nendmodule\n", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = c | d;\n\tassign mux_in[1] = 1; // Changed 0 to 1\n\tassign mux_in[2] = ~d;\t\n\tassign mux_in[3] = c&d;\n\t\nendmodule\n", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = c | d;\n\tassign mux_in[1] = 0;\n\tassign mux_in[2] = d; // Removed ~\n\tassign mux_in[3] = c&d;\n\t\nendmodule\n", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = c | d;\n\tassign mux_in[1] = 0;\n\tassign mux_in[2] = ~d;\t\n\tassign mux_in[3] = c|d; // Changed & to |\n\t\nendmodule\n", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = ~c | d; // Added ~ to c\n\tassign mux_in[1] = 0;\n\tassign mux_in[2] = ~d;\t\n\tassign mux_in[3] = c&d;\n\t\nendmodule\n", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = c | d;\n\tassign mux_in[1] = ~(c | d); // Added ~(c | d)\n\tassign mux_in[2] = ~d;\t\n\tassign mux_in[3] = c&d;\n\t\nendmodule\n", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = c | d;\n\tassign mux_in[1] = 0;\n\tassign mux_in[2] = ~c;\t// Changed ~d to ~c\n\tassign mux_in[3] = c&d;\n\t\nendmodule\n", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = c; // Removed | d\n\tassign mux_in[1] = 0;\n\tassign mux_in[2] = ~d;\t\n\tassign mux_in[3] = c&d;\n\t\nendmodule\n", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = d; // Removed c |\n\tassign mux_in[1] = 0;\n\tassign mux_in[2] = ~d;\t\n\tassign mux_in[3] = c&d;\n\t\nendmodule\n", "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = c | d;\n\tassign mux_in[1] = 0;\n\tassign mux_in[2] = ~d;\t\n\tassign mux_in[3] = !(c|d); // Changed c&d to !(c|d)\n\t\nendmodule\n"]}
{"task_id": "2012_q1g", "mutants": ["module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1;\n\t\t\t4'h1: f = 1;\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 0;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 1;\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 0; // Change: Original was \"4'h9: f = 0;\"\n\t\t\t4'ha: f = 1; // Mutant: Changed \"f = 0\" to \"f = 1\"\n\t\t\t4'hb: f = 0;\n\t\t\t4'hc: f = 1;\n\t\t\t4'hd: f = 0;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1;\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1;\n\t\t\t4'h1: f = 0; // Mutant: Changed \"f = 1\" to \"f = 0\"\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 0;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 1;\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 0;\n\t\t\t4'ha: f = 0;\n\t\t\t4'hb: f = 0;\n\t\t\t4'hc: f = 1;\n\t\t\t4'hd: f = 0;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1;\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1;\n\t\t\t4'h1: f = 1;\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 0;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 1;\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 1; // Mutant: Changed \"f = 0\" to \"f = 1\"\n\t\t\t4'ha: f = 0;\n\t\t\t4'hb: f = 0;\n\t\t\t4'hc: f = 1;\n\t\t\t4'hd: f = 0;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1;\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1;\n\t\t\t4'h1: f = 1;\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 0;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 0; // Mutant: Changed \"f = 1\" to \"f = 0\"\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 0;\n\t\t\t4'ha: f = 0;\n\t\t\t4'hb: f = 0;\n\t\t\t4'hc: f = 1;\n\t\t\t4'hd: f = 0;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1;\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1;\n\t\t\t4'h1: f = 1;\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 0;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 1;\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 0;\n\t\t\t4'ha: f = 0;\n\t\t\t4'hb: f = 0;\n\t\t\t4'hc: f = 0; // Mutant: Changed \"f = 1\" to \"f = 0\"\n\t\t\t4'hd: f = 0;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1;\n\t\tendcase\n\tend\n\nendmodule\n"]}
{"task_id": "always_nolatches", "mutants": ["module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\t\t// Change: Added an extra case that does nothing, essentially a no-op\n\t\t\t16'he000: ;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t// Change: Initially set {up, left, down, right} to 4'b0001 instead of 0\n\t\t{up, left, down, right} = 4'b0001;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\t// Change: Swapped the order of cases\n\t\tcase (scancode)\n\t\t\t16'he075: up = 1;\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he072: down = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t// Change: Changed the scancode for up arrow\n\t\t\t16'he076: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t// Change: Changed the scancode for left arrow\n\t\t\t16'he06c: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\t\t// Change: Incorrectly mapped scancode for an additional output, should not affect original functionality\n\t\t\t16'he077: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\t// Change: Inverted the initial condition for one of the outputs\n\talways @(*) begin\n\t\t{up, left, down, right} = 4'b1000;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\t// Change: Added a default case that sets all outputs to 1\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\t\tdefault: {up, left, down, right} = 4'b1111;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t// Change: Removed the case for right arrow\n\t\t\t// 16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t// Change: Combined cases for down and right arrows\n\t\t\t16'he072, 16'he074: {down, right} = 2'b11;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n"]}
{"task_id": "fadd", "mutants": ["module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a + b + cin; // No change, for reference\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a - b + cin; // Changed '+' to '-' between a and b\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a + b - cin; // Changed '+' to '-' for cin\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {sum, cout} = a + b + cin; // Swapped cout and sum in the assignment\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = {1'b0, a + b + cin}; // Added a constant bit '0' at the beginning of the result\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a & b + cin; // Changed '+' to '&' between a and b\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a + b + {cin}; // Enclosed cin in braces, no effective change but syntax variation\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a + b + cin ^ 1'b1; // Added XOR with 1 to the sum of a, b, and cin\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = (a + b + cin) | 1'b1; // Added OR with 1 to the result\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a + !b + cin; // Added logical NOT to b\nendmodule\n"]}
{"task_id": "always_case2", "mutants": ["module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0; // No change here; included for reference\n\t\t\t4'h2: pos = 2'h2; // Changed pos from 2'h1 to 2'h2\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h1; // Changed pos from 2'h2 to 2'h1\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h2; // Changed pos from 2'h1 to 2'h2\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h2; // Changed pos from 2'h3 to 2'h2\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h1; // Changed pos from 2'h0 to 2'h1\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n"]}
{"task_id": "m2014_q4j", "mutants": ["module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x+y; // Changed: No change in code; serves as a baseline for comparison.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x+y+1; // Change: Added 1 to the sum.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = {1'b0,x} + {1'b0,y}; // Change: Explicitly extended both operands to 5 bits before addition.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x+y-1; // Change: Subtracted 1 from the sum.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x-y; // Change: Changed addition to subtraction.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = {x[3], x} + {y[3], y}; // Change: Extended each operand to 5 bits using MSB before addition.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x+y; // Change: No functional change; included for diversity.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x^y; // Change: Changed addition to XOR operation.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = (x+y)^5'b00001; // Change: XORed the result with 1.\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x|y; // Change: Changed addition to OR operation.\nendmodule\n"]}
{"task_id": "vector0", "mutants": ["module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign {o2, o1, o0} = {vec[1], vec[0], vec[2]}; // Changed the ordering in the bit assignment\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = {vec[0], vec[2], vec[1]}; // Changed the order of bits in the output vector\n    assign {o2, o1, o0} = vec;\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign {o2, o0, o1} = vec; // Swapped o1 and o0 in the bit assignment\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = ~vec; // Inverted the bits of vec for the output vector\n    assign {o2, o1, o0} = vec;\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = {3{vec[0]}}; // Replicated the first bit of vec across the outv\n    assign {o2, o1, o0} = vec;\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign {o2, o1, o0} = vec ^ 3'b101; // XORed vec with a bit pattern before assignment\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign {o2, o1} = vec[2:1]; // Only assigned the first two bits, leaving o0 disconnected\n    // o0 is not assigned\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = {vec[1:0], vec[2]}; // Rearranged bits in outv\n    assign {o2, o1, o0} = vec;\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = vec;\n    assign {o2, o1, o0} = {2'b00, vec[0]}; // Only the least significant bit of vec is used, zeros for others\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n    assign outv = {vec[2], vec[2:1]}; // Incorrect bit-width for assignment, potentially causing a warning\n    assign {o2, o1, o0} = vec;\n\nendmodule\n"]}
{"task_id": "2012_q2b", "mutants": ["module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&w; // Unchanged\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & w; // Changed ~w to w\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]|w; // Changed & to |\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w; // Unchanged\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&w; // Unchanged\n    assign Y3 = (y[1]&y[2]|y[4]|y[5]) & ~w; // Changed | to & between y[1] and y[2]\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = !y[0]&w; // Changed y[0] to !y[0]\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w; // Unchanged\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&w; // Unchanged\n    assign Y3 = (y[0]|y[1]|y[2]|y[4]|y[5]) & ~w; // Added y[0] to the Y3 condition\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = (y[0]&w) | y[1]; // Added y[1] to the Y1 condition\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w; // Unchanged\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&w; // Unchanged\n    assign Y3 = (y[1]|y[2]|y[4]) & ~w; // Removed y[5] from the Y3 condition\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&!w; // Changed w to !w for Y1\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w; // Unchanged\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = (y[0]^w); // Changed & to ^ for Y1\n    assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w; // Unchanged\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n    assign Y1 = y[0]&w; // Unchanged\n    assign Y3 = (y[1]|y[2]|y[3]|y[4]|y[5]) & ~w; // Added y[3] to the Y3 condition\nendmodule\n"]}
{"task_id": "kmap4", "mutants": ["module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 1; // Mutation: changed out to 1\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0; // Mutation: changed out to 0\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 1; // Mutation: changed out to 1\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 1; // Mutation: changed out to 1\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 0; // Mutation: changed out to 0\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 1; // Mutation: changed out to 1\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 0; // Mutation: changed out to 0\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 0; // Mutation: changed out to 0\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 0; // Mutation: changed out to 0\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 1; // Mutation: changed out to 1\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n"]}
{"task_id": "m2014_q3", "mutants": ["module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1; // Changed from 1'bx to 1\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 0; // Changed from 1'bx to 0\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 0; // Changed from 1'bx to 0\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 0; // Changed from 1 to 0\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 1; // Changed from 0 to 1\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1; // Changed from 1'bx to 1\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 0; // Changed from 1'bx to 0\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 0; // Changed from 1 to 0\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 1; // Changed from 0 to 1\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 1; // Changed from 0 to 1\n\t\t\t4'h9: f = 0; // No change\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx; // No change\n\t\t\t4'h1: f = 1'bx; // No change\n\t\t\t4'h2: f = 0; // No change\n\t\t\t4'h3: f = 1'bx; // No change\n\t\t\t4'h4: f = 1; // No change\n\t\t\t4'h5: f = 1'bx; // No change\n\t\t\t4'h6: f = 1; // No change\n\t\t\t4'h7: f = 0; // No change\n\t\t\t4'h8: f = 0; // No change\n\t\t\t4'h9: f = 1; // Changed from 0 to 1\n\t\t\t4'ha: f = 1'bx; // No change\n\t\t\t4'hb: f = 1; // No change\n\t\t\t4'hc: f = 1; // No change\n\t\t\t4'hd: f = 1'bx; // No change\n\t\t\t4'he: f = 1; // No change\n\t\t\t4'hf: f = 1'bx; // No change\n\t\tendcase\n\tend\n\nendmodule\n"]}
{"task_id": "notgate", "mutants": ["module top_module(\n    input in,\n    output out\n);\n    \n    assign out = ~in; // Mutation: No change, control mutation to establish a baseline difference.\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n    \n    assign out = in; // Mutation: Removed NOT operation, making it a buffer instead of a NOT gate.\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n    \n    assign out = ~in | in; // Mutation: Added OR operation with the same input, making the output always 1.\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n    \n    assign out = ~in & in; // Mutation: Added AND operation with its inverse, making the output always 0.\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n    \n    wire temp; // Mutation: Introduced an intermediary wire but not used.\n    assign out = ~in;\n    \nendmodule\n"]}
{"task_id": "mux2to1v", "mutants": ["module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? a : b; // Change: swapped a and b in the ternary operation\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? b : {a[98:0], a[99]}; // Change: rotated a to the right\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? {b[0], b[99:1]} : a; // Change: rotated b to the left\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? b : ~a; // Change: bitwise NOT operation on a\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? ~b : a; // Change: bitwise NOT operation on b\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? {b[99:50], a[49:0]} : a; // Change: mixed half of b and half of a when sel=1\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? b : {a[49:0], a[99:50]}; // Change: swapped the halves of a\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? {b[50:0], b[99:51]} : a; // Change: swapped the halves of b and made an off by one change\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel && sel ? b : a; // Change: redundant logical AND operation on sel\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = !sel ? b : a; // Change: negated the selector condition\n\nendmodule\n"]}
{"task_id": "gates", "mutants": ["module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = a^~b; // Change: Used a^~b instead of ~(a^b) for xnor, logically same but minor alteration in expression\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b); // No change here \n\tassign out_nor = ~(a|b); // No change here \n\tassign out_xnor = ~(a^b); // No change here \n\tassign out_anotb = a & b; // Change: Incorrectly showing AND result instead of AND-NOT\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^~b; // Change: XOR with inverted b, changing the logic.\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|~b; // Change: OR with inverted b, changing the logic.\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = a&b; // Change: Removed inversion for nand, changing the logic.\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = a|b; // Change: Removed inversion for nor, logically incorrect.\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a|b; // Change: Incorrectly using OR operation for AND output.\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a&b; // Change: Using AND operation for XOR output, logically incorrect.\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a&b; // Change: Using AND operation for OR output, logically incorrect.\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = ~(a^b);\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = a|~b; // Change: Used OR with inverted b instead of XNOR logic, altering the logical operation.\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n"]}
{"task_id": "7458", "mutants": ["module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} & &{p1d, p1e, p1f}; // Changed | to &\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = |{p1a, p1b, p1c} | &{p1d, p1e, p1f}; // Changed & to | for first AND\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = |{p2a, p2b} | &{p2c, p2d}; // Changed & to | for first AND in p2y\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = &{p2a, p2b} | |{p2c, p2d}; // Changed & to | for second AND in p2y\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b} | &{p1d, p1e, p1f}; // Removed p1c from first AND\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e}; // Removed p1f from second AND\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c, p1d} | &{p1e, p1f}; // Added p1d to first AND, changing functionality\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = &{p2a} | &{p2c, p2d}; // Removed p2b from first AND\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = &{p2a, p2b} | &{p2d}; // Removed p2c from second AND\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1c} | &{p1d, p1e, p1f}; // Removed p1b from first AND\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n"]}
{"task_id": "wire", "mutants": ["module top_module(\n    input in,\n    output out);\n    \n    assign out = !in; // Changed: Negated input to output\n    \nendmodule\n", "module top_module(\n    input in,\n    output reg out); // Changed: Output from wire to reg\n    \n    always @(in) begin\n        out = in;\n    end\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in | 1'b0; // Changed: OR operation with 0\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in & 1'b1; // Changed: AND operation with 1\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in ^ 1'b0; // Changed: XOR operation with 0\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in; // No change here for control comparison\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = ~in; // Changed: Complement of input to output\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = {in}; // Changed: Concatenation with itself (no actual change in functionality)\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in >>> 1'b0; // Changed: Arithmetic right shift by 0\n    \nendmodule\n", "module top_module(\n    input in,\n    output out);\n    \n    assign out = in << 1'b0; // Changed: Logical left shift by 0\n    \nendmodule\n"]}
{"task_id": "m2014_q4e", "mutants": ["module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2); // Original: assign out = ~(in1 | in2); Modification: No change to demonstrate the original for comparison.\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 & in2); // Changed OR to AND\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = (in1 | in2); // Removed NOT operator\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2) ^ 1'b1; // Added XOR with 1 after original operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~((in1 | in2) & 1'b1); // Added AND with 1 before NOT operator\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~((in1 | in2) | 1'b0); // Added OR with 0 before NOT operator\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1); // Only considering in1 for the NOR operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in2); // Only considering in2 for the NOR operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2 | in1); // Duplicated in1 in OR operation\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~((in1 & in2) | in2); // Combined AND with in2 and OR with in2\nendmodule\n"]}
{"task_id": "m2014_q4h", "mutants": ["module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = ~in; // Negated the input signal\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in & in; // AND operation with itself, essentially the same but logically different\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in | in; // OR operation with itself, essentially the same but logically different\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\twire internal; // Added an internal wire\n\tassign internal = in;\n\tassign out = internal; // Routed input through an internal wire before output\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in ^ in; // XOR operation with itself, should result in 0\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in; // Original line\n\t//Added redundant assignment which is functionally the same\n\tassign out = in;\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\t// Change made to use a ternary operator, logically identical\n\tassign out = in ? 1'b1 : 1'b0;\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\t// Negated the input, then negated it again\n\tassign out = ~(~in);\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\t// Changed to add a delay to the assignment, may introduce simulation mismatches\n\tassign #1 out = in;\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out);\n\t\n\t// Use of buffer operation via ANDing with 1, though logically unnecessary\n\tassign out = in & 1'b1;\nendmodule\n"]}
