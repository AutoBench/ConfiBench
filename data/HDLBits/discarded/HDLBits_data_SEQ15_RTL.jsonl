{"task_id": "ece241_2013_q12", "gptgen_RTL": ["module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    // Shift register declaration\n    reg [7:0] shift_reg;\n\n    // Shifting operation\n    always @(posedge clk) begin\n        if (enable) begin\n            shift_reg <= {S, shift_reg[7:1]};\n        end\n    end\n\n    // Multiplexer for selecting the output bit based on A, B, C\n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = shift_reg[0];\n            3'b001: Z = shift_reg[1];\n            3'b010: Z = shift_reg[2];\n            3'b011: Z = shift_reg[3];\n            3'b100: Z = shift_reg[4];\n            3'b101: Z = shift_reg[5];\n            3'b110: Z = shift_reg[6];\n            3'b111: Z = shift_reg[7];\n            default: Z = 1'bx; // Should never occur\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n// 8-bit shift register declaration\nreg [7:0] shift_reg;\n\n// Shifting logic with enable\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {S, shift_reg[7:1]};\n    end\nend\n\n// Multiplexer logic for selecting the output based on A, B, C\nalways @(*) begin\n    case({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n// 8-bit shift register declaration\nreg [7:0] shift_reg;\n\n// Shift operation\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {shift_reg[6:0], S};\n    end\nend\n\n// Multiplexer for selecting output based on A, B, C\nalways @(*) begin\n    case({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0; // Default case\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] shift_reg; // 8-bit shift register\n    \n    always @(posedge clk) begin\n        if (enable) begin\n            // Shift left operation, MSB is shifted in first\n            shift_reg <= {shift_reg[6:0], S};\n        end\n    end\n    \n    // Implementing the multiplexer logic for selecting the appropriate bit based on A, B, C\n    always @(*) begin\n        case({A, B, C})\n            3'b000: Z = shift_reg[0];\n            3'b001: Z = shift_reg[1];\n            3'b010: Z = shift_reg[2];\n            3'b011: Z = shift_reg[3];\n            3'b100: Z = shift_reg[4];\n            3'b101: Z = shift_reg[5];\n            3'b110: Z = shift_reg[6];\n            3'b111: Z = shift_reg[7];\n            default: Z = 1'bx; // undefined behavior\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n// Shift register\nreg [7:0] Q;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        Q <= {S, Q[7:1]};\n    end\nend\n\n// Multiplexer\nalways @(*) begin\n    case({A, B, C})\n        3'b000: Z = Q[0];\n        3'b001: Z = Q[1];\n        3'b010: Z = Q[2];\n        3'b011: Z = Q[3];\n        3'b100: Z = Q[4];\n        3'b101: Z = Q[5];\n        3'b110: Z = Q[6];\n        3'b111: Z = Q[7];\n        default: Z = 1'bx; // Undefined behavior\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    // Declare the shift register\n    reg [7:0] shift_reg;\n\n    // Shift register operation\n    always @(posedge clk) begin\n        if (enable) begin\n            shift_reg <= {shift_reg[6:0], S};\n        end\n    end\n\n    // Determine the output Z based on the inputs A, B, and C\n    always @(*) begin\n        case({A, B, C})\n            3'b000: Z = shift_reg[0];\n            3'b001: Z = shift_reg[1];\n            3'b010: Z = shift_reg[2];\n            3'b011: Z = shift_reg[3];\n            3'b100: Z = shift_reg[4];\n            3'b101: Z = shift_reg[5];\n            3'b110: Z = shift_reg[6];\n            3'b111: Z = shift_reg[7];\n            default: Z = 1'bx; // undefined state\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n// 8-bit shift register\nreg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {S, shift_reg[7:1]};\n    end\nend\n\n// Multiplexer logic for selecting output based on A, B, C\nalways @(*) begin\n    case({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'bx; // Undefined state\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n// 8-bit shift register declaration\nreg [7:0] shift_reg;\n\n// Shift register operation\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {S, shift_reg[7:1]};\n    end\nend\n\n// Mux for selecting the output based on A, B, C\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'bx; // Undefined state\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] shift_register;\n\n    // Shift register implementation\n    always @(posedge clk) begin\n        if (enable) begin\n            shift_register <= {shift_register[6:0], S};\n        end\n    end\n\n    // Implementing the multiplexer for selecting the output based on A, B, C\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = shift_register[0];\n            3'b001: Z = shift_register[1];\n            3'b010: Z = shift_register[2];\n            3'b011: Z = shift_register[3];\n            3'b100: Z = shift_register[4];\n            3'b101: Z = shift_register[5];\n            3'b110: Z = shift_register[6];\n            3'b111: Z = shift_register[7];\n            default: Z = 1'b0; // Default case to avoid latches\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    reg [7:0] shift_reg; // 8-bit shift register\n\n    always @(posedge clk) begin\n        if (enable) begin\n            shift_reg <= {shift_reg[6:0], S}; // Shift left operation\n        end\n    end\n\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = shift_reg[0];\n            3'b001: Z = shift_reg[1];\n            3'b010: Z = shift_reg[2];\n            3'b011: Z = shift_reg[3];\n            3'b100: Z = shift_reg[4];\n            3'b101: Z = shift_reg[5];\n            3'b110: Z = shift_reg[6];\n            3'b111: Z = shift_reg[7];\n            default: Z = 1'bz; // High impedance for non-defined states\n        endcase\n    end\nendmodule\n"]}
{"task_id": "count1to10", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0001; // Reset to 1\n        else if (q == 4'b1010)\n            q <= 4'b0001; // Reset to 1 if q is 10\n        else\n            q <= q + 1; // Increment q\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001; // Reset counter to 1\n    end else if (q == 4'b1010) begin // When counter reaches 10\n        q <= 4'b0001; // Reset counter to 1\n    end else begin\n        q <= q + 1; // Increment counter\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0001; // Reset the counter to 1\n        else if (q == 4'b1010)\n            q <= 4'b0001; // Loop back to 1 after reaching 10\n        else\n            q <= q + 1; // Increment the counter\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0001; // Reset the counter to 1\n        else if (q == 4'b1010)\n            q <= 4'b0001; // Reset to 1 after reaching 10\n        else\n            q <= q + 1; // Increment the counter\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // If reset is high, reset the counter to 1\n        q <= 4'b0001;\n    end\n    else begin\n        if (q == 4'b1010) begin\n            // If counter reaches 10, reset it to 1\n            q <= 4'b0001;\n        end\n        else begin\n            // Otherwise, increment the counter\n            q <= q + 1;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1; // Reset the counter to 1\n    end\n    else if (q == 4'd10) begin\n        q <= 4'd1; // Reset to 1 after reaching 10\n    end\n    else begin\n        q <= q + 4'd1; // Increment the counter\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0001; // Reset counter to 1\n    else if (q == 4'b1010)\n        q <= 4'b0001; // Reset to 1 if the count reaches 10\n    else\n        q <= q + 1; // Increment counter\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001; // Reset to 1\n    end\n    else if (q == 4'b1010) begin\n        q <= 4'b0001; // Wrap from 10 to 1\n    end\n    else begin\n        q <= q + 1; // Increment counter\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'd1; // Reset to 1, since the counter starts at 1\n    else if (q == 4'd10)\n        q <= 4'd1; // Reset to 1 after reaching 10\n    else\n        q <= q + 4'd1; // Increment counter\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0001; // Reset the counter to 1\n        else if (q == 4'b1010)\n            q <= 4'b0001; // Reset to 1 after reaching 10\n        else\n            q <= q + 1; // Increment the counter\n    end\nendmodule\n"]}
{"task_id": "fsm3s", "gptgen_RTL": ["module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // Define state encoding\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    // State registers\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default case to handle unknown states\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case (current_state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default case to ensure deterministic output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n// State encoding\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n// State registers\nreg [1:0] current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        current_state <= A;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic based on the current state and the input\nalways @(*) begin\n    case (current_state)\n        A: next_state = in ? B : A;\n        B: next_state = in ? B : C;\n        C: next_state = in ? D : A;\n        D: next_state = in ? B : C;\n        default: next_state = A;\n    endcase\nend\n\n// Output logic\nalways @(current_state) begin\n    case (current_state)\n        A: out = 0;\n        B: out = 0;\n        C: out = 0;\n        D: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    // Current and Next state variables\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A; // Reset to state A\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case(current_state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default case to handle unknown state\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case(current_state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default case to ensure defined output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State Encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    // Current and Next state declaration\n    state_t current_state, next_state;\n\n    // State transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset to state A\n            current_state <= A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = A; // Default case to avoid latches\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default case to ensure defined output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg out\n);\n\n// State encoding\nlocalparam A = 2'b00,\n           B = 2'b01,\n           C = 2'b10,\n           D = 2'b11;\n\nreg [1:0] current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        current_state <= A; // Reset to state A\n    else\n        current_state <= next_state;\nend\n\n// Next state logic based on the current state and the input\nalways @(*) begin\n    case (current_state)\n        A: next_state = in ? B : A;\n        B: next_state = in ? B : C;\n        C: next_state = in ? D : A;\n        D: next_state = in ? B : C;\n        default: next_state = A; // Default case to handle any undefined states\n    endcase\nend\n\n// Output logic for the Moore machine\nalways @(current_state) begin\n    case (current_state)\n        A: out = 0;\n        B: out = 0;\n        C: out = 0;\n        D: out = 1;\n        default: out = 0; // Default output\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    // Current and Next state variables\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) current_state <= A; // Reset to state A\n        else current_state <= next_state;\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        // Default output\n        out = 0;\n        case (current_state)\n            A: begin\n                next_state = in ? B : A;\n                out = 0;\n            end\n            B: begin\n                next_state = in ? B : C;\n                out = 0;\n            end\n            C: begin\n                next_state = in ? D : A;\n                out = 0;\n            end\n            D: begin\n                next_state = in ? B : C;\n                out = 1; // Only state D has an output of 1\n            end\n            default: next_state = A; // Default case to handle unknown states\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    // State variables\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A; // Reset state\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default case to handle unknown states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg out\n);\n\n// State encoding\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n// State registers\nreg [1:0] current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) current_state <= A; // Synchronous reset to state A\n    else current_state <= next_state;\nend\n\n// Next state logic based on current state and input\nalways @(*) begin\n    case (current_state)\n        A: next_state = (in == 0) ? A : B;\n        B: next_state = (in == 0) ? C : B;\n        C: next_state = (in == 0) ? A : D;\n        D: next_state = (in == 0) ? C : B;\n        default: next_state = A; // Default case to handle unknown states\n    endcase\nend\n\n// Output logic - only dependent on current state in a Moore machine\nalways @(*) begin\n    case (current_state)\n        A: out = 0;\n        B: out = 0;\n        C: out = 0;\n        D: out = 1;\n        default: out = 0; // Default case to ensure output is defined\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n// State declaration\ntypedef enum reg[1:0] {\n    A = 2'b00,\n    B = 2'b01,\n    C = 2'b10,\n    D = 2'b11\n} state_t;\n\n// State variables\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        current_state <= A; // Reset to state A\n    else\n        current_state <= next_state;\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        A: next_state = in ? B : A;\n        B: next_state = in ? B : C;\n        C: next_state = in ? D : A;\n        D: next_state = in ? B : C;\n        default: next_state = A; // Default case\n    endcase\nend\n\n// Output logic\nalways @(*) begin\n    case (current_state)\n        A: out = 0;\n        B: out = 0;\n        C: out = 0;\n        D: out = 1;\n        default: out = 0; // Default case\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n// State encoding\ntypedef enum reg[1:0] {\n    STATE_A = 2'b00,\n    STATE_B = 2'b01,\n    STATE_C = 2'b10,\n    STATE_D = 2'b11\n} state_t;\n\n// State registers\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        current_state <= STATE_A;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        STATE_A: next_state = (in == 0) ? STATE_A : STATE_B;\n        STATE_B: next_state = (in == 0) ? STATE_C : STATE_B;\n        STATE_C: next_state = (in == 0) ? STATE_A : STATE_D;\n        STATE_D: next_state = (in == 0) ? STATE_C : STATE_B;\n        default: next_state = STATE_A;\n    endcase\nend\n\n// Output logic\nalways @(*) begin\n    case (current_state)\n        STATE_A: out = 0;\n        STATE_B: out = 0;\n        STATE_C: out = 0;\n        STATE_D: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n"]}
{"task_id": "review2015_fsmshift", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// Define state constants\nlocalparam S0 = 2'd0, // State where shift_ena is not asserted\n           S1 = 2'd1, // First cycle of shift_ena being high\n           S2 = 2'd2, // Second cycle of shift_ena being high\n           S3 = 2'd3; // Third cycle of shift_ena being high\n\n// State registers\nreg [1:0] current_state, next_state;\n\n// Sequential logic for state transitioning\nalways @(posedge clk) begin\n    if (reset) current_state <= S1; // If reset, go to S1\n    else current_state <= next_state; // Otherwise, transition to the next state\nend\n\n// Combinatorial logic for next state logic and output logic\nalways @(*) begin\n    // Default values\n    next_state = S0; \n    shift_ena = 1'b0;\n    \n    case (current_state)\n        S0: begin\n            // Wait here until reset is asserted\n            next_state = reset ? S1 : S0;\n        end\n        S1: begin\n            shift_ena = 1'b1; // Assert shift_ena\n            next_state = S2; // Move to next state\n        end\n        S2: begin\n            shift_ena = 1'b1; // Keep shift_ena asserted\n            next_state = S3; // Move to next state\n        end\n        S3: begin\n            shift_ena = 1'b1; // Keep shift_ena asserted for the 3rd cycle\n            next_state = S0; // Return to initial state\n        end\n        default: begin\n            next_state = S0; // Default case, should not occur\n        end\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\nreg [2:0] state; // State variable to count the 4 cycles\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // Reset the state and enable the shift register\n        state <= 3'b000;\n        shift_ena <= 1'b1;\n    end\n    else if (state < 3'b100) begin\n        // Increment the state if it's less than 4\n        state <= state + 1'b1;\n        shift_ena <= 1'b1;\n    end\n    else begin\n        // After 4 cycles, keep the shift register disabled\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// State definitions\nlocalparam S_IDLE = 2'b00,\n           S_COUNT = 2'b01,\n           S_DONE = 2'b10;\n\n// State and count declaration\nreg [1:0] state, next_state;\nreg [2:0] count;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= S_IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        S_IDLE: next_state = reset ? S_IDLE : S_COUNT;\n        S_COUNT: next_state = (count == 3) ? S_DONE : S_COUNT;\n        S_DONE: next_state = S_DONE;\n        default: next_state = S_IDLE;\n    endcase\nend\n\n// Count logic\nalways @(posedge clk) begin\n    if (state == S_COUNT) begin\n        if (count < 3) begin\n            count <= count + 1;\n        end else begin\n            count <= count;\n        end\n    end else begin\n        count <= 0;\n    end\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 0;\n    end else begin\n        shift_ena <= (state == S_COUNT);\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// State encoding\nlocalparam S0 = 2'b00, // State where shift_ena is not active\n           S1 = 2'b01, // State where shift_ena will be active for 1st cycle\n           S2 = 2'b10, // State where shift_ena will be active for 2nd cycle\n           S3 = 2'b11; // State where shift_ena will be active for 3rd and 4th cycles\n\nreg [1:0] current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if(reset) begin\n        current_state <= S1; // Move to S1 state upon reset\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case(current_state)\n        S0: next_state = S0; // Stay in S0 unless reset\n        S1: next_state = S2; // Transition to S2 after 1 cycle\n        S2: next_state = S3; // Transition to S3 after 2 cycles\n        S3: next_state = S0; // Transition to S0 after 4 cycles\n        default: next_state = S0; // Default case to handle unknown states\n    endcase\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if(reset) begin\n        shift_ena <= 1'b1; // Enable shift_ena upon reset\n    end else begin\n        // Enable shift_ena for 4 cycles after reset\n        case(current_state)\n            S1, S2, S3: shift_ena <= 1'b1;\n            default: shift_ena <= 1'b0;\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\nlocalparam S_IDLE = 2'b00,\n           S_COUNT1 = 2'b01,\n           S_COUNT2 = 2'b10,\n           S_COUNT3 = 2'b11;\n\nreg [1:0] current_state, next_state;\n\n// State transition\nalways @(posedge clk) begin\n    if (reset)\n        current_state <= S_IDLE;\n    else\n        current_state <= next_state;\nend\n\n// Next state logic and output logic\nalways @(*) begin\n    case (current_state)\n        S_IDLE: begin\n            if (reset) begin\n                next_state = S_COUNT1;\n                shift_ena = 1;\n            end else begin\n                next_state = S_IDLE;\n                shift_ena = 0;\n            end\n        end\n        S_COUNT1: begin\n            next_state = S_COUNT2;\n            shift_ena = 1;\n        end\n        S_COUNT2: begin\n            next_state = S_COUNT3;\n            shift_ena = 1;\n        end\n        S_COUNT3: begin\n            next_state = S_IDLE;\n            shift_ena = 1;\n        end\n        default: begin\n            next_state = S_IDLE;\n            shift_ena = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// State encoding\nlocalparam S_WAIT = 2'b00, // Wait for reset or counting\n           S_COUNT = 2'b01; // Count 4 clock cycles\n\n// State and counter declaration\nreg [1:0] state = S_WAIT;\nreg [2:0] counter = 3'd0; // 3-bit counter to count up to 4\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // When reset is high, move to S_COUNT state and reset counter\n        state <= S_COUNT;\n        counter <= 3'd0;\n        shift_ena <= 1'b1;\n    end else begin\n        case (state)\n            S_WAIT: begin\n                // In wait state, keep shift_ena low\n                shift_ena <= 1'b0;\n            end\n            S_COUNT: begin\n                if (counter < 3'd4) begin\n                    // Increment counter until it reaches 4\n                    counter <= counter + 3'd1;\n                    shift_ena <= 1'b1; // Enable shifting\n                end else begin\n                    // After 4 cycles, go back to wait state and disable shift\n                    state <= S_WAIT;\n                    shift_ena <= 1'b0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\nreg [2:0] state; // State to keep track of the 4 cycles\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // Reset condition - initializing states\n        shift_ena <= 1'b1; // Enable shift register for 4 cycles\n        state <= 3'b100; // Set state to track 4 cycles\n    end\n    else begin\n        if (state != 3'b000) begin\n            // If state is not 000, we are in the 4 cycle window\n            shift_ena <= 1'b1;\n            state <= state - 3'b001; // Decrement state to eventually reach 000\n        end\n        else begin\n            // Once state is 000, shift_ena is 0 forever until reset\n            shift_ena <= 1'b0;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// State Declaration\ntypedef enum int {IDLE, ENABLE1, ENABLE2, ENABLE3, ENABLE4} state_t;\nstate_t current_state, next_state;\n\n// State Transition Logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= IDLE;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next State Logic\nalways @(*) begin\n    case (current_state)\n        IDLE: next_state = ENABLE1;\n        ENABLE1: next_state = ENABLE2;\n        ENABLE2: next_state = ENABLE3;\n        ENABLE3: next_state = ENABLE4;\n        ENABLE4: next_state = IDLE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output Logic\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b0;\n    end else begin\n        case (current_state)\n            ENABLE1, ENABLE2, ENABLE3, ENABLE4: shift_ena <= 1'b1;\n            default: shift_ena <= 1'b0;\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// State definitions\nlocalparam S0 = 2'b00; // Initial state\nlocalparam S1 = 2'b01; // Count state\nlocalparam S2 = 2'b10; // Last state to keep shift_ena high before turning it off\n\n// Signal declaration\nreg [1:0] current_state, next_state;\nreg [2:0] counter; // 3-bit counter to count up to 4 cycles\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: begin\n            if (reset) next_state = S1;\n            else next_state = S0;\n        end\n        S1: begin\n            if (counter == 3'b100) next_state = S2; // move to S2 after 4 cycles\n            else next_state = S1;\n        end\n        S2: begin\n            next_state = S2; // Stay in S2 until reset\n        end\n        default: next_state = S0;\n    endcase\nend\n\n// Counter and shift_ena logic\nalways @(posedge clk) begin\n    if (current_state == S0) begin\n        shift_ena <= 1'b0;\n        counter <= 3'b000;\n    end else if (current_state == S1) begin\n        shift_ena <= 1'b1;\n        counter <= counter + 3'b001;\n    end else if (current_state == S2) begin\n        shift_ena <= 1'b0; // Ensure shift_ena is turned off in S2\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\nreg [2:0] state; // Using a 3-bit vector to count up to 4 clock cycles\n\n// State encoding\nlocalparam S0 = 3'b000, // Initial state or when reset\n           S1 = 3'b001, // Count state 1\n           S2 = 3'b010, // Count state 2\n           S3 = 3'b011, // Count state 3\n           S4 = 3'b100; // Count state 4, last state where shift_ena is high\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // If reset is high, go back to initial state\n        state <= S0;\n    end else begin\n        case (state)\n            S0: begin\n                state <= S1; // Move to count state 1\n                shift_ena <= 1'b1; // Enable shift register\n            end\n            S1: begin\n                state <= S2; // Move to count state 2\n                shift_ena <= 1'b1; // Keep shift register enabled\n            end\n            S2: begin\n                state <= S3; // Move to count state 3\n                shift_ena <= 1'b1; // Keep shift register enabled\n            end\n            S3: begin\n                state <= S4; // Move to count state 4\n                shift_ena <= 1'b1; // Keep shift register enabled for the last time\n            end\n            S4: begin\n                // Do not change state, remain in S4\n                shift_ena <= 1'b0; // Disable shift register\n            end\n            default: begin\n                state <= S0; // Go to initial state for any undefined state\n                shift_ena <= 1'b0; // Ensure shift register is disabled\n            end\n        endcase\n    end\nend\n\nendmodule\n"]}
{"task_id": "conwaylife", "gptgen_RTL": ["module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\ninteger i, j;\nreg [2:0] neighbours;\nwire [255:0] next_state;\n\nalways @(posedge clk) begin\n    if (load) q <= data;\n    else q <= next_state;\nend\n\n// Calculate next state based on the current state\ngenerate\n    genvar x, y;\n    for (x = 0; x < 16; x = x + 1) begin: row\n        for (y = 0; y < 16; y = y + 1) begin: col\n            assign next_state[x*16+y] = next_state_logic(x, y);\n        end\n    end\nendgenerate\n\n// Logic to calculate the next state of a cell\nfunction next_state_logic(input [3:0] x, input [3:0] y);\n    integer nx, ny;\n    begin\n        neighbours = 0;\n        // Count neighbours, considering wrap around (toroid)\n        for (i = -1; i <= 1; i = i + 1) begin\n            for (j = -1; j <= 1; j = j + 1) begin\n                if (!(i == 0 && j == 0)) begin\n                    nx = (x + i + 16) % 16; // Wrap X\n                    ny = (y + j + 16) % 16; // Wrap Y\n                    neighbours = neighbours + q[nx*16+ny];\n                end\n            end\n        end\n        // Game logic\n        case(neighbours)\n            3'd0, 3'd1: next_state_logic = 1'b0; // 0-1 neighbour\n            3'd2: next_state_logic = q[x*16+y]; // 2 neighbours, no change\n            3'd3: next_state_logic = 1'b1; // 3 neighbours\n            default: next_state_logic = 1'b0; // 4+ neighbours\n        endcase\n    end\nendfunction\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n    integer i, j;\n    reg [7:0] neighbour_count;\n    wire [255:0] next_state;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    neighbour_count = q[{(i-1)&4'hF, (j+1)&4'hF}] + q[{i, (j+1)&4'hF}] + q[{(i+1)&4'hF, (j+1)&4'hF}] +\n                                      q[{(i-1)&4'hF, j}] +                                              q[{(i+1)&4'hF, j}] +\n                                      q[{(i-1)&4'hF, (j-1)&4'hF}] + q[{i, (j-1)&4'hF}] + q[{(i+1)&4'hF, (j-1)&4'hF}];\n                                      \n                    next_state[i*16+j] = (neighbour_count == 2) ? q[i*16+j] : \n                                         (neighbour_count == 3) ? 1'b1 : 1'b0;\n                end\n            end\n            q <= next_state;\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\ninteger i, j;\nreg [2:0] row_above, row_below, row;\nwire [7:0] neighbors;\nreg [255:0] next_q;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                // Determine rows considering the toroidal wraparound\n                row_above = (i == 0) ? q[240 + j*16 +: 3] : q[(i-1)*16 + j*16 +: 3];\n                row_below = (i == 15) ? q[j*16 +: 3] : q[(i+1)*16 + j*16 +: 3];\n                row = q[i*16 + j*16 +: 3];\n                \n                // Calculating neighbors, including wraparound considerations\n                neighbors = {row_above[2], row_above[1], row_above[0], row[0], row[2], row_below[2], row_below[1], row_below[0]};\n                \n                // Game rules\n                case (neighbors)\n                    8'b00000000, 8'b00000001: next_q[i*16 + j] = 0;\n                    8'b00000110, 8'b00000100: next_q[i*16 + j] = q[i*16 + j];\n                    8'b00000111: next_q[i*16 + j] = 1;\n                    default: next_q[i*16 + j] = 0;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\ninteger i, j;\nreg [7:0] neighbour_count;\nwire [255:0] next_q;\n\n// Function to calculate the neighbor count\nfunction automatic [7:0] calculate_neighbors;\n    input [7:0] row;\n    input [7:0] col;\n    integer r, c;\n    begin\n        calculate_neighbors = 0;\n        for (r = -1; r <= 1; r = r + 1) begin\n            for (c = -1; c <= 1; c = c + 1) begin\n                if (!(r == 0 && c == 0)) begin\n                    calculate_neighbors = calculate_neighbors + \n                        q[(((row + r + 16) % 16) * 16) + ((col + c + 16) % 16)];\n                end\n            end\n        end\n    end\nendfunction\n\n// Generate the next state based on the current state and the rules\nassign next_q = q; // Initialize next_q\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbour_count = calculate_neighbors(i, j);\n                \n                // Apply the game rules\n                case (neighbour_count)\n                    0, 1: next_q[(i*16) + j] <= 0;\n                    3: next_q[(i*16) + j] <= 1;\n                    4, 5, 6, 7, 8: next_q[(i*16) + j] <= 0;\n                    default: next_q[(i*16) + j] <= q[(i*16) + j]; // 2 Neighbors, do not change\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    // Temporary register to hold next state\n    reg [255:0] next_state;\n\n    // Function to calculate number of alive neighbors\n    function [3:0] count_neighbors;\n        input [7:0] x, y;\n        reg [7:0] nx, ny;\n        integer i, j;\n        begin\n            count_neighbors = 0;\n            for (i = -1; i <= 1; i = i + 1) begin\n                for (j = -1; j <= 1; j = j + 1) begin\n                    if (!(i == 0 && j == 0)) begin\n                        // Handle wrapping\n                        nx = (x + i + 16) % 16;\n                        ny = (y + j + 16) % 16;\n                        count_neighbors = count_neighbors + q[nx*16+ny];\n                    end\n                end\n            end\n        end\n    endfunction\n\n    integer x, y;\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            for (x = 0; x < 16; x = x + 1) begin\n                for (y = 0; y < 16; y = y + 1) begin\n                    case (count_neighbors(x, y))\n                        0, 1: next_state[x*16 + y] = 0;\n                        3: next_state[x*16 + y] = 1;\n                        2: next_state[x*16 + y] = q[x*16 + y];\n                        default: next_state[x*16 + y] = 0;\n                    endcase\n                end\n            end\n            q <= next_state;\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\ninteger i, j;\nreg [7:0] neighbours;\nreg [255:0] next_q;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbours = q[{(i-1)&15, (j-1)&15}] + q[{(i-1)&15, j}] + q[{(i-1)&15, (j+1)&15}] +\n                             q[{i, (j-1)&15}] +                                    q[{i, (j+1)&15}] +\n                             q[{(i+1)&15, (j-1)&15}] + q[{(i+1)&15, j}] + q[{(i+1)&15, (j+1)&15}];\n                \n                case (neighbours)\n                    0, 1: next_q[i*16+j] = 0;\n                    2: next_q[i*16+j] = q[i*16+j];\n                    3: next_q[i*16+j] = 1;\n                    default: next_q[i*16+j] = 0;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    integer i, j;\n    wire [255:0] next_state;\n    reg [7:0] neighbors;\n\n    // Function to calculate the next state of a cell\n    function automatic [0:0] next_cell_state;\n        input [7:0] neighbors;\n        input [0:0] current_state;\n        begin\n            case (neighbors)\n                0, 1: next_cell_state = 0;\n                2: next_cell_state = current_state;\n                3: next_cell_state = 1;\n                default: next_cell_state = 0;\n            endcase\n        end\n    endfunction\n\n    // Generate the next state for each cell\n    generate\n        for (i = 0; i < 16; i = i + 1) begin : row\n            for (j = 0; j < 16; j = j + 1) begin : col\n                // Calculate the position of each neighbor, taking into account the toroid behavior\n                wire [3:0] north = (i == 0) ? 15 : i - 1;\n                wire [3:0] south = (i == 15) ? 0 : i + 1;\n                wire [3:0] west = (j == 0) ? 15 : j - 1;\n                wire [3:0] east = (j == 15) ? 0 : j + 1;\n\n                // Count the number of alive neighbors\n                always @(*) begin\n                    neighbors = q[north*16+west] + q[north*16+j] + q[north*16+east] +\n                                q[i*16+west] /*current cell*/ + q[i*16+east] +\n                                q[south*16+west] + q[south*16+j] + q[south*16+east];\n\n                    // Subtract the current cell value since it was included in the count\n                    neighbors = neighbors - q[i*16+j];\n                end\n\n                // Determine the next state for each cell\n                assign next_state[i*16+j] = next_cell_state(neighbors, q[i*16+j]);\n            end\n        end\n    endgenerate\n\n    // Load new state or update the game state at each clock cycle\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_state;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    integer i, j;\n    reg [2:0] neighbour_count;\n    wire [255:0] next_q;\n    \n    // Function to calculate the 1D index from a 2D coordinate, with wrapping\n    function integer index_wrap;\n        input integer x, y;\n        begin\n            // Wrap coordinates around the edges\n            x = (x + 16) % 16;\n            y = (y + 16) % 16;\n            index_wrap = y * 16 + x;\n        end\n    endfunction\n\n    // Calculate the next state of each cell\n    generate\n        genvar idx;\n        for (idx = 0; idx < 256; idx = idx + 1) begin : cell_update\n            always @(*) begin\n                integer x, y;\n                x = idx % 16; // Extract x-coordinate\n                y = idx / 16; // Extract y-coordinate\n\n                // Count neighbours\n                neighbour_count = q[index_wrap(x-1, y-1)] + q[index_wrap(x, y-1)] + q[index_wrap(x+1, y-1)] +\n                                  q[index_wrap(x-1, y  )] +                          q[index_wrap(x+1, y  )] +\n                                  q[index_wrap(x-1, y+1)] + q[index_wrap(x, y+1)] + q[index_wrap(x+1, y+1)];\n\n                // Apply game rules\n                case(neighbour_count)\n                    3'b000, 3'b001: next_q[idx] = 1'b0; // Rule 1\n                    3'b010: next_q[idx] = q[idx];       // Rule 2\n                    3'b011: next_q[idx] = 1'b1;         // Rule 3\n                    default: next_q[idx] = 1'b0;        // Rule 4\n                endcase\n            end\n        end\n    endgenerate\n\n    // Load initial state or update state on each clock cycle\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\ninteger i, j;\nreg [7:0] neighbours;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end\n    else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbours = q[{(i-1)%16, (j+1)%16}] + q[{i%16, (j+1)%16}] + q[{(i+1)%16, (j+1)%16}]\n                            + q[{(i-1)%16, j%16}]                                     + q[{(i+1)%16, j%16}]\n                            + q[{(i-1)%16, (j-1)%16}] + q[{i%16, (j-1)%16}] + q[{(i+1)%16, (j-1)%16}];\n                \n                case (neighbours)\n                    0, 1: q[i*16 + j] <= 0;\n                    2: q[i*16 + j] <= q[i*16 + j];\n                    3: q[i*16 + j] <= 1;\n                    default: q[i*16 + j] <= 0;\n                endcase\n            end\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\ninteger i, j;\nreg [3:0] neighbours;\nwire [255:0] next_q;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbours = q[((i+15)%16)*16 + ((j+15)%16)] + q[((i+15)%16)*16 + (j)] + q[((i+15)%16)*16 + ((j+1)%16)]\n                            + q[(i)*16 + ((j+15)%16)]                                   + q[(i)*16 + ((j+1)%16)]\n                            + q[((i+1)%16)*16 + ((j+15)%16)] + q[((i+1)%16)*16 + (j)] + q[((i+1)%16)*16 + ((j+1)%16)];\n\n                case (neighbours)\n                    0, 1: next_q[i*16 + j] = 0;\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1;\n                    default: next_q[i*16 + j] = 0;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\n\nendmodule\n"]}
{"task_id": "m2014_q4d", "gptgen_RTL": ["module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\nlogic xor_out;\n\n// XOR operation\nassign xor_out = in ^ out;\n\n// D flip-flop without reset\nalways @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\nlogic xor_result;\n\n// XOR operation\nassign xor_result = in ^ out;\n\n// D Flip-Flop\nalways @(posedge clk) begin\n    out <= xor_result;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\nwire xor_result;\n\n// XOR operation before D flip-flop\nassign xor_result = in ^ out;\n\n// D flip-flop without reset, positive edge triggered\nalways @(posedge clk) begin\n    out <= xor_result;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n// Intermediate signal for XOR output\nlogic xor_out;\n\n// XOR operation\nassign xor_out = in ^ out;\n\n// D flip-flop, positive edge triggered, no reset\nalways @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\nreg temp;\n\nalways @(posedge clk) begin\n    temp <= in ^ out;\nend\n\nassign out = temp;\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n    wire xor_out;\n\n    // XOR operation\n    assign xor_out = in ^ out;\n\n    // D flip-flop without reset, positive edge triggered\n    always @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\nreg temp_out;\n\nalways @(posedge clk) begin\n    temp_out <= in ^ out;\nend\n\nassign out = temp_out;\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n// Intermediate signal for XOR output\nlogic xor_out;\n\n// XOR operation\nassign xor_out = in ^ out;\n\n// D flip-flop (No reset)\nalways_ff @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n// Intermediate signal for the output of the XOR gate\nlogic xor_out;\n\n// XOR operation\nassign xor_out = in ^ out;\n\n// D flip-flop with positive edge trigger, no reset\nalways @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n// Intermediate wire to hold the result of the XOR operation\nwire xor_result;\n\n// XOR operation between 'in' and the flip-flop output 'out'\nassign xor_result = in ^ out;\n\n// D flip-flop, no reset, positive edge triggered by clk\nalways @(posedge clk) begin\n    out <= xor_result;\nend\n\nendmodule\n"]}
{"task_id": "shift18", "gptgen_RTL": ["module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end\n    else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1; // shift left by 1\n            2'b01: q <= q << 8; // shift left by 8\n            2'b10: q <= {q[63], q[63:1]}; // arithmetic shift right by 1\n            2'b11: q <= {{8{q[63]}}, q[63:8]}; // arithmetic shift right by 8\n        endcase\n    end\nend\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n    );\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1; // Shift left by 1\n                2'b01: q <= q << 8; // Shift left by 8\n                2'b10: q <= $signed(q) >>> 1; // Arithmetic right shift by 1\n                2'b11: q <= $signed(q) >>> 8; // Arithmetic right shift by 8\n            endcase\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into the shift register\n            q <= data;\n        end\n        else if (ena) begin\n            // Perform shifting based on the amount\n            case (amount)\n                2'b00: begin // Shift left by 1\n                    q <= q << 1;\n                end\n                2'b01: begin // Shift left by 8\n                    q <= q << 8;\n                end\n                2'b10: begin // Shift right by 1, arithmetic shift\n                    q <= $signed(q) >>> 1;\n                end\n                2'b11: begin // Shift right by 8, arithmetic shift\n                    q <= $signed(q) >>> 8;\n                end\n                default: begin\n                    // Do nothing for undefined operation\n                end\n            endcase\n        end\n        // If neither load nor ena is active, retain the current value\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load the data into the shift register.\n        q <= data;\n    end else if (ena) begin\n        // Shift or rotate based on the value of amount.\n        case (amount)\n            2'b00: begin\n                // Shift left by 1 bit.\n                q <= q << 1;\n            end\n            2'b01: begin\n                // Shift left by 8 bits.\n                q <= q << 8;\n            end\n            2'b10: begin\n                // Arithmetic shift right by 1 bit.\n                // Replicate the MSB (most significant bit) to keep the sign.\n                q <= {q[63], q[63:1]};\n            end\n            2'b11: begin\n                // Arithmetic shift right by 8 bits.\n                // Replicate the MSB (most significant bit) 8 times to keep the sign.\n                q <= { {8{q[63]}}, q[63:8]};\n            end\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\nalways @(posedge clk) begin\n    if(load) begin\n        // Load the data into the shift register\n        q <= data;\n    end\n    else if(ena) begin\n        // Shift based on the amount\n        case(amount)\n            2'b00: q <= q << 1;  // Shift left by 1\n            2'b01: q <= q << 8;  // Shift left by 8\n            2'b10: q <= $signed(q) >>> 1;  // Arithmetic shift right by 1\n            2'b11: q <= $signed(q) >>> 8;  // Arithmetic shift right by 8\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend else if (ena) begin\n\t\tcase (amount)\n\t\t\t2'b00: q <= q << 1; // Shift left by 1\n\t\t\t2'b01: q <= q << 8; // Shift left by 8\n\t\t\t2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8\n\t\tendcase\n\tend\nend\n\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data; // Load data into shift register\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1; // Shift left by 1\n                2'b01: q <= q << 8; // Shift left by 8\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load the data into the shift register\n        q <= data;\n    end\n    else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1; // Shift left by 1\n            2'b01: q <= q << 8; // Shift left by 8\n            2'b10: q <= {{q[63]}, q[63:1]}; // Arithmetic shift right by 1\n            2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1; // Shift left by 1\n                2'b01: q <= q << 8; // Shift left by 8\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8\n            endcase\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end\n    else if (ena) begin\n        case(amount)\n        2'b00: q <= q << 1; // shift left by 1\n        2'b01: q <= q << 8; // shift left by 8\n        2'b10: q <= $signed(q) >>> 1; // arithmetic shift right by 1\n        2'b11: q <= $signed(q) >>> 8; // arithmetic shift right by 8\n        endcase\n    end\nend\n\nendmodule\n"]}
{"task_id": "review2015_fsmseq", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State encoding\ntypedef enum reg[2:0] {\n    S0 = 3'b000, // Looking for first '1'\n    S1 = 3'b001, // Found first '1', looking for second '1'\n    S2 = 3'b010, // Found two '1's, looking for '0'\n    S3 = 3'b011, // Found \"110\", looking for '1'\n    S4 = 3'b100  // Sequence 1101 found, start_shifting = 1\n} state_t;\n\n// State variables\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        current_state <= S0;\n    else\n        current_state <= next_state;\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: next_state = data ? S1 : S0; // If we see a '1', move to S1, else stay in S0\n        S1: next_state = data ? S2 : S0; // If we see another '1', move to S2, else back to S0\n        S2: next_state = data ? S1 : S3; // If we see a '1', back to S1 as it could be start of new sequence, else move to S3\n        S3: next_state = data ? S4 : S0; // If we see a '1', sequence complete, else back to S0\n        S4: next_state = S4; // Remain in this state once sequence is found\n        default: next_state = S0; // Default case\n    endcase\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if (reset)\n        start_shifting <= 1'b0;\n    else if (current_state == S4)\n        start_shifting <= 1'b1;\n    // Note: No need to handle else condition as we want to latch the output to 1 once in S4\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State encoding\ntypedef enum int {S0, S1, S2, S3, FOUND} state_t;\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n        start_shifting <= 0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: next_state = data ? S1 : S0;\n        S1: next_state = data ? S2 : S0;\n        S2: next_state = data ? S2 : S3;\n        S3: next_state = data ? S1 : S0;\n        FOUND: next_state = FOUND;\n        default: next_state = S0;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if (reset) begin\n        start_shifting <= 0;\n    end else if (current_state == S3 && data) begin\n        start_shifting <= 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State Definitions\nlocalparam [2:0] S0 = 3'd0, // Initial State\n                 S1 = 3'd1, // Detected 1\n                 S2 = 3'd2, // Detected 11\n                 S3 = 3'd3, // Detected 110\n                 S4 = 3'd4; // Detected 1101, Start shifting\n\n// State Register\nreg [2:0] current_state, next_state;\n\n// State Transition Logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n        start_shifting <= 1'b0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next State Logic\nalways @(*) begin\n    case (current_state)\n        S0: begin\n            if (data == 1'b1) \n                next_state = S1;\n            else\n                next_state = S0;\n        end\n        S1: begin\n            if (data == 1'b1) \n                next_state = S2;\n            else\n                next_state = S0;\n        end\n        S2: begin\n            if (data == 1'b0) \n                next_state = S3;\n            else\n                next_state = S2; // Stay in S2 if another 1 is detected\n        end\n        S3: begin\n            if (data == 1'b1) begin\n                next_state = S4;\n                start_shifting = 1'b1; // Sequence detected, start shifting\n            end else\n                next_state = S0;\n        end\n        S4: begin\n            // Once in S4, stay here indefinitely until reset\n            next_state = S4;\n            start_shifting = 1'b1;\n        end\n        default: next_state = S0; // Default to S0 for any undefined states\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State encoding\ntypedef enum {S0, S1, S10, S110, S1101} state_t;\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic based on current_state and data input\nalways @(*) begin\n    case (current_state)\n        S0: next_state = data ? S1 : S0;\n        S1: next_state = data ? S10 : S0;\n        S10: next_state = data ? S110 : S0;\n        S110: next_state = data ? S10 : S1101;\n        S1101: next_state = S1101; // Stay in this state once 1101 is detected\n        default: next_state = S0;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if (reset) begin\n        start_shifting <= 1'b0;\n    end else if (current_state == S110 && data == 1'b1) begin\n        start_shifting <= 1'b1; // Sequence 1101 detected\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State declaration\ntypedef enum int {\n    S0, // Initial state, looking for '1'\n    S1, // Found '1', looking for another '1'\n    S2, // Found \"11\", looking for '0'\n    S3  // Found \"110\", looking for '1' to complete \"1101\"\n} state_t;\n\n// State register\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n        start_shifting <= 1'b0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: next_state = data ? S1 : S0;\n        S1: next_state = data ? S2 : S0;\n        S2: next_state = data ? S1 : S3;\n        S3: if (data) begin\n                start_shifting = 1'b1;\n                next_state = S1;\n            end else begin\n                next_state = S0;\n            end\n        default: next_state = S0;\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting);\n\n    reg [2:0] state, next_state;\n\n    // State encoding\n    localparam  S0 = 3'b000, // Looking for '1'\n                S1 = 3'b001, // 1 found, looking for first '1' in \"11\"\n                S2 = 3'b010, // \"11\" found, looking for '0'\n                S3 = 3'b011, // \"110\" found, looking for '1'\n                FOUND = 3'b100; // \"1101\" sequence found\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S1 : S3;\n            S3: next_state = data ? FOUND : S0;\n            FOUND: next_state = FOUND;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 0;\n        else if (state == FOUND)\n            start_shifting <= 1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State encoding\ntypedef enum int {S0, S1, S2, S3, FOUND} state_t;\nstate_t current_state, next_state;\n\n// FSM Logic - State transition\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// FSM Logic - Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: next_state = data ? S1 : S0;\n        S1: next_state = data ? S2 : S0;\n        S2: next_state = data ? S2 : S3;\n        S3: next_state = data ? S1 : S0;\n        FOUND: next_state = FOUND;\n        default: next_state = S0;\n    endcase\nend\n\n// FSM Logic - Output logic\nalways @(posedge clk) begin\n    if (reset) begin\n        start_shifting <= 0;\n    end else begin\n        if (current_state == S3 && data) begin\n            start_shifting <= 1;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // State encoding\n    typedef enum int {S0, S1, S2, S3, FOUND} state_t;\n    state_t current_state, next_state;\n\n    // State Transition\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= S0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        // Default assignment\n        next_state = current_state;\n        \n        case (current_state)\n            S0: begin\n                if (data) next_state = S1;\n            end\n            S1: begin\n                if (data) next_state = S2;\n                else next_state = S0;\n            end\n            S2: begin\n                if (!data) next_state = S3;\n                // Stay in S2 if data is 1\n            end\n            S3: begin\n                if (data) next_state = FOUND;\n                else next_state = S0;  // Reset to S0 if sequence is broken\n            end\n            FOUND: begin\n                // Stay in FOUND state indefinitely until reset\n                next_state = FOUND;\n            end\n            default: next_state = S0;  // Default to S0 for any undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            start_shifting <= 0;\n        end else if (current_state == FOUND) begin\n            start_shifting <= 1;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State encoding\ntypedef enum int {S0, S1, S2, S3, FOUND} state_t;\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n        start_shifting <= 0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic based on current state and input data\nalways @(*) begin\n    case (current_state)\n        S0: next_state = (data == 1'b1) ? S1 : S0;\n        S1: next_state = (data == 1'b1) ? S2 : S0;\n        S2: next_state = (data == 1'b0) ? S3 : S2;\n        S3: next_state = (data == 1'b1) ? FOUND : S0;\n        FOUND: begin\n            next_state = FOUND;\n            start_shifting = 1;\n        end\n        default: next_state = S0;\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // State encoding\n    localparam S0 = 2'b00;\n    localparam S1 = 2'b01;\n    localparam S2 = 2'b10;\n    localparam S3 = 2'b11;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // Next state logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= S0;\n            start_shifting <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (data == 1'b1) \n                    next_state = S1;\n                else \n                    next_state = S0;\n                start_shifting = 0;\n            end\n            S1: begin\n                if (data == 1'b1) \n                    next_state = S2;\n                else \n                    next_state = S0;\n                start_shifting = 0;\n            end\n            S2: begin\n                if (data == 1'b0) \n                    next_state = S3;\n                else \n                    next_state = S2; // Stay in S2 if another '1' is received\n                start_shifting = 0;\n            end\n            S3: begin\n                if (data == 1'b1) begin\n                    next_state = S3; // Once 1101 is detected, remain in S3\n                    start_shifting = 1;\n                end else \n                    next_state = S0;\n            end\n            default: begin\n                next_state = S0; // Default state\n                start_shifting = 0;\n            end\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "m2014_q4b", "gptgen_RTL": ["module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n\tif (ar)\n\t\tq <= 1'b0;\n\telse\n\t\tq <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n\tif (ar)\n\t\tq <= 1'b0;\n\telse\n\t\tq <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\n    always @(posedge clk or posedge ar)\n    begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\nalways @(posedge clk or posedge ar)\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n\tif (ar)\n\t\tq <= 1'b0;\n\telse\n\t\tq <= d;\nend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n\tif (ar)\n\t\tq <= 1'b0;\n\telse\n\t\tq <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n"]}
{"task_id": "review2015_shiftcount", "gptgen_RTL": ["module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (shift_ena) begin\n        // Shift in the data most-significant-bit first\n        q <= {data, q[3:1]};\n    end\n    else if (count_ena) begin\n        // Decrement the number in the register\n        q <= q - 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n\n// Sequential logic with sensitivity to positive clock edges\nalways @(posedge clk) begin\n    if (shift_ena) begin\n        // Shift left operation: MSB is replaced by 'data', other bits are shifted left\n        q <= {data, q[3:1]};\n    end\n    else if (count_ena) begin\n        // Decrement operation: Subtract 1 from current value of q\n        q <= q - 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if(shift_ena) begin\n            // Shift in the data. MSB first.\n            q <= {data, q[3:1]};\n        end\n        else if(count_ena) begin\n            // Decrement the number in the shift register.\n            q <= q - 1;\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (shift_ena) begin\n        // Shift data in, MSB first\n        q <= {q[2:0], data};\n    end\n    else if (count_ena) begin\n        // Decrement the number in the shift register\n        q <= q - 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {data, q[3:1]}; // Shift in the data from MSB side\n        end\n        else if (count_ena) begin\n            q <= q - 1; // Decrement the value in the shift register\n        end\n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    // Temporary register to handle decrement\n    reg [3:0] temp;\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift data into q, MSB first\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            // Decrement current value in q\n            temp = q - 1;\n            q <= temp;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift in the data starting from MSB\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            // Decrement the value in the shift register\n            q <= q - 1;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n    \n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {data, q[3:1]};  // Shift in the data from MSB\n        end\n        else if (count_ena) begin\n            q <= q - 1;  // Decrement the value in the register\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n    );\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {data, q[3:1]}; // Shift in the data at MSB\n        end\n        else if (count_ena) begin\n            q <= q - 1; // Decrement the value\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if(shift_ena) begin\n        // Shift in the data most-significant-bit first\n        q <= {q[2:0], data};\n    end\n    else if(count_ena) begin\n        // Decrement the number in the shift register\n        q <= q - 1;\n    end\nend\n\nendmodule\n"]}
{"task_id": "dff8ar", "gptgen_RTL": ["module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if(areset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) q <= 8'b0;\n    else q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) \n        q <= 8'b0;\n    else \n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if(areset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule\n"]}
{"task_id": "lfsr32", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Reset q to 1 if reset is high\n        end else begin\n            // Perform the Galois LFSR operation\n            // XOR the taps: 32, 22, 2, and 1 (considering 1-based indexing)\n            q <= {q[30:0], (q[31] ^ q[21] ^ q[1] ^ q[0])};\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset q to 32'h1 on a high reset\n    end else begin\n        // Galois LFSR implementation\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset the output to 32'h1 on a high reset signal\n    end\n    else begin\n        // Perform the Galois LFSR operation\n        // XOR the tapped bits with the rightmost bit (bit 0) and shift the register\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset value\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]}; // Shift and XOR for Galois LFSR\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n    \n    wire feedback = q[31] ^ q[21] ^ q[1] ^ q[0]; // XOR taps at positions 32, 22, 2, and 1 (adjusting for 0-indexing)\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Reset q to 32'h1\n        end else begin\n            q <= {q[30:0], feedback}; // Shift left by 1, placing feedback in the LSB position\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // On reset, set q to 32'h1\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]}; // Shift left with taps at 32, 22, 2, and 1 XORed for the new bit\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset the LFSR to 32'h1 when reset is high.\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]}; // Shift left with feedback from the XOR of the tap positions.\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\n// On reset, set q to 32'h1, else shift and calculate new value based on taps\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset value\n    end \n    else begin\n        // Shift q and apply XOR for taps at positions 32, 22, 2, and 1\n        // Note: Verilog indexing starts at 0, so we adjust positions by 1\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule\n"]}
{"task_id": "2014_q4a", "gptgen_RTL": ["module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= R; // Load the register with R when L is asserted.\n    end\n    else if (E) begin\n        Q <= w; // Shift the register with w when E is asserted and L is not asserted.\n    end\nend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\nalways @(posedge clk) begin\n\tif (L) begin\n\t\tQ <= R;\n\tend else if (E) begin\n\t\tQ <= w;\n\tend\nend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\nalways @(posedge clk) begin\n\tif (L) Q <= R;\n\telse if (E) Q <= w;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L)  // Load the value R when L is asserted\n        Q <= R;\n    else if (E)  // Shift the value when E is asserted\n        Q <= w;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) \n        Q <= R; // Load the value of R into Q when L is asserted\n    else if (E) \n        Q <= w; // Shift the value when E is asserted, taking the input from w\n    // If neither L nor E are asserted, the value of Q remains unchanged\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) Q <= R; // Load the value R when L is asserted\n    else if (E) Q <= w; // Shift the value when E is asserted\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= R; // Load the value into Q when L is asserted\n    end\n    else if (E) begin\n        Q <= w; // Shift the value when E is asserted\n    end\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) // Load the value R when L is asserted.\n        Q <= R;\n    else if (E) // Enable shift operation.\n        Q <= w;\n    // If neither loading nor shifting, Q retains its value due to being a reg type.\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= R; // Load the value of R into Q when L is asserted\n        end\n        else if (E) begin\n            Q <= w; // Shift in the value of w when E is asserted and L is not\n        end\n    end\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= R; // Load the value of R into Q when L is asserted\n    end\n    else if (E) begin\n        Q <= w; // Otherwise, shift the value of w into Q when E is asserted\n    end\nend\n\nendmodule\n"]}
{"task_id": "alwaysblock2", "gptgen_RTL": ["module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using assign statement for XOR gate\nassign out_assign = a ^ b;\n\n// Using combinational always block for XOR gate\nalways @ (a or b) begin\n    out_always_comb = a ^ b;\nend\n\n// Using clocked always block for XOR gate with a flip-flop\nalways @ (posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using an assign statement\nassign out_assign = a ^ b;\n\n// Combinational always block\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\n// Clocked always block with flip-flop\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// XOR using an assign statement\nassign out_assign = a ^ b;\n\n// XOR using a combinational always block\nalways @ (a or b) begin\n    out_always_comb = a ^ b;\nend\n\n// XOR using a clocked always block with flip-flop\nalways @ (posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using assign statement for immediate XOR operation\nassign out_assign = a ^ b;\n\n// Using combinational always block for XOR operation\nalways @ (a or b)\nbegin\n    out_always_comb = a ^ b;\nend\n\n// Using clocked always block for XOR operation with flip-flop\n// This introduces a one-clock cycle delay\nalways @ (posedge clk)\nbegin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// XOR using assign statement\nassign out_assign = a ^ b;\n\n// XOR using combinational always block\nalways @ (a or b) begin\n    out_always_comb = a ^ b;\nend\n\n// XOR using clocked always block with flip-flop\nalways @ (posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using assign statement for XOR gate\nassign out_assign = a ^ b;\n\n// Using combinational always block for XOR gate\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\n// Using clocked always block for XOR gate with a flip-flop\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using an assign statement for XOR\nassign out_assign = a ^ b;\n\n// Using a combinational always block for XOR\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\n// Using a clocked always block for XOR with flip-flop\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using an assign statement for direct XOR operation\nassign out_assign = a ^ b;\n\n// Using a combinational always block\nalways @ (a or b) begin\n    out_always_comb = a ^ b;\nend\n\n// Using a clocked always block with a flip-flop\nalways @ (posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using an assign statement\nassign out_assign = a ^ b;\n\n// Using a combinational always block\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\n// Using a clocked always block with flip-flop\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n// Using an assign statement for immediate XOR operation\nassign out_assign = a ^ b;\n\n// Using a combinational always block for XOR operation\nalways @* begin\n    out_always_comb = a ^ b;\nend\n\n// Using a clocked always block with a flip-flop to produce a delayed XOR operation\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n"]}
{"task_id": "countbcd", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Enable signals for each BCD digit beyond the first\nassign ena[1] = (q[3:0] == 4'b1001); // Enable tens when ones is 9\nassign ena[2] = ena[1] && (q[7:4] == 4'b1001); // Enable hundreds when tens is 9 and ena[1] is high\nassign ena[3] = ena[2] && (q[11:8] == 4'b1001); // Enable thousands when hundreds is 9 and ena[2] is high\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 16'b0; // Reset the counter to 0\n    end else begin\n        if (q[3:0] == 4'b1001) begin // Ones digit\n            q[3:0] <= 4'b0; // Reset ones to 0\n            if (q[7:4] == 4'b1001) begin // Tens digit\n                q[7:4] <= 4'b0; // Reset tens to 0\n                if (q[11:8] == 4'b1001) begin // Hundreds digit\n                    q[11:8] <= 4'b0; // Reset hundreds to 0\n                    if (q[15:12] == 4'b1001) begin // Thousands digit\n                        q[15:12] <= 4'b0; // Reset thousands to 0 if it is 9\n                    end else begin\n                        q[15:12] <= q[15:12] + 1'b1; // Increment thousands\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1'b1; // Increment hundreds\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1'b1; // Increment tens\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1'b1; // Increment ones\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q\n);\n\n// Assign enable signals for each of the upper three digits\nassign ena[1] = (q[3:0] == 9) ? 1'b1 : 1'b0; // Enable tens when ones digit reaches 9\nassign ena[2] = (q[7:4] == 9) && ena[1] ? 1'b1 : 1'b0; // Enable hundreds when tens digit is 9 and ena[1] is high\nassign ena[3] = (q[11:8] == 9) && ena[2] ? 1'b1 : 1'b0; // Enable thousands when hundreds digit is 9 and ena[2] is high\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\t// Reset the counter\n\t\tq <= 16'd0;\n\tend else begin\n\t\t// Increment the ones digit\n\t\tif (q[3:0] < 9) begin\n\t\t\tq[3:0] <= q[3:0] + 1'b1;\n\t\tend else begin\n\t\t\tq[3:0] <= 4'd0; // Reset ones digit to 0 and check for tens digit\n\t\t\t// Increment the tens digit\n\t\t\tif (q[7:4] < 9) begin\n\t\t\t\tq[7:4] <= q[7:4] + 1'b1;\n\t\t\tend else begin\n\t\t\t\tq[7:4] <= 4'd0; // Reset tens digit to 0 and check for hundreds digit\n\t\t\t\t// Increment the hundreds digit\n\t\t\t\tif (q[11:8] < 9) begin\n\t\t\t\t\tq[11:8] <= q[11:8] + 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tq[11:8] <= 4'd0; // Reset hundreds digit to 0 and check for thousands digit\n\t\t\t\t\t// Increment the thousands digit\n\t\t\t\t\tif (q[15:12] < 9) begin\n\t\t\t\t\t\tq[15:12] <= q[15:12] + 1'b1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tq[15:12] <= 4'd0; // Reset thousands digit to 0, overflow case\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Enable signals for each digit\nassign ena[1] = (q[3:0] == 9);  // Enable tens when ones are 9\nassign ena[2] = (q[7:4] == 9) && ena[1]; // Enable hundreds when tens are 9 and ones are 9\nassign ena[3] = (q[11:8] == 9) && ena[2]; // Enable thousands when hundreds are 9 and tens are 9\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 16'b0; // Reset the counter\n    end else begin\n        // Increment ones\n        if (q[3:0] == 9) q[3:0] <= 0;\n        else q[3:0] <= q[3:0] + 1;\n        \n        // Increment tens\n        if (ena[1]) begin\n            if (q[7:4] == 9) q[7:4] <= 0;\n            else q[7:4] <= q[7:4] + 1;\n        end\n        \n        // Increment hundreds\n        if (ena[2]) begin\n            if (q[11:8] == 9) q[11:8] <= 0;\n            else q[11:8] <= q[11:8] + 1;\n        end\n        \n        // Increment thousands\n        if (ena[3]) begin\n            if (q[15:12] == 9) q[15:12] <= 0;\n            else q[15:12] <= q[15:12] + 1;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 16'd0;\n    end else begin\n        if (q[3:0] == 9) begin\n            q[3:0] <= 0;\n            if (q[7:4] == 9) begin\n                q[7:4] <= 0;\n                if (q[11:8] == 9) begin\n                    q[11:8] <= 0;\n                    if (q[15:12] == 9) begin\n                        q[15:12] <= 0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 9) ? 1'b1 : 1'b0;\nassign ena[2] = (q[3:0] == 9 && q[7:4] == 9) ? 1'b1 : 1'b0;\nassign ena[3] = (q[3:0] == 9 && q[7:4] == 9 && q[11:8] == 9) ? 1'b1 : 1'b0;\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q);\n\n    // Enable signals for tens, hundreds, and thousands\n    assign ena[1] = (q[3:0] == 9);  // Enable tens when ones is 9\n    assign ena[2] = ena[1] && (q[7:4] == 9);  // Enable hundreds when tens is 9 and ones is 9\n    assign ena[3] = ena[2] && (q[11:8] == 9);  // Enable thousands when hundreds is 9, tens is 9 and ones is 9\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 0;  // Reset the counter to 0\n        end\n        else begin\n            if (q[3:0] == 9) begin\n                q[3:0] <= 0;  // Reset ones to 0 if it was 9\n                if (q[7:4] == 9) begin\n                    q[7:4] <= 0;  // Reset tens to 0 if it was 9\n                    if (q[11:8] == 9) begin\n                        q[11:8] <= 0;  // Reset hundreds to 0 if it was 9\n                        if (q[15:12] == 9) begin\n                            q[15:12] <= 0;  // Reset thousands to 0 if it was 9 (roll over scenario)\n                        end else begin\n                            q[15:12] <= q[15:12] + 1;  // Increment thousands\n                        end\n                    end else begin\n                        q[11:8] <= q[11:8] + 1;  // Increment hundreds\n                    end\n                end else begin\n                    q[7:4] <= q[7:4] + 1;  // Increment tens\n                end\n            end else begin\n                q[3:0] <= q[3:0] + 1;  // Increment ones\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Enable logic for the tens, hundreds, and thousands digits\nassign ena[1] = (q[3:0] == 4'b1001); // Enable tens when ones is 9\nassign ena[2] = (q[7:4] == 4'b1001) & ena[1]; // Enable hundreds when tens is 9 and ones rolls over\nassign ena[3] = (q[11:8] == 4'b1001) & ena[2]; // Enable thousands when hundreds is 9 and tens rolls over\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        // Reset all digits to 0\n        q <= 16'b0; \n    end else begin\n        // Increment ones digit\n        if (q[3:0] == 4'b1001) q[3:0] <= 4'b0; // Reset to 0 if 9\n        else q[3:0] <= q[3:0] + 1;\n        \n        // Increment tens digit\n        if (ena[1]) begin\n            if (q[7:4] == 4'b1001) q[7:4] <= 4'b0; // Reset to 0 if 9\n            else q[7:4] <= q[7:4] + 1;\n        end\n\n        // Increment hundreds digit\n        if (ena[2]) begin\n            if (q[11:8] == 4'b1001) q[11:8] <= 4'b0; // Reset to 0 if 9\n            else q[11:8] <= q[11:8] + 1;\n        end\n\n        // Increment thousands digit\n        if (ena[3]) begin\n            if (q[15:12] == 4'b1001) q[15:12] <= 4'b0; // Reset to 0 if 9\n            else q[15:12] <= q[15:12] + 1;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Enable signals for the tens, hundreds, and thousands digits\nassign ena[1] = (q[3:0] == 9); // Enable tens when ones is 9\nassign ena[2] = ena[1] && (q[7:4] == 9); // Enable hundreds when tens is 9 and ones is about to reset\nassign ena[3] = ena[2] && (q[11:8] == 9); // Enable thousands when hundreds is 9 and tens is about to reset\n\n// Ones counter\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q[3:0] <= 0;\n    else if (q[3:0] == 9)\n        q[3:0] <= 0;\n    else\n        q[3:0] <= q[3:0] + 1;\nend\n\n// Tens counter\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q[7:4] <= 0;\n    else if (ena[1]) begin\n        if (q[7:4] == 9)\n            q[7:4] <= 0;\n        else\n            q[7:4] <= q[7:4] + 1;\n    end\nend\n\n// Hundreds counter\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q[11:8] <= 0;\n    else if (ena[2]) begin\n        if (q[11:8] == 9)\n            q[11:8] <= 0;\n        else\n            q[11:8] <= q[11:8] + 1;\n    end\nend\n\n// Thousands counter\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q[15:12] <= 0;\n    else if (ena[3]) begin\n        if (q[15:12] == 9)\n            q[15:12] <= 0;\n        else\n            q[15:12] <= q[15:12] + 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Increment the ones digit and generate enable for the tens digit\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q[3:0] <= 4'd0;\n    end else if (q[3:0] == 4'd9) begin\n        q[3:0] <= 4'd0;\n    end else begin\n        q[3:0] <= q[3:0] + 1'b1;\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9) ? 1'b1 : 1'b0;\n\n// Increment the tens digit and generate enable for the hundreds digit\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q[7:4] <= 4'd0;\n    end else if (ena[1] && q[7:4] == 4'd9) begin\n        q[7:4] <= 4'd0;\n    end else if (ena[1]) begin\n        q[7:4] <= q[7:4] + 1'b1;\n    end\nend\n\nassign ena[2] = (ena[1] && q[7:4] == 4'd9) ? 1'b1 : 1'b0;\n\n// Increment the hundreds digit and generate enable for the thousands digit\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q[11:8] <= 4'd0;\n    end else if (ena[2] && q[11:8] == 4'd9) begin\n        q[11:8] <= 4'd0;\n    end else if (ena[2]) begin\n        q[11:8] <= q[11:8] + 1'b1;\n    end\nend\n\nassign ena[3] = (ena[2] && q[11:8] == 4'd9) ? 1'b1 : 1'b0;\n\n// Increment the thousands digit\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q[15:12] <= 4'd0;\n    end else if (ena[3] && q[15:12] == 4'd9) begin\n        q[15:12] <= 4'd0;\n    end else if (ena[3]) begin\n        q[15:12] <= q[15:12] + 1'b1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        // Increment the ones digit\n        if (q[3:0] == 4'b1001) begin // If ones digit is 9, reset it to 0 and enable tens increment\n            q[3:0] <= 4'b0000;\n            q[7:4] <= q[7:4] + 1'b1; // Increment tens\n        end else begin\n            q[3:0] <= q[3:0] + 1'b1; // Increment ones\n        end\n        \n        // Check for tens carry and increment hundreds\n        if (q[7:4] == 4'b1010) begin // If tens digit reaches 10, reset it to 0 and enable hundreds increment\n            q[7:4] <= 4'b0000;\n            q[11:8] <= q[11:8] + 1'b1; // Increment hundreds\n        end\n        \n        // Check for hundreds carry and increment thousands\n        if (q[11:8] == 4'b1010) begin // If hundreds digit reaches 10, reset it to 0 and enable thousands increment\n            q[11:8] <= 4'b0000;\n            q[15:12] <= q[15:12] + 1'b1; // Increment thousands\n        end\n        \n        // Check for thousands carry\n        if (q[15:12] == 4'b1010) begin // If thousands digit reaches 10, reset it to 0\n            q[15:12] <= 4'b0000;\n        end\n    end\nend\n\n// Enable signals logic\nassign ena[1] = (q[3:0] == 4'b1001); // Enable tens increment when ones is 9\nassign ena[2] = (q[7:4] == 4'b1001) && (q[3:0] == 4'b1001); // Enable hundreds increment when tens is 9 and ones is 9\nassign ena[3] = (q[11:8] == 4'b1001) && (q[7:4] == 4'b1001) && (q[3:0] == 4'b1001); // Enable thousands increment when hundreds is 9, tens is 9, and ones is 9\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Enable signals for the tens, hundreds, and thousands digits\nassign ena = {q[11:8] == 9 && q[7:4] == 9 && q[3:0] == 9,  // Thousands enable\n              q[7:4] == 9 && q[3:0] == 9,                 // Hundreds enable\n              q[3:0] == 9};                                // Tens enable\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 0;\n    end else begin\n        if (q[3:0] == 9) begin\n            q[3:0] <= 0; // Reset ones\n            if (q[7:4] == 9) begin\n                q[7:4] <= 0; // Reset tens\n                if (q[11:8] == 9) begin\n                    q[11:8] <= 0; // Reset hundreds\n                    if (q[15:12] == 9) begin\n                        q[15:12] <= 0; // Reset thousands\n                    end else begin\n                        q[15:12] <= q[15:12] + 1; // Increment thousands\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1; // Increment hundreds\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1; // Increment tens\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1; // Increment ones\n        end\n    end\nend\n\nendmodule\n"]}
