{"task_id": "ece241_2013_q12", "mutants": ["module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] q;\n    always @(posedge clk) begin\n        if (enable)\n            q <= {q[6:0], S}; // No change here\n    end\n    \n    assign Z = q[ {A, B, C} ]; // Changed the indexing to use A, B, C directly without braces (incorrect syntax to illustrate change)\n    \nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] q;\n    always @(posedge clk) begin\n        if (enable)\n            q <= {S, q[7:1]}; // Changed the shift direction, mistakenly shifting in the MSB instead of LSB\n    end\n    \n    assign Z = q[ {A, B, C} ];\n    \nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] q;\n    always @(posedge clk) begin\n        // Incorrect condition: changed 'if (enable)' to 'if (!enable)', inverting the enable condition\n        if (!enable)\n            q <= {q[6:0], S};\n    end\n    \n    assign Z = q[ {A, B, C} ];\n    \nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] q;\n    always @(negedge clk) begin // Changed the clock edge to negative edge\n        if (enable)\n            q <= {q[6:0], S};\n    end\n    \n    assign Z = q[ {A, B, C} ];\n    \nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] q;\n    always @(posedge clk) begin\n        if (enable)\n            q <= {q[6:0], !S}; // Inverted the input S before shifting in\n    end\n    \n    assign Z = q[ {A, B, C} ];\n    \nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] q = 8'b00000001; // Initialized q with a non-zero value\n    always @(posedge clk) begin\n        if (enable)\n            q <= {q[6:0], S};\n    end\n    \n    assign Z = q[ {A, B, C} ];\n    \nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] q;\n    always @(posedge clk) begin\n        if (enable)\n            q <= {q[5:0], S, q[7]}; // Incorrectly inserted S in the middle, preserving MSB\n    end\n    \n    assign Z = q[ {A, B, C} ];\n    \nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] q;\n    always @(posedge clk) begin\n        if (enable)\n            q[6:0] <= {q[6:0], S}; // Only shifting the lower 7 bits, leaving q[7] unchanged\n    end\n    \n    assign Z = q[ {A, B, C} ];\n    \nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:1] q; // Reduced the size of q, mistakenly making it 7 bits instead of 8\n    always @(posedge clk) begin\n        if (enable)\n            q <= {q[6:1], S}; // Adjusted for the new size of q\n    end\n    \n    assign Z = q[ {A, B, C} ]; // This will cause a compilation error due to mismatch in bit width\n    \nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] q;\n    always @(posedge clk) begin\n        if (enable)\n            q <= {q[6:0], q[7]}; // Recirculating the MSB instead of shifting in S\n    end\n    \n    assign Z = q[ {A, B, C} ];\n    \nendmodule\n"]}
{"task_id": "count1to10", "mutants": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 9) // Changed condition from q == 10 to q == 9\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 10)\n\t\t\tq <= 2; // Changed reset value from 1 to 2\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 10)\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= q + 2; // Changed increment from q+1 to q+2\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\tq <= 1; // Removed condition q == 10 for reset\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(negedge clk) // Changed posedge to negedge\n\t\tif (reset || q == 10)\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\tq <= 0; // Changed reset value from 1 to 0\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 10)\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= q - 1; // Changed increment to decrement (q-1)\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [2:0] q); // Changed bit width from [3:0] to [2:0]\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 10)\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (!reset || q == 10) // Changed reset condition to !reset\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 11) // Changed comparison from q == 10 to q == 11\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n"]}
{"task_id": "fsm3s", "mutants": ["module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    reg [1:0] state;\n    reg [1:0] next;\n    \n    always_comb begin\n        case (state)\n            A: next = in ? B : A; // No change\n            B: next = in ? B : C; // No change\n            C: next = in ? D : A; // No change\n            // Mutation: Change next state for D when in=0 from C to B\n            D: next = in ? B : B; // Changed here\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        if (reset) state <= A;\n        else state <= next;\n    end\n        \n    assign out = (state==D);\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    reg [1:0] state;\n    reg [1:0] next;\n    \n    always_comb begin\n        case (state)\n            A: next = in ? B : A; // No change\n            // Mutation: Change next state for B when in=0 from C to D\n            B: next = in ? B : D; // Changed here\n            C: next = in ? D : A; // No change\n            D: next = in ? B : C; // No change\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        if (reset) state <= A;\n        else state <= next;\n    end\n        \n    assign out = (state==D);\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    reg [1:0] state;\n    reg [1:0] next;\n    \n    always_comb begin\n        // Mutation: Change next state for A when in=1 from B to C\n        case (state)\n            A: next = in ? C : A; // Changed here\n            B: next = in ? B : C;\n            C: next = in ? D : A;\n            D: next = in ? B : C;\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        if (reset) state <= A;\n        else state <= next;\n    end\n        \n    assign out = (state==D);\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    reg [1:0] state;\n    reg [1:0] next;\n    \n    always_comb begin\n        case (state)\n            A: next = in ? B : A;\n            B: next = in ? B : C;\n            C: next = in ? D : A;\n            D: next = in ? B : C;\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        if (reset) state <= A;\n        // Mutation: Change state assignment to non-blocking\n        else state <= next; // No change (Clarification)\n    end\n    \n    // Mutation: Change output to be high when in state C instead of D\n    assign out = (state==C); // Changed here\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    reg [1:0] state;\n    reg [1:0] next;\n    \n    always_comb begin\n        case (state)\n            A: next = in ? B : A;\n            // Mutation: Change next state for B when in=1 from B to A\n            B: next = in ? A : C; // Changed here\n            C: next = in ? D : A;\n            D: next = in ? B : C;\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        if (reset) state <= A;\n        else state <= next;\n    end\n        \n    assign out = (state==D);\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    reg [1:0] state;\n    reg [1:0] next;\n    \n    always_comb begin\n        case (state)\n            A: next = in ? B : A;\n            B: next = in ? B : C;\n            C: next = in ? D : A;\n            D: next = in ? B : C;\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        if (reset) \n            // Mutation: Change reset state from A to B\n            state <= B; // Changed here\n        else state <= next;\n    end\n        \n    assign out = (state==D);\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    reg [1:0] state;\n    reg [1:0] next;\n    \n    always_comb begin\n        case (state)\n            A: next = in ? B : A;\n            B: next = in ? B : C;\n            // Mutation: Change next state for C when in=0 from A to B\n            C: next = in ? D : B; // Changed here\n            D: next = in ? B : C;\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        if (reset) state <= A;\n        else state <= next;\n    end\n        \n    assign out = (state==D);\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    reg [1:0] state;\n    reg [1:0] next;\n    \n    always_comb begin\n        case (state)\n            // Mutation: Change next state for A when in=0 from A to B\n            A: next = in ? B : B; // Changed here\n            B: next = in ? B : C;\n            C: next = in ? D : A;\n            D: next = in ? B : C;\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        if (reset) state <= A;\n        else state <= next;\n    end\n        \n    assign out = (state==D);\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    reg [1:0] state;\n    reg [1:0] next;\n    \n    always_comb begin\n        case (state)\n            A: next = in ? B : A;\n            B: next = in ? B : C;\n            C: next = in ? D : A;\n            // Mutation: Change next state for D when in=1 from B to A\n            D: next = in ? A : C; // Changed here\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        if (reset) state <= A;\n        else state <= next;\n    end\n        \n    assign out = (state==D);\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output out\n);\n    parameter A=0, B=1, C=2, D=3;\n    reg [1:0] state;\n    reg [1:0] next;\n    \n    always_comb begin\n        case (state)\n            A: next = in ? B : A;\n            B: next = in ? B : C;\n            // Mutation: Change next state for C when in=1 from D to B\n            C: next = in ? B : A; // Changed here\n            D: next = in ? B : C;\n        endcase\n    end\n    \n    always @(posedge clk) begin\n        if (reset) state <= A;\n        else state <= next;\n    end\n        \n    assign out = (state==D);\n\nendmodule\n"]}
{"task_id": "review2015_fsmshift", "mutants": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B1; // Changed B0 to B1 here\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = B3; // Changed Done to B3 here\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\tDone: next = B0; // Changed Done to loop back to B0\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B2; // Changed B0's next state to B2\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B2; // Changed B2's next state to loop on itself\n\t\t\tB3: next = Done;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B3; // Changed B1's next state to B3\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\t// Removed Done case entirely, implicitly latches\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=4, Done=4; // Changed parameter B3 to 4\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B0; // Changed B0's next state to loop on itself\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=3; // Changed Done parameter to 3, making it equivalent to B3\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n"]}
{"task_id": "conwaylife", "mutants": ["module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n    \n    \n    logic [323:0] q_pad;\n    always@(*) begin\n        for (int i=0;i<16;i++)\n            q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n        q_pad[1 +: 16] = q[16*15 +: 16];\n        q_pad[18*17+1 +: 16] = q[0 +: 16];\n        \n        for (int i=0; i<18; i++) begin\n            q_pad[i*18] = q_pad[i*18+16]; // Change: -1 to +16 to slightly modify the neighbor assignment logic\n            q_pad[i*18+17] = q_pad[i*18+1];\n        end\n    end\n    \n    always @(posedge clk) begin\n        for (int i=0;i<16;i++)\n        for (int j=0;j<16;j++) begin\n            q[i*16+j] <= \n                ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n                q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n                q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h3;\n        end\n        \n        if (load)\n            q <= data;\n        \n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n    \n    \n    logic [323:0] q_pad;\n    always@(*) begin\n        for (int i=0;i<16;i++)\n            q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n        q_pad[1 +: 16] = q[16*15 +: 16];\n        q_pad[18*17+1 +: 16] = q[0 +: 16];\n        \n        for (int i=0; i<18; i++) begin\n            q_pad[i*18] = q_pad[i*18+16];\n            q_pad[i*18+17] = q_pad[i*18+1]; // Change: +1 to -1 to slightly modify the neighbor assignment logic\n        end\n    end\n    \n    always @(posedge clk) begin\n        for (int i=0;i<16;i++)\n        for (int j=0;j<16;j++) begin\n            q[i*16+j] <= \n                ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n                q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n                q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h3;\n        end\n        \n        if (load)\n            q <= data;\n        \n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n    \n    \n    logic [323:0] q_pad;\n    always@(*) begin\n        for (int i=0;i<16;i++)\n            q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n        q_pad[1 +: 16] = q[16*15 +: 16];\n        q_pad[18*17+1 +: 16] = q[0 +: 16];\n        \n        for (int i=0; i<18; i++) begin\n            q_pad[i*18] = q_pad[i*18+16];\n            q_pad[i*18+17] = q_pad[i*18+1];\n        end\n    end\n    \n    always @(posedge clk) begin\n        for (int i=0;i<16;i++)\n        for (int j=0;j<16;j++) begin\n            q[i*16+j] <= \n                ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n                q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n                q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h2; // Change: 3'h3 to 3'h2 for the condition\n        end\n        \n        if (load)\n            q <= data;\n        \n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n    \n    \n    logic [323:0] q_pad;\n    always@(*) begin\n        for (int i=0;i<16;i++) \n            q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];  // Change: No change here, just a placeholder for consistency in mutant creation\n        q_pad[1 +: 16] = q[16*15 +: 16];\n        q_pad[18*17+1 +: 16] = q[0 +: 16];\n        \n        for (int i=0; i<18; i++) begin\n            q_pad[i*18] = q_pad[i*18+16];\n            q_pad[i*18+17] = q_pad[i*18+1];\n        end\n    end\n    \n    always @(posedge clk) begin\n        for (int i=0;i<16;i++)\n        for (int j=0;j<16;j++) begin\n            q[i*16+j] <= \n                ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n                q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n                q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h6 | q[i*16+j]) == 3'h3; // Change: & 3'h7 to & 3'h6 to modify condition mask\n        end\n        \n        if (load)\n            q <= data;\n        \n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n    \n    \n    logic [323:0] q_pad;\n    always@(*) begin\n        for (int i=0;i<16;i++)\n            q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n        q_pad[1 +: 16] = q[16*15 +: 16];\n        q_pad[18*17+1 +: 16] = q[0 +: 16];\n        \n        for (int i=0; i<18; i++) begin\n            q_pad[i*18] = q_pad[i*18+16];\n            q_pad[i*18+17] = q_pad[i*18+2]; // Change: +1 to +2 in neighbor assignment\n        end\n    end\n    \n    always @(posedge clk) begin\n        for (int i=0;i<16;i++)\n        for (int j=0;j<16;j++) begin\n            q[i*16+j] <= \n                ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n                q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n                q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h3;\n        end\n        \n        if (load)\n            q <= data;\n        \n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n    \n    \n    logic [323:0] q_pad;\n    always@(*) begin\n        for (int i=0;i<16;i++)\n            q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n        q_pad[1 +: 16] = q[16*15 +: 16]; // Change: No real change, serves as a placeholder for diversity\n        q_pad[18*17+1 +: 16] = q[0 +: 16];\n        \n        for (int i=0; i<18; i++) begin\n            q_pad[i*18] = q_pad[i*18+15]; // Change: +16 to +15 in neighbor assignment\n            q_pad[i*18+17] = q_pad[i*18+1];\n        end\n    end\n    \n    always @(posedge clk) begin\n        for (int i=0;i<16;i++)\n        for (int j=0;j<16;j++) begin\n            q[i*16+j] <= \n                ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n                q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n                q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h3;\n        end\n        \n        if (load)\n            q <= data;\n        \n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n    \n    \n    logic [323:0] q_pad;\n    always@(*) begin\n        for (int i=0;i<16;i++)\n            q_pad[18*(i+1)+1 +: 16] = q[16*i +: 15]; // Change: 16 to 15 to slightly modify the data assignment, missing out the last bit\n        q_pad[1 +: 16] = q[16*15 +: 16];\n        q_pad[18*17+1 +: 16] = q[0 +: 16];\n        \n        for (int i=0; i<18; i++) begin\n            q_pad[i*18] = q_pad[i*18+16];\n            q_pad[i*18+17] = q_pad[i*18+1];\n        end\n    end\n    \n    always @(posedge clk) begin\n        for (int i=0;i<16;i++)\n        for (int j=0;j<16;j++) begin\n            q[i*16+j] <= \n                ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n                q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n                q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h3;\n        end\n        \n        if (load)\n            q <= data;\n        \n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n    \n    \n    logic [323:0] q_pad;\n    always@(*) begin\n        for (int i=0;i<15;i++) // Change: 16 to 15, affects one less iteration\n            q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n        q_pad[1 +: 16] = q[16*15 +: 16];\n        q_pad[18*17+1 +: 16] = q[0 +: 16];\n        \n        for (int i=0; i<18; i++) begin\n            q_pad[i*18] = q_pad[i*18+16];\n            q_pad[i*18+17] = q_pad[i*18+1];\n        end\n    end\n    \n    always @(posedge clk) begin\n        for (int i=0;i<16;i++)\n        for (int j=0;j<16;j++) begin\n            q[i*16+j] <= \n                ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n                q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n                q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h3;\n        end\n        \n        if (load)\n            q <= data;\n        \n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n    \n    \n    logic [323:0] q_pad;\n    always@(*) begin\n        for (int i=0;i<16;i++)\n            q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n        q_pad[1 +: 16] = q[16*15 +: 16];\n        q_pad[18*17+1 +: 16] = q[0 +: 16];\n        \n        for (int i=0; i<18; i++) begin\n            q_pad[i*18] = q_pad[i*18+15]; // Change: +16 to +15 for a slight variation in neighbor padding logic\n            q_pad[i*18+17] = q_pad[i*18+1];\n        end\n    end\n    \n    always @(posedge clk) begin\n        for (int i=0;i<16;i++)\n        for (int j=0;j<16;j++) begin\n            q[i*16+j] <= \n                ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n                q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n                q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h3;\n        end\n        \n        if (load)\n            q <= data;\n        \n    end\n    \nendmodule\n"]}
{"task_id": "m2014_q4d", "mutants": ["module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\tinitial\n\t\tout = 1; // Changed initial value of out from 0 to 1\n\n\talways@(posedge clk) begin\n\t\tout <= in ^ out;\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\tinitial\n\t\tout = 0;\n\t\t\n\talways@(posedge clk) begin\n\t\tout <= in ^ !out; // Complemented the output in the XOR operation\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\tinitial\n\t\tout = 0;\n\t\t\n\talways@(negedge clk) begin // Changed posedge to negedge\n\t\tout <= in ^ out;\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\t// Removed the initial block entirely\n\talways@(posedge clk) begin\n\t\tout <= in ^ out;\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\tinitial\n\t\tout = 0;\n\t\t\n\talways@(posedge clk) begin\n\t\tout <= in & out; // Changed XOR (^) to AND (&)\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\tinitial\n\t\tout = 0;\n\t\t\n\talways@(posedge clk) begin\n\t\tout <= ~(in ^ out); // Negated the result of XOR\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\tinitial\n\t\tout = 0;\n\t\t\n\talways@(posedge clk) begin\n\t\tout <= in; // Removed XOR with out\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\tinitial\n\t\tout = 0;\n\t\t\n\talways@(posedge clk) begin\n\t\tout <= in ^ 1'b1; // XOR with constant 1\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\tinitial\n\t\tout = 0;\n\t\t\n\talways@(posedge clk) begin\n\t\tout <= {1'b0, in} ^ out; // Added 1'b0 to 'in' before XOR, this won't compile as intended and is considered a logic error due to width mismatch\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\tinitial\n\t\tout = 0;\n\t\t\n\talways@(posedge clk) begin\n\t\tout[0] <= in ^ out; // Attempt to assign to a bit slice of 'out', this is a logic error since 'out' is a single bit\n\tend\n\nendmodule\n"]}
{"task_id": "shift18", "mutants": ["module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) case (amount)\n\t\t\t2'b00: q <= {q[62:0], 1'b1}; // Changed 1'b0 to 1'b1 for LSB in left shift by 1\n\t\t\t2'b01: q <= {q[55:0], 8'b0};\n\t\t\t2'b10: q <= {q[63], q[63:1]};\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]};\n\t\t\tdefault: q <= 64'hx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) case (amount)\n\t\t\t2'b00: q <= {q[62:0], 1'b0};\n\t\t\t2'b01: q <= {q[55:0], 8'hFF}; // Changed 8'b0 to 8'hFF for LSB in left shift by 8\n\t\t\t2'b10: q <= {q[63], q[63:1]};\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]};\n\t\t\tdefault: q <= 64'hx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= ~data; // Complement of data is loaded instead of data itself\n\t\telse if (ena) case (amount)\n\t\t\t2'b00: q <= {q[62:0], 1'b0};\n\t\t\t2'b01: q <= {q[55:0], 8'b0};\n\t\t\t2'b10: q <= {q[63], q[63:1]};\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]};\n\t\t\tdefault: q <= 64'hx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (!ena) q <= q; // Added condition to maintain current state if 'ena' is low\n\t\telse case (amount)\n\t\t\t2'b00: q <= {q[62:0], 1'b0};\n\t\t\t2'b01: q <= {q[55:0], 8'b0};\n\t\t\t2'b10: q <= {q[63], q[63:1]};\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]};\n\t\t\tdefault: q <= 64'hx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) case (amount)\n\t\t\t2'b00: q <= {q[61:0], 2'b00}; // Shift left by 2 instead of 1\n\t\t\t2'b01: q <= {q[55:0], 8'b0};\n\t\t\t2'b10: q <= {q[63], q[63:1]};\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]};\n\t\t\tdefault: q <= 64'hx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) case (amount)\n\t\t\t2'b00: q <= {q[62:0], 1'b0};\n\t\t\t2'b01: q <= {q[55:0], 8'b0};\n\t\t\t2'b10: q <= {{1'b0}, q[63:1]}; // Changed MSB of right shift by 1 to 0\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]};\n\t\t\tdefault: q <= 64'hx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) case (amount)\n\t\t\t2'b00: q <= {q[62:0], 1'b0};\n\t\t\t2'b01: q <= {q[55:0], 8'b0};\n\t\t\t2'b10: q <= {q[63], q[63:1]};\n\t\t\t2'b11: q <= {{8{1'b0}}, q[63:8]}; // Changed replicated q[63] to 0 in right shift by 8\n\t\t\tdefault: q <= 64'hx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) case (amount)\n\t\t\t2'b00: q <= {q[63:0], 1'b0}; // Logically incorrect, attempting to concatenate beyond width\n\t\t\t2'b01: q <= {q[55:0], 8'b0};\n\t\t\t2'b10: q <= {q[63], q[63:1]};\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]};\n\t\t\tdefault: q <= 64'hx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) case (amount)\n\t\t\t2'b00: q <= {q[62:0], 1'b0};\n\t\t\t2'b01: q <= {q[56:0], 7'b0}; // Shift left by 7 instead of 8\n\t\t\t2'b10: q <= {q[63], q[63:1]};\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]};\n\t\t\tdefault: q <= 64'hx;\n\t\tendcase\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) case (amount)\n\t\t\t2'b00: q <= {q[62:0], 1'b0};\n\t\t\t2'b01: q <= {q[55:0], 8'b0};\n\t\t\t2'b10: q <= {q[63], q[63:1]};\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]};\n\t\t\tdefault: q <= 64'bz; // Changed 64'hx (don't care) to 64'bz (high impedance)\n\t\tendcase\n\tend\nendmodule\n"]}
{"task_id": "review2015_fsmseq", "mutants": ["module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S; // No change\n\t\t\tS1: next = data ? S11: S; // Changed from S to S1 (minor logical error)\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=5; // Changed Done value from 4 to 5, affecting the encoding\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S; \n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [3:0] state, next; // Changed reg bit width to [3:0] from [2:0]\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S; \n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S; \n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S110 : S110; // Changed from S11 : S110 to S110 : S110 (logical error)\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S1; // Changed from data ? S1: S to S1: S1 (logical error)\n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S : S; // Changed from data ? S1: S to S : S (stalls in state S)\n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S; \n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = !data ? Done : S; // Changed from data ? Done : S to !data ? Done : S (logical inversion)\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S; \n\t\t\tS1: next = !data ? S11: S; // Changed from data ? S11: S to !data ? S11: S (logical inversion)\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S; \n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S : S110; // Changed from data ? S11 : S110 to data ? S : S110 (logical error)\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S; \n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = data ? S : Done; // Changed from data ? Done : S to data ? S : Done (swap error and done conditions)\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\nendmodule\n"]}
{"task_id": "m2014_q4b", "mutants": ["module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 1; // Changed reset value to 1 instead of 0\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\tif (!ar) // Changed condition to negate \"ar\"\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= !d; // Changed data assignment to the negation of \"d\"\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or negedge ar) begin // Changed sensitivity to negedge of \"ar\" instead of posedge\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk) begin // Removed \"ar\" from sensitivity list\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d; // No change, commented out for demonstration\n\t\t// This is actually the original logic, wrongly indicated as a mutation for illustration.\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d & ar; // Changed assignment to \"d\" AND \"ar\"\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d | ar; // Changed assignment to \"d\" OR \"ar\"\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\t// Added dummy logic that does not affect functionality\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse if (!ar)\n\t\t\tq <= d;\n\t\telse\n\t\t\tq <= d; // Unnecessary else case\n\tend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d ^ ar; // Changed assignment to \"d\" XOR \"ar\"\n\tend\n\nendmodule\n"]}
{"task_id": "review2015_shiftcount", "mutants": ["module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[2:0], data }; // Changed from q[2:0] to q[3:1], incorrect shifting\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[2:1], data, q[0] }; // Changed bits position in the concatenation\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[2:0], data };\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b0; // Changed the decrement value to 0, no decrement\n\tend \n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[2:0], !data }; // Inverted the data bit\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { data, q[3:1] }; // Shifted in the data at the MSB, wrong shifting direction\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[1:0], data, q[3] }; // Altered bit positions in concatenation\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[3], q[2:0] }; // Incorrectly shifted q[3] into q[3] again\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[2:0], 1'b0 }; // Shifted in a 0 instead of data\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[2:0], data };\n\t\telse if (count_ena)\n\t\t\tq <= q + 1'b1; // Changed to increment instead of decrement\n\tend \n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { 2'b10, q[1:0] }; // Changed to shift in a constant value at the MSB\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n"]}
{"task_id": "dff8ar", "mutants": ["module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 8'hFF; // Change: Reset value changed from 0 to 255 (0xFF)\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk, negedge areset) // Change: Trigger on negative edge of areset instead of positive\n\t\tif (!areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk) // Change: Removed posedge areset from sensitivity list\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d[7:0]; // Redundant change: Explicitly specifying the full range of d\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput [6:0] d, // Change: Width of d reduced to 7 bits\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= {1'b0, d}; // Adding a leading zero to keep q's width consistent\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:1] q); // Change: Width of q reduced to 7 bits\n\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d[7:1]; // Ignoring the LSB of d\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 1; // Change: Reset value changed from 0 to 1\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d ^ 8'hFF; // Change: Inverting d before assignment to q\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= {d[6:0], d[7]}; // Change: Circular rotate right by 1\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq[7:1] <= d[6:0]; // Change: Assigning only lower 7 bits of d to higher 7 bits of q\n\t\t\tq[0] <= d[7]; // Assigning MSB of d to LSB of q\n\t\nendmodule\n"]}
{"task_id": "lfsr32", "mutants": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(q) begin\n\t\tq_next = q[31:1];\n\t\tq_next[31] = q[0];\n\t\tq_next[22] ^= q[0]; // Changed the tap from 21 to 22, which is incorrect per the original spec.\n\t\tq_next[1] ^= q[0];\n\t\tq_next[0] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(q) begin\n\t\tq_next = q[31:0]; // Removed the shift operation making q_next[31:1] equal to q[31:0].\n\t\tq_next[31] = q[0];\n\t\tq_next[21] ^= q[0];\n\t\tq_next[1] ^= q[0];\n\t\tq_next[0] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(q) begin\n\t\tq_next = q[31:1];\n\t\tq_next[31] = ~q[0]; // Inverted the q[0] value.\n\t\tq_next[21] ^= q[0];\n\t\tq_next[1] ^= q[0];\n\t\tq_next[0] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(q) begin\n\t\tq_next = q[31:1];\n\t\tq_next[31] = q[0];\n\t\tq_next[21] ^= q[0];\n\t\tq_next[2] ^= q[0]; // Changed the position to 2, which is already a tap, so no effective change in the logic.\n\t\tq_next[0] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(q) begin\n\t\tq_next = q[31:1];\n\t\tq_next[31] = q[0];\n\t\tq_next[21] ^= q[0];\n\t\tq_next[1] ^= ~q[0]; // Inverted the XOR operation input.\n\t\tq_next[0] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(q) begin\n\t\tq_next = q[31:1];\n\t\tq_next[31] = q[0];\n\t\tq_next[21] ^= q[0];\n\t\tq_next[1] ^= q[0];\n\t\tq_next[0] ^= ~q[0]; // Inverted the XOR operation input for the last bit.\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(posedge clk) begin // Changed the sensitivity list from @(q) to @(posedge clk).\n\t\tq_next = q[31:1];\n\t\tq_next[31] = q[0];\n\t\tq_next[21] ^= q[0];\n\t\tq_next[1] ^= q[0];\n\t\tq_next[0] ^= q[0];\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(reset) begin // Changed the sensitivity list to only trigger on reset.\n\t\tq_next = q[31:1];\n\t\tq_next[31] = q[0];\n\t\tq_next[21] ^= q[0];\n\t\tq_next[1] ^= q[0];\n\t\tq_next[0] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(q) begin\n\t\tq_next = {q[30:0], q[31]}; // Swapped the positions, effectively shifting the register the wrong way.\n\t\tq_next[31] = q[0];\n\t\tq_next[21] ^= q[0];\n\t\tq_next[1] ^= q[0];\n\t\tq_next[0] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(q) begin\n\t\tq_next = q[31:1];\n\t\tq_next[30] = q[0]; // Incorrectly assigned q[0] to q_next[30] instead of q_next[31].\n\t\tq_next[21] ^= q[0];\n\t\tq_next[1] ^= q[0];\n\t\tq_next[0] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n"]}
{"task_id": "2014_q4a", "mutants": ["module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tif (L)\n\t\t\tQ <= R; // Original: Q <= R; Mutant: no change, serves as a base for comparison.\n\t\telse if (E)\n\t\t\tQ <= !w; // Change: Negated the input w.\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tif (!L) // Change: Negated the condition for L.\n\t\t\tQ <= R;\n\t\telse if (E)\n\t\t\tQ <= w;\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tif (L)\n\t\t\tQ <= !R; // Change: Negated the input R.\n\t\telse if (E)\n\t\t\tQ <= w;\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tif (L)\n\t\t\tQ <= R;\n\t\telse if (!E) // Change: Negated the condition for E.\n\t\t\tQ <= w;\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tif (L)\n\t\t\tQ <= R;\n\t\telse if (E)\n\t\t\tQ <= Q; // Change: Q is assigned to itself instead of w.\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tif (L)\n\t\t\tQ <= R;\n\t\telse if (E) // Original condition\n\t\t\tQ <= w; // Original action\n\t\t// Change: Added a redundant else statement that does nothing.\n\t\telse\n\t\t\tQ <= Q;\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tif (L)\n\t\t\tQ <= w; // Change: The value of Q is set to w instead of R when L is asserted.\n\t\telse if (E)\n\t\t\tQ <= w;\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tif (L)\n\t\t\tQ <= R;\n\t\telse if (E)\n\t\t\tQ <= R; // Change: The value of Q is set to R instead of w when E is asserted.\n\t\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\t// Change: Removed the always block thereby making Q constant.\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tif (L)\n\t\t\tQ <= R;\n\t\telse if (E)\n\t\t\tQ <= 1'b0; // Change: The value of Q is set to a constant 0 when E is asserted.\n\t\nendmodule\n"]}
{"task_id": "alwaysblock2", "mutants": ["module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a ^ b;\n\talways @(*) out_always_comb = a ^ b;\n\talways @(posedge clk) out_always_ff <= a & b; // Changed XOR to AND for out_always_ff\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a ^ b;\n\talways @(*) out_always_comb = a | b; // Changed XOR to OR for out_always_comb\n\talways @(posedge clk) out_always_ff <= a ^ b;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a & b; // Changed XOR to AND for out_assign\n\talways @(*) out_always_comb = a ^ b;\n\talways @(posedge clk) out_always_ff <= a ^ b;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a ^ b;\n\talways @(*) out_always_comb = ~(a ^ b); // Added inversion to out_always_comb\n\talways @(posedge clk) out_always_ff <= a ^ b;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a ^ b;\n\talways @(*) out_always_comb = a ^ b;\n\talways @(posedge clk) out_always_ff <= ~(a ^ b); // Added inversion to out_always_ff\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a ^~ b; // Added inversion to b for out_assign\n\talways @(*) out_always_comb = a ^ b;\n\talways @(posedge clk) out_always_ff <= a ^ b;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a ^ b;\n\talways @(*) out_always_comb = a ^~ b; // Added inversion to b for out_always_comb\n\talways @(posedge clk) out_always_ff <= a ^ b;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a ^ b;\n\talways @(*) out_always_comb = a ^ b;\n\talways @(posedge clk) out_always_ff <= a ^~ b; // Added inversion to b for out_always_ff\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a ~^ b; // Changed XOR to XNOR for out_assign\n\talways @(*) out_always_comb = a ^ b;\n\talways @(posedge clk) out_always_ff <= a ^ b;\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a ^ b;\n\talways @(*) out_always_comb = a ~^ b; // Changed XOR to XNOR for out_always_comb\n\talways @(posedge clk) out_always_ff <= a ^ b;\nendmodule\n"]}
{"task_id": "countbcd", "mutants": ["module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\twire [3:0] enable = { q[11:0]==12'h998, q[7:0]==8'h99, q[3:0] == 4'h9, 1'b1}; // Changed 12'h999 to 12'h998\n\tassign ena = enable[3:1];\n\talways @(posedge clk)\n\t\tfor (int i=0;i<4;i++) begin\n\t\t\tif (reset || (q[i*4 +:4] == 9 && enable[i]))\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\twire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h98, q[3:0] == 4'h9, 1'b1}; // Changed 8'h99 to 8'h98\n\tassign ena = enable[3:1];\n\talways @(posedge clk)\n\t\tfor (int i=0;i<4;i++) begin\n\t\t\tif (reset || (q[i*4 +:4] == 9 && enable[i]))\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\twire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0] == 4'h8, 1'b1}; // Changed 4'h9 to 4'h8\n\tassign ena = enable[3:1];\n\talways @(posedge clk)\n\t\tfor (int i=0;i<4;i++) begin\n\t\t\tif (reset || (q[i*4 +:4] == 9 && enable[i]))\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\twire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0] == 4'h9, 1'b0}; // Changed 1'b1 to 1'b0\n\tassign ena = enable[3:1];\n\talways @(posedge clk)\n\t\tfor (int i=0;i<4;i++) begin\n\t\t\tif (reset || (q[i*4 +:4] == 9 && enable[i]))\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\twire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0] == 4'h9, 1'b1};\n\tassign ena = enable[3:1];\n\talways @(posedge clk)\n\t\tfor (int i=0;i<3;i++) begin // Changed loop limit from 4 to 3\n\t\t\tif (reset || (q[i*4 +:4] == 9 && enable[i]))\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\twire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0] == 4'h9, 1'b1};\n\tassign ena = enable[3:1];\n\talways @(posedge clk)\n\t\tfor (int i=0;i<4;i++) begin\n\t\t\tif (reset || (q[i*4 +:4] == 8 && enable[i])) // Changed comparison value from 9 to 8\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\twire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0] == 4'h9, 1'b1};\n\tassign ena = enable[3:1];\n\talways @(posedge clk)\n\t\tfor (int i=1;i<4;i++) begin // Changed loop start from 0 to 1\n\t\t\tif (reset || (q[i*4 +:4] == 9 && enable[i]))\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\twire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0] == 4'h9, 1'b1};\n\tassign ena = enable[2:0]; // Changed enable[3:1] to enable[2:0]\n\talways @(posedge clk)\n\t\tfor (int i=0;i<4;i++) begin\n\t\t\tif (reset || (q[i*4 +:4] == 9 && enable[i]))\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\twire [3:0] enable = { q[11:0]==12'h997, q[7:0]==8'h99, q[3:0] == 4'h9, 1'b1}; // Changed 12'h999 to 12'h997\n\tassign ena = enable[3:1];\n\talways @(posedge clk)\n\t\tfor (int i=0;i<4;i++) begin\n\t\t\tif (reset || (q[i*4 +:4] == 9 && enable[i]))\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\n\twire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0] == 4'hA, 1'b1}; // Changed 4'h9 to 4'hA\n\tassign ena = enable[3:1];\n\talways @(posedge clk)\n\t\tfor (int i=0;i<4;i++) begin\n\t\t\tif (reset || (q[i*4 +:4] == 9 && enable[i]))\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n"]}
