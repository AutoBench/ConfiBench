{"task_id": "mux2to1v", "task_number": 1, "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "header": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "module_code": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic [99:0] a,b,\n\toutput logic sel,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\ta <= 'hdeadbeef;\n\t\tb <= 'h5eaf00d;\n\t\tsel <= 0;\n\t\t@(negedge clk);\n\t\twavedrom_start(\"Beef or seafood?\");\n\t\t\trepeat(6) @(posedge clk) sel <= ~sel;\n\t\t@(negedge clk);\n\t\twavedrom_stop();\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,sel} <= {$random, $random, $random, $random, $random, $random, $random};\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [99:0] a;\n\tlogic [99:0] b;\n\tlogic sel;\n\tlogic [99:0] out_ref;\n\tlogic [99:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,a,b,sel,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.sel );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.sel,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "m2014_q6b", "task_number": 2, "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "header": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "module_code": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0;\n\t\t\t4'h1: Y2 = 1'b0;\n\t\t\t4'h2: Y2 = 1'b1;\n\t\t\t4'h3: Y2 = 1'b1;\n\t\t\t4'h4: Y2 = 1'b0;\n\t\t\t4'h5: Y2 = 1'b1;\n\t\t\t4'h6: Y2 = 1'b0;\n\t\t\t4'h7: Y2 = 1'b0;\n\t\t\t4'h8: Y2 = 1'b0;\n\t\t\t4'h9: Y2 = 1'b1;\n\t\t\t4'ha: Y2 = 1'b1;\n\t\t\t4'hb: Y2 = 1'b1;\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0;\n\t\t\t4'h1: Y2 = 1'b0;\n\t\t\t4'h2: Y2 = 1'b1;\n\t\t\t4'h3: Y2 = 1'b1;\n\t\t\t4'h4: Y2 = 1'b0;\n\t\t\t4'h5: Y2 = 1'b1;\n\t\t\t4'h6: Y2 = 1'b0;\n\t\t\t4'h7: Y2 = 1'b0;\n\t\t\t4'h8: Y2 = 1'b0;\n\t\t\t4'h9: Y2 = 1'b1;\n\t\t\t4'ha: Y2 = 1'b1;\n\t\t\t4'hb: Y2 = 1'b1;\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg [3:1] y,\n\toutput reg w\n);\n\n\tinitial begin\n\t\trepeat(100) @(posedge clk, negedge clk) begin\n\t\t\t{y,w} <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_Y2;\n\t\tint errortime_Y2;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [3:1] y;\n\tlogic w;\n\tlogic Y2_ref;\n\tlogic Y2_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,y,w,Y2_ref,Y2_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.y,\n\t\t.w );\n\treference_module good1 (\n\t\t.y,\n\t\t.w,\n\t\t.Y2(Y2_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.y,\n\t\t.w,\n\t\t.Y2(Y2_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_Y2) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Y2\", stats1.errors_Y2, stats1.errortime_Y2);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Y2\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { Y2_ref } === ( { Y2_ref } ^ { Y2_dut } ^ { Y2_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (Y2_ref !== ( Y2_ref ^ Y2_dut ^ Y2_ref ))\n\t\tbegin if (stats1.errors_Y2 == 0) stats1.errortime_Y2 = $time;\n\t\t\tstats1.errors_Y2 = stats1.errors_Y2+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "ringer", "task_number": 3, "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "header": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "module_code": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring & ~vibrate_mode;\n\tassign motor = ring & vibrate_mode;\n\t\nendmodule\n", "testbench": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring & ~vibrate_mode;\n\tassign motor = ring & vibrate_mode;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg ring, vibrate_mode,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{vibrate_mode,ring} <= 1'b0;\n\t\twavedrom_start();\n\t\trepeat(10) @(posedge clk)\n\t\t\t{vibrate_mode,ring} <= count++;\t\t\n\t\twavedrom_stop();\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_ringer;\n\t\tint errortime_ringer;\n\t\tint errors_motor;\n\t\tint errortime_motor;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic ring;\n\tlogic vibrate_mode;\n\tlogic ringer_ref;\n\tlogic ringer_dut;\n\tlogic motor_ref;\n\tlogic motor_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,ring,vibrate_mode,ringer_ref,ringer_dut,motor_ref,motor_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.ring,\n\t\t.vibrate_mode );\n\treference_module good1 (\n\t\t.ring,\n\t\t.vibrate_mode,\n\t\t.ringer(ringer_ref),\n\t\t.motor(motor_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.ring,\n\t\t.vibrate_mode,\n\t\t.ringer(ringer_dut),\n\t\t.motor(motor_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_ringer) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"ringer\", stats1.errors_ringer, stats1.errortime_ringer);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"ringer\");\n\t\tif (stats1.errors_motor) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"motor\", stats1.errors_motor, stats1.errortime_motor);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"motor\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { ringer_ref, motor_ref } === ( { ringer_ref, motor_ref } ^ { ringer_dut, motor_dut } ^ { ringer_ref, motor_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (ringer_ref !== ( ringer_ref ^ ringer_dut ^ ringer_ref ))\n\t\tbegin if (stats1.errors_ringer == 0) stats1.errortime_ringer = $time;\n\t\t\tstats1.errors_ringer = stats1.errors_ringer+1'b1; end\n\t\tif (motor_ref !== ( motor_ref ^ motor_dut ^ motor_ref ))\n\t\tbegin if (stats1.errors_motor == 0) stats1.errortime_motor = $time;\n\t\t\tstats1.errors_motor = stats1.errors_motor+1'b1; end\n\n\tend\nendmodule\n"}